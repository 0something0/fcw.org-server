diff -Nurd -X.diff_ignore freeciv/common/aicore/path_finding.c freeciv/common/aicore/path_finding.c
--- freeciv/common/aicore/path_finding.c	2014-09-03 00:11:59.242084668 +0300
+++ freeciv/common/aicore/path_finding.c	2014-09-06 03:35:14.982612378 +0300
@@ -3416,8 +3416,7 @@
 
   return (result
           + uclass_number(utype_class(parameter->utype))
-          + (parameter->move_rate << 4)
-          + (parameter->utype->unknown_move_cost << 8));
+          + (parameter->move_rate << 6));
 }
 
 /****************************************************************************
@@ -3432,14 +3431,7 @@
     return FALSE;
   }
 
-  if (parameter1->utype == parameter2->utype) {
-    /* Short test. */
-    return TRUE;
-  }
-
-  if (utype_class(parameter1->utype) != utype_class(parameter2->utype)
-      || (parameter1->utype->unknown_move_cost
-          != parameter2->utype->unknown_move_cost)) {
+  if (utype_class(parameter1->utype) != utype_class(parameter2->utype)) {
     return FALSE;
   }
 
@@ -3470,46 +3462,24 @@
 
   if (!param->omniscience
       && TILE_UNKNOWN == tile_get_known(to_tile, param->owner)) {
-    cost = param->utype->unknown_move_cost;
-  }
-
-  if (to_tile == param->start_tile) {
-    /* Attack point. Do not consider if attack is possible, because we
-     * also want to be frighten by transports. */
     cost = SINGLE_MOVE;
+  } else if (!is_native_tile(param->utype, to_tile)
+             && !tile_city(to_tile)) {
+    return -1;  /* Impossible move. */
   } else {
-    const struct unit_class *uclass = utype_class(param->utype);
-    const struct city *pcity = tile_city(to_tile);
-
-    if (NULL != pcity) {
-      /* Not allied cities are reputed impregnable! */
-      if (!pplayers_allied(city_owner(pcity), param->owner)) {
-        return -1; /* Impossible move. */
-      }
-    } else {
-      if (!is_native_tile_to_class(uclass, to_tile)
-          || (NULL == tile_city(from_tile)
-              && !is_native_move(uclass, from_tile, to_tile))) {
-        return -1; /* Impossible move. */
-      }
-    }
-
     cost = map_move_cost(param->owner, param->utype, from_tile, to_tile);
-    if (cost > param->utype->move_rate) {
-      cost = param->utype->move_rate;
-    }
   }
 
-  cost += to_cost;
-  if (cost > FC_PTR_TO_INT(param->data)) {
-    return -1; /* We reached the maximum we wanted. */
-  } else if (*from_cost == PF_IMPOSSIBLE_MC || cost < *from_cost) {
-    /* Uninitialized yet, or better route. */
-    *from_cost = cost;
+  if (to_cost + cost > FC_PTR_TO_INT(param->data)) {
+    return -1;  /* We reached the maximum we wanted. */
+  } else if (*from_cost == PF_IMPOSSIBLE_MC     /* Uninitialized yet. */
+             || to_cost + cost < *from_cost) {
+    *from_cost = to_cost + cost;
     /* N.B.: We don't deal with from_extra. */
   }
 
-  return cost;
+  /* Let's calculate some priority. */
+  return MAX(3 * SINGLE_MOVE - cost, 0);
 }
 
 /****************************************************************************
@@ -3566,9 +3536,8 @@
   Returns the map for the unit type. Creates it if needed.
 ****************************************************************************/
 static inline struct pf_map *
-pf_reverse_map_get_map(struct pf_reverse_map *pfrm,
-                       const struct unit_type *punittype,
-                       int move_rate)
+pf_reverse_map_utype_map(struct pf_reverse_map *pfrm,
+                         const struct unit_type *punittype)
 {
   struct pf_map *pfm;
   struct pf_parameter *param;
@@ -3576,8 +3545,8 @@
 
   param = &pfrm->param;
   param->utype = punittype;
-  param->move_rate = move_rate;
-  param->moves_left_initially = move_rate;
+  param->move_rate = punittype->move_rate;
+  param->moves_left_initially = punittype->move_rate;
 
   if (pf_map_hash_lookup(pfrm->hash, param, &pfm)) {
     fc_assert(NULL != pfm);
@@ -3595,38 +3564,6 @@
 }
 
 /****************************************************************************
-  Returns the map for the unit. Creates it if needed.
-****************************************************************************/
-static inline struct pf_map *
-pf_reverse_map_unit_map(struct pf_reverse_map *pfrm,
-                        const struct unit *punit)
-{
-  return pf_reverse_map_get_map(pfrm, unit_type(punit),
-                                unit_move_rate(punit));
-}
-
-/****************************************************************************
-  Returns the map for the unit type. Creates it if needed.
-****************************************************************************/
-static inline struct pf_map *
-pf_reverse_map_utype_map(struct pf_reverse_map *pfrm,
-                         const struct unit_type *punittype,
-                         const struct tile *ptile)
-{
-  const struct player *pplayer = pfrm->param.owner;
-  int veteran_level = get_unittype_bonus(pplayer, ptile, punittype,
-                                         EFT_VETERAN_BUILD);
-
-  if (veteran_level >= utype_veteran_levels(punittype)) {
-    veteran_level = utype_veteran_levels(punittype) - 1;
-  }
-
-  return pf_reverse_map_get_map(pfrm, punittype,
-             utype_move_rate(punittype, ptile, pplayer, veteran_level,
-                             punittype->hp));
-}
-
-/****************************************************************************
   Get the move costs that a unit type needs to reach the start tile. Returns
   PF_IMPOSSIBLE_MC if the tile is unreachable.
 ****************************************************************************/
@@ -3634,7 +3571,7 @@
                                    const struct unit_type *punittype,
                                    struct tile *ptile)
 {
-  struct pf_map *pfm = pf_reverse_map_utype_map(pfrm, punittype, ptile);
+  struct pf_map *pfm = pf_reverse_map_utype_map(pfrm, punittype);
 
   return pfm->get_move_cost(pfm, ptile);
 }
@@ -3646,7 +3583,7 @@
 int pf_reverse_map_unit_move_cost(struct pf_reverse_map *pfrm,
                                   const struct unit *punit)
 {
-  struct pf_map *pfm = pf_reverse_map_unit_map(pfrm, punit);
+  struct pf_map *pfm = pf_reverse_map_utype_map(pfrm, unit_type(punit));
 
   return pfm->get_move_cost(pfm, unit_tile(punit));
 }
@@ -3659,7 +3596,7 @@
                                           const struct unit_type *punittype,
                                           struct tile *ptile)
 {
-  struct pf_map *pfm = pf_reverse_map_utype_map(pfrm, punittype, ptile);
+  struct pf_map *pfm = pf_reverse_map_utype_map(pfrm, punittype);
 
   return pfm->get_path(pfm, ptile);
 }
@@ -3671,38 +3608,9 @@
 struct pf_path *pf_reverse_map_unit_path(struct pf_reverse_map *pfrm,
                                          const struct unit *punit)
 {
-  struct pf_map *pfm = pf_reverse_map_unit_map(pfrm, punit);
-  struct pf_path *path = pfm->get_path(pfm, unit_tile(punit));
-  const struct pf_parameter *param;
-  int i, diff;
-
-  if (NULL == path) {
-    return NULL;
-  }
-
-  /* Adjust some values. */
-  param = pf_map_parameter(pfm);
-  if (0 >= param->move_rate) {
-    fc_assert(1 == path->length);
-    path->positions[0].moves_left = punit->moves_left;
-    return path;
-  }
-
-  fc_assert(1 <= path->length);
-  diff = path->positions[path->length - 1].moves_left - punit->moves_left;
-  for (i = 0; i < path->length; i++) {
-    struct pf_position *pos = path->positions + i;
-
-    pos->moves_left -= diff;
-    pos->moves_left %= param->move_rate;
-    if (0 > pos->moves_left) {
-      pos->moves_left += param->move_rate;
-    }
-    pos->turn = ((pos->total_MC + param->move_rate - pos->moves_left)
-                 / param->move_rate);
-  }
+  struct pf_map *pfm = pf_reverse_map_utype_map(pfrm, unit_type(punit));
 
-  return path;
+  return pfm->get_path(pfm, unit_tile(punit));
 }
 
 /****************************************************************************
@@ -3713,7 +3621,7 @@
                                    struct tile *ptile,
                                    struct pf_position *pos)
 {
-  struct pf_map *pfm = pf_reverse_map_utype_map(pfrm, punittype, ptile);
+  struct pf_map *pfm = pf_reverse_map_utype_map(pfrm, punittype);
 
   return pfm->get_position(pfm, ptile, pos);
 }
@@ -3725,19 +3633,7 @@
                                   const struct unit *punit,
                                   struct pf_position *pos)
 {
-  struct pf_map *pfm = pf_reverse_map_unit_map(pfrm, punit);
-  const struct pf_parameter *param;
-
-  if (!pfm->get_position(pfm, unit_tile(punit), pos)) {
-    return FALSE;
-  }
+  struct pf_map *pfm = pf_reverse_map_utype_map(pfrm, unit_type(punit));
 
-  /* Adjust some values. */
-  param = pf_map_parameter(pfm);
-  if (0 < param->move_rate) {
-    pos->turn = ((pos->total_MC + param->move_rate - punit->moves_left)
-                 / param->move_rate);
-  }
-  pos->moves_left = punit->moves_left;
-  return TRUE;
+  return pfm->get_position(pfm, unit_tile(punit), pos);
 }
diff -Nurd -X.diff_ignore freeciv/common/movement.c freeciv/common/movement.c
--- freeciv/common/movement.c	2014-08-22 02:29:50.198043905 +0300
+++ freeciv/common/movement.c	2014-09-06 03:32:53.634937438 +0300
@@ -38,61 +38,47 @@
 #include "movement.h"
 
 /****************************************************************************
-  This function calculates the move rate of the unit, taking into account
-  the penalty for reduced hitpoints, the active effects, and any veteran
+  This function calculates the move rate of the unit, taking into 
+  account the penalty for reduced hitpoints (affects sea and land 
+  units only), the effects of wonders for sea units, and any veteran
   bonuses.
-
-  'utype' and 'pplayer' must be set. 'ptile' can be NULL.
 ****************************************************************************/
-int utype_move_rate(const struct unit_type *utype, const struct tile *ptile,
-                    const struct player *pplayer, int veteran_level,
-                    int hitpoints)
+int unit_move_rate(const struct unit *punit)
 {
-  const struct unit_class *uclass;
+  int move_rate = 0;
+  int base_move_rate;
+  struct unit_class *pclass;
   const struct veteran_level *vlevel;
-  int base_move_rate, move_rate;
 
-  fc_assert_ret_val(NULL != utype, 0);
-  fc_assert_ret_val(NULL != pplayer, 0);
-  vlevel = utype_veteran_level(utype, veteran_level);
-  fc_assert_ret_val(NULL != vlevel, 0);
-  uclass = utype_class(utype);
+  fc_assert_ret_val(punit != NULL, 0);
 
-  base_move_rate = utype->move_rate + vlevel->move_bonus;
+  vlevel = utype_veteran_level(unit_type(punit), punit->veteran);
+  fc_assert_ret_val(vlevel != NULL, 0);
+
+  base_move_rate = unit_type(punit)->move_rate + vlevel->move_bonus;
   move_rate = base_move_rate;
 
-  if (uclass_has_flag(uclass, UCF_DAMAGE_SLOWS)) {
+  pclass = unit_class(punit);
+
+  if (uclass_has_flag(pclass, UCF_DAMAGE_SLOWS)) {
     /* Scale the MP based on how many HP the unit has. */
-    move_rate = (move_rate * hitpoints) / utype->hp;
+    move_rate = (move_rate * punit->hp) / unit_type(punit)->hp;
   }
 
   /* Add on effects bonus (Magellan's Expedition, Lighthouse,
    * Nuclear Power). */
-  move_rate += (get_unittype_bonus(pplayer, ptile, utype, EFT_MOVE_BONUS)
-                * SINGLE_MOVE);
+  move_rate += (get_unit_bonus(punit, EFT_MOVE_BONUS) * SINGLE_MOVE);
 
   /* Don't let the move_rate be less than min_speed unless the base_move_rate is
    * also less than min_speed. */
-  if (move_rate < uclass->min_speed) {
-    move_rate = MIN(uclass->min_speed, base_move_rate);
+  if (move_rate < pclass->min_speed) {
+    move_rate = MIN(pclass->min_speed, base_move_rate);
   }
 
   return move_rate;
 }
 
 /****************************************************************************
-  This function calculates the move rate of the unit. See utype_move_rate()
-  for further details.
-****************************************************************************/
-int unit_move_rate(const struct unit *punit)
-{
-  fc_assert_ret_val(NULL != punit, 0);
-
-  return utype_move_rate(unit_type(punit), unit_tile(punit),
-                         unit_owner(punit), punit->veteran, punit->hp);
-}
-
-/****************************************************************************
   This function calculates the movement cost to unknown tiles. The base
   value is equal to the highest movement cost the unit can encounter. If
   the unit cannot enter all terrains, a malus is applied.
diff -Nurd -X.diff_ignore freeciv/common/movement.h freeciv/common/movement.h
--- freeciv/common/movement.h	2014-08-22 02:29:50.650042865 +0300
+++ freeciv/common/movement.h	2014-09-06 03:32:53.634937438 +0300
@@ -46,9 +46,6 @@
   MR_NON_NATIVE_MOVE,  /* Usually RMM_RELAXED road diagonally without link */
 };
 
-int utype_move_rate(const struct unit_type *utype, const struct tile *ptile,
-                    const struct player *pplayer, int veteran_level,
-                    int hitpoints);
 int unit_move_rate(const struct unit *punit);
 int utype_unknown_move_cost(const struct unit_type *utype);
 
