diff -Nurd -X.diff_ignore freeciv/client/packhand.c freeciv/client/packhand.c
--- freeciv/client/packhand.c	2015-05-22 01:06:23.521182281 +0300
+++ freeciv/client/packhand.c	2015-07-28 14:18:06.032342232 +0300
@@ -614,42 +614,13 @@
   } else {
     name_changed = (0 != strncmp(packet->name, pcity->name,
                                  sizeof(pcity->name)));
-    if (options.draw_city_trade_routes) {
-      bool old_still_present[MAX_TRADE_ROUTES];
-
-      for (i = 0; i < MAX_TRADE_ROUTES; i++) {
-        if (packet->trade[i] == 0) {
-          old_still_present[i] = TRUE; /* Not present, but not 'old' either */
-        } else {
-          old_still_present[i] = FALSE;
-        }
-      }
 
-      trade_routes_iterate(pcity, proute) {
-        bool found = FALSE;
-
-        for (i = 0; i < MAX_TRADE_ROUTES; i++) {
-          if (packet->trade[i] == proute->partner) {
-            old_still_present[i] = TRUE;
-            found = TRUE;
-            break;
-          }
-        }
-
-        if (!found) {
-          trade_routes_changed = TRUE;
-          break;
-        }
-      } trade_routes_iterate_end;
+    while (trade_route_list_size(pcity->routes) > packet->traderoute_count) {
+      struct trade_route *proute = trade_route_list_get(pcity->routes, -1);
 
-      if (!trade_routes_changed) {
-        for (i = 0; i < MAX_TRADE_ROUTES; i++) {
-          if (!old_still_present[i]) {
-            trade_routes_changed = TRUE;
-            break;
-          }
-        }
-      }
+      trade_route_list_remove(pcity->routes, proute);
+      FC_FREE(proute);
+      trade_routes_changed = TRUE;
     }
 
     /* Descriptions should probably be updated if the
@@ -710,24 +681,6 @@
 
   pcity->city_options = packet->city_options;
 
-  /* Rebuild trade routes */
-  trade_routes_iterate_safe(pcity, pold) {
-    trade_route_list_remove(pcity->routes, pold);
-    free(pold);
-  } trade_routes_iterate_safe_end;
-
-  for (i = 0; i < MAX_TRADE_ROUTES; i++) {
-    if (packet->trade[i] != 0) {
-      struct trade_route *proute = fc_malloc(sizeof(struct trade_route));
-
-      proute->partner = packet->trade[i];
-      proute->value = packet->trade_value[i];
-      proute->dir = packet->trade_direction[i];
-
-      trade_route_list_append(pcity->routes, proute);
-    }
-  }
-
   if (pcity->surplus[O_SCIENCE] != packet->surplus[O_SCIENCE]
       || pcity->surplus[O_SCIENCE] != packet->surplus[O_SCIENCE]
       || pcity->waste[O_SCIENCE] != packet->waste[O_SCIENCE]
@@ -1008,6 +961,38 @@
 }
 
 /****************************************************************************
+  A traderoute-info packet contains information about one end of a traderoute
+****************************************************************************/
+void handle_traderoute_info(const struct packet_traderoute_info *packet)
+{
+  struct city *pcity = game_city_by_number(packet->city);
+  struct trade_route *proute;
+  bool city_changed = FALSE;
+
+  if (pcity == NULL) {
+    return;
+  }
+
+  proute = trade_route_list_get(pcity->routes, packet->index);
+  if (proute == NULL) {
+    fc_assert(trade_route_list_size(pcity->routes) == packet->index);
+
+    proute = fc_malloc(sizeof(struct trade_route));
+    trade_route_list_append(pcity->routes, proute);
+    city_changed = TRUE;
+  }
+
+  proute->partner = packet->partner;
+  proute->value = packet->value;
+  proute->dir = packet->direction;
+
+  if (options.draw_city_trade_routes && city_changed) {
+    update_city_description(pcity);
+    update_map_canvas_visible();
+  }
+}
+
+/****************************************************************************
   A city-short-info packet is sent to tell us about any cities we can't see
   the internals of.  Most of the time this includes any cities owned by
   someone else.
diff -Nurd -X.diff_ignore freeciv/common/packets.def freeciv/common/packets.def
--- freeciv/common/packets.def	2015-07-25 12:05:18.816391695 +0300
+++ freeciv/common/packets.def	2015-07-28 14:10:26.897190007 +0300
@@ -3,7 +3,7 @@
 Max used id:
 ============
 
-Max id: 247
+Max id: 248
 
 Packets are not ordered by their id, but by their category. New packet
 with higher id may get added to existing category, and not to the end of file.
@@ -619,9 +619,7 @@
   SINT16 usage[O_LAST];
   UINT16 food_stock, shield_stock;
 
-  UINT16 trade[MAX_TRADE_ROUTES];
-  UINT8 trade_value[MAX_TRADE_ROUTES];
-  RDIR trade_direction[MAX_TRADE_ROUTES];
+  UINT8 traderoute_count;
 
   UINT16 pollution;
   UINT16 illness_trade;
@@ -672,6 +670,14 @@
   STRING name[MAX_LEN_NAME];
 end
 
+PACKET_TRADEROUTE_INFO = 248; sc, lsend, handle-via-packet
+  CITY city;
+  UINT8 index;
+  CITY partner;
+  UINT8 value;
+  RDIR direction;
+end
+
 PACKET_CITY_SELL = 33; cs, dsend
   CITY city_id;
   UINT8 build_id;
diff -Nurd -X.diff_ignore freeciv/server/citytools.c freeciv/server/citytools.c
--- freeciv/server/citytools.c	2015-07-25 12:05:17.600393720 +0300
+++ freeciv/server/citytools.c	2015-07-28 14:15:17.488667352 +0300
@@ -2032,14 +2032,18 @@
   struct packet_city_info packet;
   struct packet_city_short_info sc_pack;
   struct player *powner = city_owner(pcity);
+  struct traderoute_packet_list *routes = traderoute_packet_list_new();
 
   /* Send to everyone who can see the city. */
-  package_city(pcity, &packet, FALSE);
+  package_city(pcity, &packet, routes, FALSE);
   players_iterate(pplayer) {
     if (can_player_see_city_internals(pplayer, pcity)) {
       if (!send_city_suppressed || pplayer != powner) {
         update_dumb_city(powner, pcity);
         lsend_packet_city_info(powner->connections, &packet, FALSE);
+        traderoute_packet_list_iterate(routes, route_packet) {
+          lsend_packet_traderoute_info(powner->connections, route_packet);
+        } traderoute_packet_list_iterate_end;
       }
     } else {
       if (map_is_known_and_seen(pcity->tile, pplayer, V_MAIN)
@@ -2057,6 +2061,11 @@
       send_packet_city_info(pconn, &packet, FALSE);
     }
   } conn_list_iterate_end;
+
+  traderoute_packet_list_iterate(routes, route_packet) {
+    FC_FREE(route_packet);
+  } traderoute_packet_list_iterate_end;
+  traderoute_packet_list_destroy(routes);
 }
 
 /**************************************************************************
@@ -2068,6 +2077,7 @@
   conn_list_do_buffer(dest);
   conn_list_iterate(dest, pconn) {
     struct player *pplayer = pconn->playing;
+
     if (!pplayer && !pconn->observer) {
       continue;
     }
@@ -2160,6 +2170,7 @@
   struct packet_city_info packet;
   struct packet_city_short_info sc_pack;
   struct player *powner = NULL;
+  struct traderoute_packet_list *routes = NULL;
 
   if (!pcity) {
     pcity = tile_city(ptile);
@@ -2171,15 +2182,23 @@
     /* send info to owner */
     /* This case implies powner non-NULL which means pcity non-NULL */
     if (!send_city_suppressed) {
+      routes = traderoute_packet_list_new();
+
       /* send all info to the owner */
       update_dumb_city(powner, pcity);
-      package_city(pcity, &packet, FALSE);
+      package_city(pcity, &packet, routes, FALSE);
       lsend_packet_city_info(dest, &packet, FALSE);
+      traderoute_packet_list_iterate(routes, route_packet) {
+        lsend_packet_traderoute_info(dest, route_packet);
+      } traderoute_packet_list_iterate_end;
       if (dest == powner->connections) {
         /* HACK: send also a copy to global observers. */
         conn_list_iterate(game.est_connections, pconn) {
           if (conn_is_global_observer(pconn)) {
             send_packet_city_info(pconn, &packet, FALSE);
+            traderoute_packet_list_iterate(routes, route_packet) {
+              send_packet_traderoute_info(pconn, route_packet);
+            } traderoute_packet_list_iterate_end;
           }
         } conn_list_iterate_end;
       }
@@ -2188,8 +2207,13 @@
     /* send info to non-owner */
     if (!pviewer) {	/* observer */
       if (pcity) {
-	package_city(pcity, &packet, FALSE);   /* should be dumb_city info? */
+        routes = traderoute_packet_list_new();
+
+	package_city(pcity, &packet, routes, FALSE);   /* should be dumb_city info? */
         lsend_packet_city_info(dest, &packet, FALSE);
+        traderoute_packet_list_iterate(routes, route_packet) {
+          lsend_packet_traderoute_info(dest, route_packet);
+        } traderoute_packet_list_iterate_end;
       }
     } else {
       if (!map_is_known(ptile, pviewer)) {
@@ -2210,12 +2234,20 @@
       }
     }
   }
+
+  if (routes != NULL) {
+    traderoute_packet_list_iterate(routes, route_packet) {
+      FC_FREE(route_packet);
+    } traderoute_packet_list_iterate_end;
+    traderoute_packet_list_destroy(routes);
+  }
 }
 
 /**************************************************************************
   Fill city info packet with information about given city.
 **************************************************************************/
 void package_city(struct city *pcity, struct packet_city_info *packet,
+                  struct traderoute_packet_list *routes,
 		  bool dipl_invest)
 {
   int i;
@@ -2292,7 +2324,7 @@
 
       /* And repackage */
       recursion = TRUE;
-      package_city(pcity, packet, dipl_invest);
+      package_city(pcity, packet, routes, dipl_invest);
       recursion = FALSE;
 
       return;
@@ -2303,16 +2335,20 @@
 
   i = 0;
   trade_routes_iterate(pcity, proute) {
-    packet->trade[i] = proute->partner;
-    packet->trade_value[i] = proute->value;
-    packet->trade_direction[i] = proute->dir;
+    struct packet_traderoute_info *tri_packet = fc_malloc(sizeof(struct packet_traderoute_info));
+
+    tri_packet->city = pcity->id;
+    tri_packet->index = i;
+    tri_packet->partner = proute->partner;
+    tri_packet->value = proute->value;
+    tri_packet->direction = proute->dir;
+
+    traderoute_packet_list_append(routes, tri_packet);
 
     i++;
   } trade_routes_iterate_end;
 
-  for (; i < MAX_TRADE_ROUTES; i++) {
-    packet->trade[i] = 0;
-  }
+  packet->traderoute_count = i;
 
   output_type_iterate(o) {
     packet->surplus[o] = pcity->surplus[o];
diff -Nurd -X.diff_ignore freeciv/server/citytools.h freeciv/server/citytools.h
--- freeciv/server/citytools.h	2015-05-17 14:58:03.445565651 +0300
+++ freeciv/server/citytools.h	2015-07-28 13:12:20.609059950 +0300
@@ -18,6 +18,13 @@
 #include "packets.h"
 #include "unitlist.h"
 
+#define SPECLIST_TAG traderoute_packet
+#define SPECLIST_TYPE struct packet_traderoute_info
+#include "speclist.h"
+#define traderoute_packet_list_iterate(ptrlist, ptr) \
+    TYPED_LIST_ITERATE(struct packet_traderoute_info, ptrlist, ptr)
+#define traderoute_packet_list_iterate_end LIST_ITERATE_END
+
 int build_points_left(struct city *pcity);
 int do_make_unit_veteran(struct city *pcity,
 			 const struct unit_type *punittype);
@@ -44,6 +51,7 @@
 void send_all_known_cities(struct conn_list *dest);
 void send_player_cities(struct player *pplayer);
 void package_city(struct city *pcity, struct packet_city_info *packet,
+                  struct traderoute_packet_list *routes,
 		  bool dipl_invest);
 
 void reality_check_city(struct player *pplayer, struct tile *ptile);
diff -Nurd -X.diff_ignore freeciv/server/diplomats.c freeciv/server/diplomats.c
--- freeciv/server/diplomats.c	2015-07-25 12:05:17.604393713 +0300
+++ freeciv/server/diplomats.c	2015-07-28 13:35:03.281985835 +0300
@@ -163,6 +163,7 @@
   struct player *cplayer;
   struct packet_unit_short_info unit_packet;
   struct packet_city_info city_packet;
+  struct traderoute_packet_list *routes;
 
   /* Fetch target city's player.  Sanity checks. */
   if (!pcity) {
@@ -203,10 +204,16 @@
   } unit_list_iterate_end;
   /* Send city info to investigator's player.
      As this is a special case we bypass send_city_info. */
-  package_city(pcity, &city_packet, TRUE);
+  routes = traderoute_packet_list_new();
+  package_city(pcity, &city_packet, routes, TRUE);
   /* We need to force to send the packet to ensure the client will receive
    * something and popup the city dialog. */
   lsend_packet_city_info(pplayer->connections, &city_packet, TRUE);
+  traderoute_packet_list_iterate(routes, route_packet) {
+    lsend_packet_traderoute_info(pplayer->connections, route_packet);
+    FC_FREE(route_packet);
+  } traderoute_packet_list_iterate_end;
+  traderoute_packet_list_destroy(routes);
 
   /* Charge a nominal amount of movement for this. */
   (pdiplomat->moves_left)--;
