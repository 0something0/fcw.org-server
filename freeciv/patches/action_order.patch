From 64511bed1594edc17b986da72cf2a1bd87e09567 Mon Sep 17 00:00:00 2001
From: Sveinung Kvilhaugsvik <sveinung84@users.sourceforge.net>
Date: Wed, 29 Jul 2015 21:54:18 +0200
Subject: [PATCH 3/4] Add initial action support to the orders system

Only support Explode Nuclear at tile the unit is on for now.
---
 client/control.c   |  2 ++
 client/goto.c      |  7 +++++++
 client/packhand.c  |  1 +
 common/packets.def |  2 ++
 common/unit.h      |  3 +++
 server/savegame.c  |  1 +
 server/savegame2.c |  1 +
 server/savegame3.c | 44 +++++++++++++++++++++++++++++++++++++++++++-
 server/unithand.c  | 30 ++++++++++++++++++++++++++++++
 server/unittools.c | 25 +++++++++++++++++++++++++
 10 files changed, 115 insertions(+), 1 deletion(-)

diff --git a/client/control.c b/client/control.c
index 3a0b51c..512037c 100644
--- a/client/control.c
+++ b/client/control.c
@@ -1347,6 +1347,7 @@ void request_unit_return(struct unit *punit)
       order.dir = -1;
       order.activity = ACTIVITY_SENTRY;
       order.target = EXTRA_NONE;
+      order.action = ACTION_COUNT;
       send_goto_path(punit, path, &order);
     } else {
       send_goto_path(punit, path, NULL);
@@ -1563,6 +1564,7 @@ void request_move_unit_direction(struct unit *punit, int dir)
   p.dir[0] = dir;
   p.activity[0] = ACTIVITY_LAST;
   p.target[0] = EXTRA_NONE;
+  p.action[0] = ACTION_COUNT;
 
   send_packet_unit_orders(&client.conn, &p);
 }
diff --git a/client/goto.c b/client/goto.c
index f999729..130ff69 100644
--- a/client/goto.c
+++ b/client/goto.c
@@ -1384,12 +1384,14 @@ static void send_path_orders(struct unit *punit, struct pf_path *path,
       p.dir[i] = -1;
       p.activity[i] = ACTIVITY_LAST;
       p.target[i] = EXTRA_NONE;
+      p.action[i] = ACTION_COUNT;
       log_goto_packet("  packet[%d] = wait: %d,%d", i, TILE_XY(old_tile));
     } else {
       p.orders[i] = ORDER_MOVE;
       p.dir[i] = get_direction_for_step(old_tile, new_tile);
       p.activity[i] = ACTIVITY_LAST;
       p.target[i] = EXTRA_NONE;
+      p.action[i] = ACTION_COUNT;
       log_goto_packet("  packet[%d] = move %s: %d,%d => %d,%d",
                       i, dir_get_name(p.dir[i]),
                       TILE_XY(old_tile), TILE_XY(new_tile));
@@ -1409,6 +1411,7 @@ static void send_path_orders(struct unit *punit, struct pf_path *path,
     p.activity[i] = (final_order->order == ORDER_ACTIVITY)
       ? final_order->activity : ACTIVITY_LAST;
     p.target[i] = final_order->target;
+    p.action[i] = ACTION_COUNT;
     p.length++;
   }
 
@@ -1504,6 +1507,7 @@ static bool order_recursive_roads(struct tile *ptile, struct extra_type *pextra,
   p->dir[p->length] = -1;
   p->activity[p->length] = ACTIVITY_GEN_ROAD;
   p->target[p->length] = extra_index(pextra);
+  p->action[p->length] = ACTION_COUNT;
   p->length++;
 
   return TRUE;
@@ -1552,6 +1556,7 @@ void send_connect_route(enum unit_activity activity,
           p.dir[p.length] = -1;
 	  p.activity[p.length] = ACTIVITY_IRRIGATE;
           p.target[p.length] = extra_index(tgt);
+          p.action[p.length] = ACTION_COUNT;
 	  p.length++;
 	}
 	break;
@@ -1572,6 +1577,7 @@ void send_connect_route(enum unit_activity activity,
 	p.dir[p.length] = get_direction_for_step(old_tile, new_tile);
         p.activity[p.length] = ACTIVITY_LAST;
         p.target[p.length] = EXTRA_NONE;
+        p.action[p.length] = ACTION_COUNT;
 	p.length++;
 
 	old_tile = new_tile;
@@ -1616,6 +1622,7 @@ void send_goto_route(void)
       order.dir = -1;
       order.activity = ACTIVITY_LAST;
       order.target = EXTRA_NONE;
+      order.action = ACTION_COUNT;
 
       /* ORDER_MOVE would require real direction,
        * ORDER_ACTIVITY would require real activity */
diff --git a/client/packhand.c b/client/packhand.c
index 0b0640e..26ba789 100644
--- a/client/packhand.c
+++ b/client/packhand.c
@@ -232,6 +232,7 @@ static struct unit *unpackage_unit(const struct packet_unit_info *packet)
       punit->orders.list[i].dir = packet->orders_dirs[i];
       punit->orders.list[i].activity = packet->orders_activities[i];
       punit->orders.list[i].target = packet->orders_targets[i];
+      punit->orders.list[i].action = packet->orders_actions[i];
     }
   }
 
diff --git a/common/packets.def b/common/packets.def
index e90308d..63918ee 100644
--- a/common/packets.def
+++ b/common/packets.def
@@ -903,6 +903,7 @@ PACKET_UNIT_INFO = 63; sc, lsend, is-game-info, cancel(PACKET_UNIT_SHORT_INFO)
   DIRECTION orders_dirs[MAX_LEN_ROUTE:orders_length];
   ACTIVITY orders_activities[MAX_LEN_ROUTE:orders_length];
   EXTRA orders_targets[MAX_LEN_ROUTE:orders_length];
+  GEN_ACTION orders_actions[MAX_LEN_ROUTE:orders_length];
 end
 
 PACKET_UNIT_SHORT_INFO = 64; sc, lsend, is-game-info, force, cancel(PACKET_UNIT_INFO)
@@ -958,6 +959,7 @@ PACKET_UNIT_ORDERS = 73; cs
   DIRECTION dir[MAX_LEN_ROUTE:length];
   ACTIVITY activity[MAX_LEN_ROUTE:length];
   EXTRA target[MAX_LEN_ROUTE:length];
+  GEN_ACTION action[MAX_LEN_ROUTE:length];
   TILE dest_tile;
 end
 
diff --git a/common/unit.h b/common/unit.h
index 99be818..0822673 100644
--- a/common/unit.h
+++ b/common/unit.h
@@ -41,6 +41,7 @@ enum unit_orders {
   ORDER_TRADE_ROUTE = 6,
   ORDER_HOMECITY = 7,
   ORDER_ACTION_MOVE = 8,
+  ORDER_PERFORM_ACTION = 9,
   /* and plenty more for later... */
   ORDER_LAST
 };
@@ -100,6 +101,8 @@ struct unit_order {
   enum unit_orders order;
   enum unit_activity activity;  /* Only valid for ORDER_ACTIVITY. */
   int target;
+  /* Only valid for ORDER_PERFORM_ACTION */
+  int action;
   enum direction8 dir;          /* Only valid for ORDER_MOVE. */
 };
 
diff --git a/server/savegame.c b/server/savegame.c
index b29db61..c52bfe8 100644
--- a/server/savegame.c
+++ b/server/savegame.c
@@ -1495,6 +1495,7 @@ static void player_load_units(struct player *plr, int plrno,
 	  order->order = char2order(orders_buf[j]);
 	  order->dir = char2dir(dir_buf[j]);
 	  order->activity = char2activity(act_buf[j]);
+          order->action = ACTION_COUNT;
 	  if (order->order == ORDER_LAST
 	      || (order->order == ORDER_MOVE && !direction8_is_valid(order->dir))
 	      || (order->order == ORDER_ACTIVITY
diff --git a/server/savegame2.c b/server/savegame2.c
index 0b4214f..b33e2e4 100644
--- a/server/savegame2.c
+++ b/server/savegame2.c
@@ -3885,6 +3885,7 @@ static bool sg_load_player_unit(struct loaddata *loading,
         order->order = char2order(orders_unitstr[j]);
         order->dir = char2dir(dir_unitstr[j]);
         order->activity = char2activity(act_unitstr[j]);
+        order->action = ACTION_COUNT;
         if (order->order == ORDER_LAST
             || (order->order == ORDER_MOVE && !direction8_is_valid(order->dir))
             || (order->order == ORDER_ACTIVITY
diff --git a/server/savegame3.c b/server/savegame3.c
index 82f3228..cc0c0b2 100644
--- a/server/savegame3.c
+++ b/server/savegame3.c
@@ -723,6 +723,9 @@ static enum unit_orders char2order(char order)
   case 'x':
   case 'X':
     return ORDER_ACTION_MOVE;
+  case 'p':
+  case 'P':
+    return ORDER_PERFORM_ACTION;
   }
 
   /* This can happen if the savegame is invalid. */
@@ -753,6 +756,8 @@ static char order2char(enum unit_orders order)
     return 'h';
   case ORDER_ACTION_MOVE:
     return 'x';
+  case ORDER_PERFORM_ACTION:
+    return 'p';
   case ORDER_LAST:
     break;
   }
@@ -1644,6 +1649,26 @@ static void sg_save_savefile(struct savedata *saving)
     free(modname);
   }
 
+  /* Save action order in the savegame. */
+  secfile_insert_int(saving->file, ACTION_COUNT,
+                     "savefile.action_size");
+  if (ACTION_COUNT > 0) {
+    const char **modname;
+    int j;
+
+    i = 0;
+    modname = fc_calloc(ACTION_COUNT, sizeof(*modname));
+
+    for (j = 0; j < ACTION_COUNT; j++) {
+      modname[i++] = gen_action_name(j);
+    }
+
+    secfile_insert_str_vec(saving->file, modname,
+                           ACTION_COUNT,
+                           "savefile.action_vector");
+    free(modname);
+  }
+
   /* Save terrain character mapping in the savegame. */
   i = 0;
   terrain_type_iterate(pterr) {
@@ -5032,6 +5057,7 @@ static bool sg_load_player_unit(struct loaddata *loading,
     if (len > 0) {
       const char *orders_unitstr, *dir_unitstr, *act_unitstr;
       const char *tgt_unitstr;
+      const char *action_unitstr;
 
       punit->orders.list = fc_malloc(len * sizeof(*(punit->orders.list)));
       punit->orders.length = len;
@@ -5057,12 +5083,15 @@ static bool sg_load_player_unit(struct loaddata *loading,
       tgt_unitstr
         = secfile_lookup_str_default(loading->file, NULL, "%s.tgt_list", unitstr);
 
+      action_unitstr
+        = secfile_lookup_str_default(loading->file, "",
+                                     "%s.action_list", unitstr);
       punit->has_orders = TRUE;
       for (j = 0; j < len; j++) {
         struct unit_order *order = &punit->orders.list[j];
 
         if (orders_unitstr[j] == '\0' || dir_unitstr[j] == '\0'
-            || act_unitstr[j] == '\0') {
+            || act_unitstr[j] == '\0' || action_unitstr == '\0') {
           log_sg("Invalid unit orders.");
           free_unit_orders(punit);
           break;
@@ -5070,6 +5099,11 @@ static bool sg_load_player_unit(struct loaddata *loading,
         order->order = char2order(orders_unitstr[j]);
         order->dir = char2dir(dir_unitstr[j]);
         order->activity = char2activity(act_unitstr[j]);
+
+        order->action = (action_unitstr[j] == '?'
+                         ? ACTION_COUNT
+                         : char2num(action_unitstr[j]));
+
         if (order->order == ORDER_LAST
             || (order->order == ORDER_MOVE && !direction8_is_valid(order->dir))
             || (order->order == ORDER_ACTIVITY
@@ -5258,6 +5292,7 @@ static void sg_save_player_units(struct savedata *saving,
       int len = punit->orders.length, j;
       char orders_buf[len + 1], dir_buf[len + 1];
       char act_buf[len + 1], tgt_buf[len + 1];
+      char action_buf[len + 1];
 
       secfile_insert_int(saving->file, len, "%s.orders_length", buf);
       secfile_insert_int(saving->file, punit->orders.index,
@@ -5272,6 +5307,7 @@ static void sg_save_player_units(struct savedata *saving,
         dir_buf[j] = '?';
         act_buf[j] = '?';
         tgt_buf[j] = '?';
+        action_buf[j] = '?';
         switch (punit->orders.list[j].order) {
         case ORDER_MOVE:
           dir_buf[j] = dir2char(punit->orders.list[j].dir);
@@ -5280,6 +5316,9 @@ static void sg_save_player_units(struct savedata *saving,
           tgt_buf[j] = num2char(punit->orders.list[j].target);
           act_buf[j] = activity2char(punit->orders.list[j].activity);
           break;
+        case ORDER_PERFORM_ACTION:
+          action_buf[j] = num2char(punit->orders.list[j].action);
+          break;
         case ORDER_FULL_MP:
         case ORDER_BUILD_CITY:
         case ORDER_DISBAND:
@@ -5292,11 +5331,13 @@ static void sg_save_player_units(struct savedata *saving,
         }
       }
       orders_buf[len] = dir_buf[len] = act_buf[len] = tgt_buf[len] = '\0';
+      action_buf[len] = '\0';
 
       secfile_insert_str(saving->file, orders_buf, "%s.orders_list", buf);
       secfile_insert_str(saving->file, dir_buf, "%s.dir_list", buf);
       secfile_insert_str(saving->file, act_buf, "%s.activity_list", buf);
       secfile_insert_str(saving->file, tgt_buf, "%s.tgt_list", buf);
+      secfile_insert_str(saving->file, action_buf, "%s.action_list", buf);
     } else {
       /* Put all the same fields into the savegame - otherwise the
        * registry code can't correctly use a tabular format and the
@@ -5309,6 +5350,7 @@ static void sg_save_player_units(struct savedata *saving,
       secfile_insert_str(saving->file, "-", "%s.dir_list", buf);
       secfile_insert_str(saving->file, "-", "%s.activity_list", buf);
       secfile_insert_str(saving->file, "-", "%s.tgt_list", buf);
+      secfile_insert_str(saving->file, "-", "%s.action_list", buf);
     }
 
     i++;
diff --git a/server/unithand.c b/server/unithand.c
index 05aa230..41e4851 100644
--- a/server/unithand.c
+++ b/server/unithand.c
@@ -3502,6 +3502,35 @@ void handle_unit_orders(struct player *pplayer,
       }
 
       break;
+    case ORDER_PERFORM_ACTION:
+      switch ((enum gen_action) packet->action[i]) {
+      case ACTION_NUKE:
+        break;
+      default:
+        log_error("handle_unit_orders() the action %s isn't allowed in "
+                  "orders. "
+                  "Sent in order number %d from %s to unit number %d.",
+                  action_get_rule_name(packet->action[i]), i,
+                  player_name(pplayer), packet->unit_id);
+
+        return;
+      }
+
+      switch (action_get_target_kind(packet->action[i])) {
+      case ATK_CITY:
+        break;
+      case ATK_UNIT:
+        break;
+      case ATK_UNITS:
+        break;
+      case ATK_TILE:
+        break;
+      case ATK_COUNT:
+        fc_assert(action_get_target_kind(packet->action[i]) != ATK_COUNT);
+        break;
+      }
+
+      break;
     case ORDER_FULL_MP:
     case ORDER_BUILD_CITY:
     case ORDER_DISBAND:
@@ -3547,6 +3576,7 @@ void handle_unit_orders(struct player *pplayer,
     punit->orders.list[i].dir = packet->dir[i];
     punit->orders.list[i].activity = packet->activity[i];
     punit->orders.list[i].target = packet->target[i];
+    punit->orders.list[i].action = packet->action[i];
   }
 
   if (!packet->repeat) {
diff --git a/server/unittools.c b/server/unittools.c
index fccab98..462af66 100644
--- a/server/unittools.c
+++ b/server/unittools.c
@@ -2306,6 +2306,7 @@ void package_unit(struct unit *punit, struct packet_unit_info *packet)
       packet->orders_dirs[i] = punit->orders.list[i].dir;
       packet->orders_activities[i] = punit->orders.list[i].activity;
       packet->orders_targets[i] = punit->orders.list[i].target;
+      packet->orders_actions[i] = punit->orders.list[i].action;
     }
   } else {
     packet->orders_length = packet->orders_index = 0;
@@ -3740,6 +3741,7 @@ static int order_to_action(struct unit *punit, enum unit_orders order)
   case ORDER_ACTIVITY:
   case ORDER_DISBAND:
   case ORDER_HOMECITY:
+  case ORDER_PERFORM_ACTION:
   case ORDER_LAST:
     /* Not action enabler controlled. */
     break;
@@ -3850,6 +3852,12 @@ bool execute_orders(struct unit *punit, const bool fresh)
         return TRUE;
       }
       break;
+    case ORDER_PERFORM_ACTION:
+      if (should_wait_for_mp(punit, order.action)) {
+        log_debug("  stopping. Not enough move points this turn");
+        return TRUE;
+      }
+      break;
     case ORDER_ACTIVITY:
     case ORDER_DISBAND:
     case ORDER_HOMECITY:
@@ -4114,6 +4122,23 @@ bool execute_orders(struct unit *punit, const bool fresh)
       } else {
 	return FALSE;
       }
+    case ORDER_PERFORM_ACTION:
+      log_debug("  orders: doing action %d", order.action);
+
+      fc_assert_msg(
+            action_get_target_kind(order.action) == ATK_TILE,
+            "Only tile targets are currently supported");
+
+      dst_tile = unit_tile(punit);
+
+      fc_assert_ret_val_msg(dst_tile, FALSE, "No target tile for action");
+
+      handle_unit_do_action(pplayer,
+                            unitid,
+                            dst_tile->index,
+                            0, "", order.action);
+
+      return player_unit_by_number(pplayer, unitid);
     case ORDER_LAST:
       cancel_orders(punit, "  client sent invalid order!");
       notify_player(pplayer, unit_tile(punit), E_UNIT_ORDERS, ftc_server,
-- 
2.1.4

