diff -Nurd -X.diff_ignore freeciv/configure.ac freeciv/configure.ac
--- freeciv/configure.ac	2012-05-16 21:12:05.000000000 +0300
+++ freeciv/configure.ac	2012-05-16 22:10:11.000000000 +0300
@@ -714,6 +714,31 @@
 		 AC_MSG_ERROR(Did not find math lib!))
     fi
 fi
+
+
+dnl The following adds flags for libcurl
+    AC_MSG_CHECKING(for libcurl 7.11.0 or later)
+    set x `curl-config --version 2>&1`
+    shift
+    case "$1" in [[0-9]*]) ;; *) shift;; esac
+    jigdo_curlver="$1"
+    AC_MSG_RESULT($jigdo_curlver)
+    case "$jigdo_curlver" in
+        [[1-9][0-9].*|[8-9].*|7.1[1-9]*|7.[2-9][0-9]*])
+            CFLAGS="$CFLAGS `curl-config --cflags 2>/dev/null`"
+            SERVER_LIBS="$SERVER_LIBS `curl-config --libs 2>/dev/null`"
+            if test -n "$jigdo_libcurl"; then CURLLIBS="$jigdo_libcurl"; fi
+            ;;
+        *)
+        AC_MSG_RESULT([   * libcurl not installed, or the installed version])
+        AC_MSG_RESULT([   * is too old, or curl-config is not in \$PATH.])
+        AC_MSG_RESULT([   * Please install libcurl 7.11.0 or later, it is])
+        AC_MSG_RESULT([   * needed by the jigdo GUI application.])
+        installDevel "libcurl2" "libcurl2"
+    esac
+
+
+
 AC_SUBST(SERVER_LIBS)
 
 AC_CHECK_LIB(nls,main)
diff -Nurd -X.diff_ignore freeciv/server/aws4c.c freeciv/server/aws4c.c
--- freeciv/server/aws4c.c	1970-01-01 02:00:00.000000000 +0200
+++ freeciv/server/aws4c.c	2012-05-16 22:10:12.000000000 +0300
@@ -0,0 +1,1218 @@
+/**
+
+*/
+
+/*
+ *
+ * Copyright(c) 2009,  Vlad Korolev,  <vlad[@]v-lad.org >
+ * 
+ * with contributions from Henry Nestler < Henry at BigFoot.de >
+ *
+ * This software is licensed as described in the file COPYING, which
+ * you should have received as part of this distribution. The terms
+ * are also available at http://www.gnu.org/licenses/lgpl-3.0.txt
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the COPYING file.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ */
+
+/*!
+  \mainpage
+
+  This is a small library that provides Amazon Web Services binding
+  for C programs.  
+  
+  The AWS4C leverages CURL and OPENSSL libraries for HTTP transfer and 
+  cryptographic functions.
+
+  The \ref todo list is here.
+
+  The \ref bug list is here.
+
+*/
+
+/// \todo Include regression testing
+/// \todo Run thing through valgrind
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <curl/curl.h>
+#include <openssl/hmac.h>
+#include <openssl/evp.h>
+#include <openssl/bio.h>
+#include <openssl/buffer.h>
+
+#include "aws4c.h"
+
+
+/*!
+  \defgroup internal Internal Functions
+  \{
+*/
+
+static int debug = 0;   /// <flag to control debugging options
+static char * ID       = NULL;  /// <Current ID
+static char * awsKeyID = NULL;  /// <AWS Key ID
+static char * awsKey   = NULL;  /// <AWS Key Material
+static char * S3Host     = "s3.amazonaws.com";     /// <AWS S3 host
+/// \todo Use SQSHost in SQS functions
+static char * SQSHost  = "queue.amazonaws.com";  /// <AWS SQS host
+static char * Bucket   = NULL;
+static char * MimeType = NULL;
+static char * AccessControl = NULL;
+
+static void __debug ( char *fmt, ... ) ;
+static char * __aws_get_iso_date ();
+static char * __aws_get_httpdate ();
+static FILE * __aws_getcfg ();
+static int s3_do_get ( IOBuf *b, char * const signature, 
+			  char * const date, char * const resource );
+static int s3_do_put ( IOBuf *b, char * const signature, 
+			  char * const date, char * const resource );
+static char* __aws_sign ( char * const str );
+static void __chomp ( char  * str );
+
+#ifdef ENABLE_UNBASE64
+/// Decode base64 into binary
+/// \param input base64 text
+/// \param length length of the input text
+/// \return decoded data in  newly allocated buffer
+/// \internal
+///
+/// This function allocates a buffer of the same size as the input
+/// buffer and then decodes the given base64 encoded text into 
+/// binary.   The result is placed into the allocated buffer. It is
+/// the caller's responsibility to free this buffer
+static char *unbase64(unsigned char *input, int length)
+{
+  BIO *b64, *bmem;
+
+  /// Allocate and zero the buffer
+  char *buffer = (char *)malloc(length);
+  memset(buffer, 0, length);
+
+  /// Decode the input into the newly allocated buffer
+  /// \todo Check for errors during decode
+  b64 = BIO_new(BIO_f_base64());
+  bmem = BIO_new_mem_buf(input, length);
+  bmem = BIO_push(b64, bmem);
+
+  BIO_read(bmem, buffer, length);
+
+  BIO_free_all(bmem);
+
+  /// Return the decoded text
+  return buffer;
+}
+#endif /* ENABLE_UNBASE64 */
+
+/// Encode a binary into base64 buffer
+/// \param input binary data  text
+/// \param length length of the input text
+/// \internal
+/// \return a newly allocated buffer with base64 encoded data 
+static char *__b64_encode(const unsigned char *input, int length)
+{
+  BIO *bmem, *b64;
+  BUF_MEM *bptr;
+
+  b64 = BIO_new(BIO_f_base64());
+  bmem = BIO_new(BIO_s_mem());
+  b64 = BIO_push(b64, bmem);
+  BIO_write(b64, input, length);
+  if(BIO_flush(b64)) ; /* make gcc 4.1.2 happy */
+  BIO_get_mem_ptr(b64, &bptr);
+
+  char *buff = (char *)malloc(bptr->length);
+  memcpy(buff, bptr->data, bptr->length-1);
+  buff[bptr->length-1] = 0;
+
+  BIO_free_all(b64);
+
+  return buff;
+}
+
+/// Chomp (remove the trailing '\n' from the string
+/// \param str string
+static void __chomp ( char  * str )
+{
+  if ( str[0] == 0 ) return;
+  int ln = strlen(str);
+  ln--;
+  if ( str[ln] == '\n' ) str[ln] = 0;
+  if ( ln == 0 ) return ;
+  ln--;
+  if ( str[ln] == '\r' ) str[ln] = 0;
+}
+
+/// Handles reception of the data
+/// \param ptr pointer to the incoming data
+/// \param size size of the data member
+/// \param nmemb number of data memebers
+/// \param stream pointer to I/O buffer
+/// \return number of bytes processed
+static size_t writefunc ( void * ptr, size_t size, size_t nmemb, void * stream )
+{
+  __debug ( "DATA RCVD %d items of size %d ",  nmemb, size );
+  aws_iobuf_append ( stream, ptr, nmemb*size );
+  return nmemb * size;
+}
+
+/// Suppress outputs to stdout
+static size_t writedummyfunc ( void * ptr, size_t size, size_t nmemb, void * stream )
+{
+  return nmemb * size;
+}
+
+/// Handles sending of the data
+/// \param ptr pointer to the incoming data
+/// \param size size of the data member
+/// \param nmemb number of data memebers
+/// \param stream pointer to I/O buffer
+/// \return number of bytes written
+static size_t readfunc ( void * ptr, size_t size, size_t nmemb, void * stream )
+{
+  char * Ln = ptr;
+  int sz = aws_iobuf_getline ( stream, ptr, size*nmemb);
+  __debug ( "Sent[%3d] %s", sz, Ln );
+  return sz;
+}
+
+/// Process incming header
+/// \param ptr pointer to the incoming data
+/// \param size size of the data member
+/// \param nmemb number of data memebers
+/// \param stream pointer to I/O buffer
+/// \return number of bytes processed
+static size_t header ( void * ptr, size_t size, size_t nmemb, void * stream )
+{
+  IOBuf * b = stream;
+
+  if (!strncmp ( ptr, "HTTP/1.1", 8 ))
+    {
+      b->result = strdup ( ptr + 9 );
+      __chomp(b->result);
+      b->code   = atoi ( ptr + 9 );
+    }
+  else if ( !strncmp ( ptr, "ETag: ", 6 ))
+    {
+      b->eTag = strdup ( ptr + 6 );
+      __chomp(b->eTag);
+    }
+  else if ( !strncmp ( ptr, "Last-Modified: ", 14 ))
+    {
+      b->lastMod = strdup ( ptr + 15 );
+      __chomp(b->lastMod);
+    }
+  else if ( !strncmp ( ptr, "Content-Length: ", 15 ))
+    {
+      b->contentLen = atoi ( ptr + 16 );
+    }
+
+  return nmemb * size;
+}
+
+
+/// Get Data for authentication of SQS request
+/// \return date in ISO format
+static char * __aws_get_iso_date ()
+{
+  static char dTa[256];
+  time_t t = time(NULL);
+  struct tm * gTime = gmtime ( & t );
+
+  memset ( dTa, 0 , sizeof(dTa));
+  strftime ( dTa, sizeof(dTa), "%FT%H:%M:%SZ", gTime );
+  __debug ( "Request Time: %s", dTa );
+  return dTa;
+}
+
+#ifdef ENABLE_DUMP
+/// Dump current state
+/// \internal
+static void Dump ()
+{
+  printf ( "----------------------------------------\n");
+  printf ( "ID     : %-40s \n", ID );
+  printf ( "KeyID  : %-40s \n", awsKeyID );
+  printf ( "Key    : %-40s \n", awsKey );
+  printf ( "S3  Host   : %-40s \n", S3Host );
+  printf ( "SQS Host   : %-40s \n", SQSHost );
+  printf ( "Bucket : %-40s \n", Bucket );
+  printf ( "----------------------------------------\n");
+}
+#endif /* ENABLE_DUMP */
+
+
+/// Print debug output
+/// \internal
+/// \param fmt printf like formating string
+static void __debug ( char *fmt, ... ) {
+  /// If debug flag is not set we won't print anything
+  if ( ! debug ) return ;
+  /// Otherwise process the arguments and print the result
+  va_list args;
+  va_start( args, fmt );
+  fprintf( stderr, "DBG: " );
+  vfprintf( stderr, fmt, args );
+  fprintf( stderr, "\n" );
+  va_end( args );
+}
+
+
+/// Get Request Date
+/// \internal
+/// \return date in HTTP format
+static char * __aws_get_httpdate ()
+{
+  static char dTa[256];
+  time_t t = time(NULL);
+  struct tm * gTime = gmtime ( & t );
+  memset ( dTa, 0 , sizeof(dTa));
+  strftime ( dTa, sizeof(dTa), "%a, %d %b %Y %H:%M:%S +0000", gTime );
+  __debug ( "Request Time: %s", dTa );
+  return dTa;
+}
+
+/// Internal function to get configuration file
+static FILE * __aws_getcfg ()
+{
+  int rv;
+  char ConfigFile[256];
+  /// Compose FileName and check
+  snprintf ( ConfigFile, sizeof(ConfigFile) - 3, "%s/.awsAuth",
+	     getenv("HOME"));
+  __debug ( "Config File %s", ConfigFile );
+
+  struct stat sBuf;
+  rv = stat ( ConfigFile, &sBuf );
+  if ( rv == -1 ) return NULL;
+
+  
+  if ( sBuf.st_mode & 066   ||
+       sBuf.st_uid != getuid () )
+    {
+      fprintf ( stderr, "I refuse to read your credentials from %s as this "
+	       "file is readable by, writable by or owned by someone else."
+		"Try chmod 600 %s", ConfigFile, ConfigFile );
+      return NULL;
+    }
+
+  return fopen ( ConfigFile, "r" );
+}
+
+
+/// Get S3 Request signature
+/// \internal
+/// \param resource -- URI of the object
+/// \param resSize --  size of the resoruce buffer
+/// \param date -- HTTP date
+/// \param method -- HTTP method
+/// \param bucket -- bucket 
+/// \param file --  file
+/// \return fills up resource and date parameters, also 
+///         returns request signature to be used with Authorization header
+static char * GetStringToSign ( char * resource,  int resSize, 
+			     char ** date,
+			     char * const method,
+			     char * const bucket,
+			     char * const file )
+{
+  char  reqToSign[2048];
+  char  acl[32];
+  
+  * date = __aws_get_httpdate();
+
+  memset ( resource,0,resSize);
+  if ( bucket != NULL )
+    snprintf ( resource, resSize,"%s/%s", bucket, file );
+  else
+    snprintf ( resource, resSize,"%s", file );
+
+  if (AccessControl)
+    snprintf( acl, sizeof(acl), "x-amz-acl:%s\n", AccessControl);
+  else
+    acl[0] = 0;
+
+  snprintf ( reqToSign, sizeof(reqToSign),"%s\n\n%s\n%s\n%s/%s",
+	     method,
+	     MimeType ? MimeType : "",
+	     *date,
+	     acl,
+	     resource );
+
+  // EU: If bucket is in virtual host name, remove bucket from path
+  if (bucket && strncmp(S3Host, bucket, strlen(bucket)) == 0)
+    snprintf ( resource, resSize,"%s", file );
+
+  return __aws_sign(reqToSign);
+}
+
+static void __aws_urlencode ( char * src, char * dest, int nDest )
+{
+  int i;
+  int n;
+  memset ( dest, 0, nDest );
+  __debug ( "Encoding: %s", src );
+  const char * badChrs = " \n$&+,/:;=?@";
+  const char * hexDigit = "0123456789ABCDEF";
+
+  n = 0;
+  for ( i = 0 ; src[i] ; i ++ )
+    {
+      if ( n + 5 > nDest ) 
+	{ puts ( "URLEncode:: Dest buffer to small.. can't continue \n" ); exit(0); }
+      if ( strchr ( badChrs, src[i] ))
+	{
+	  unsigned char c = src[i];
+	  dest[n++] = '%'; 
+	  dest[n++] = hexDigit [(c >> 4 ) & 0xF ];
+	  dest[n++] = hexDigit [c & 0xF ];
+	}
+      else dest[n++] = src[i];
+    }
+  __debug ( "Encoded To: %s", dest );
+}
+
+static int SQSRequest ( IOBuf *b, char * verb, char * const url )
+{
+  CURL* ch =  curl_easy_init( );
+  struct curl_slist *slist=NULL;
+
+  curl_easy_setopt ( ch, CURLOPT_URL, url );
+  curl_easy_setopt ( ch, CURLOPT_HEADERDATA, b );
+  curl_easy_setopt ( ch, CURLOPT_VERBOSE, debug );
+  curl_easy_setopt ( ch, CURLOPT_INFILESIZE, b->len );
+  curl_easy_setopt ( ch, CURLOPT_POST, 1 );
+  //curl_easy_setopt ( ch, CURLOPT_POST, CURLOPT_POSTFIELDSIZE , 0 );
+  curl_easy_setopt ( ch, CURLOPT_HEADERFUNCTION, header );
+  curl_easy_setopt ( ch, CURLOPT_WRITEFUNCTION, writefunc );
+  curl_easy_setopt ( ch, CURLOPT_WRITEDATA, b );
+  curl_easy_setopt ( ch, CURLOPT_READFUNCTION, readfunc );
+  curl_easy_setopt ( ch, CURLOPT_READDATA, b );
+
+  int  sc  = curl_easy_perform(ch);
+  /** \todo check the return code  */
+  __debug ( "Return Code: %d ", sc );
+  
+  curl_slist_free_all(slist);
+
+  return sc;
+}
+
+static char * SQSSign ( char * str )
+{
+  char RealSign[1024];
+  char * signature = __aws_sign(str);
+
+  __aws_urlencode ( signature, RealSign, sizeof(RealSign));
+    
+  free ( signature );
+  return strdup(RealSign);
+}
+
+
+
+/*!
+  \}
+*/
+
+
+/*!
+  \defgroup conf Configuration Functions
+  \{
+*/
+
+/// Initialize  the library 
+void aws_init () { curl_global_init (CURL_GLOBAL_ALL); }
+
+/// Set debuging output
+/// \param d  when non-zero causes debugging output to be printed
+void aws_set_debug (int d)
+{
+  debug = d;
+}
+
+/// \brief Set AWS account ID to be read from .awsAuth file
+/// \param id new account ID
+void aws_set_id ( char * const id )     
+{ ID = id == NULL ? NULL : strdup(id); }
+
+/// Set AWS account access key
+/// \param key new AWS authentication key
+void aws_set_key ( char * const key )   
+{ awsKey = key == NULL ? NULL : strdup(key); }
+
+/// Set AWS account access key ID
+/// \param keyid new AWS key ID
+void aws_set_keyid ( char * const keyid ) 
+{ awsKeyID = keyid == NULL ? NULL :  strdup(keyid);}
+
+/// Read AWS authentication records
+/// \param id  user ID
+int aws_read_config ( char * const id )
+{
+  aws_set_id ( id );
+  aws_set_keyid ( NULL );
+  aws_set_key   ( NULL   );
+
+  /// Open File
+  /// Make sure that file permissions are set right
+  __debug ( "Reading Config File ID[%s]", ID );
+  FILE * f = __aws_getcfg();
+  if ( f == NULL ) { perror ("Error opening config file"); exit(1); }
+  
+
+  /// Read Lines
+  char line[1024];
+  int  ln = 0;
+  while ( !feof(f))
+    {
+      ln++;
+      memset (line,0,sizeof(line));
+      fgets ( line, sizeof(line), f );
+
+  /// Skip Comments
+      if ( line[0] == '#' ) continue;
+      if ( line[0] == 0 ) continue;
+
+      __chomp ( line );
+      
+
+	/// Split the line on ':'
+      char * keyID = strchr(line,':');
+      if ( keyID == NULL )
+	{ printf ( "Syntax error in credentials file line %d, no keyid\n", ln );
+	  exit(1);
+	}
+      *keyID = 0; keyID ++;
+
+      char * key = strchr(keyID,':');
+      if ( key == NULL )
+	{ printf ( "Syntax error in credentials file line %d, no key\n", ln );
+	  exit(1);
+	}
+      *key = 0; key ++;
+      
+      
+      /// If the line is correct Set the IDs
+      if ( !strcmp(line,id))
+	{
+	  aws_set_keyid ( keyID );
+	  aws_set_key   ( key   );
+	  break;
+	}
+
+    }
+  /// Return error if not found
+  if ( awsKeyID == NULL ) return -1;
+  return 0;
+}
+
+/*!
+  \}
+*/
+
+
+
+
+/*!
+  \defgroup s3 S3 Interface Functions
+  \{
+*/
+
+
+/// Select current S3 bucket
+/// \param str bucket ID
+void s3_set_bucket ( char * const str ) 
+{ Bucket = str == NULL ? NULL : strdup(str); }
+
+/// Set S3 host
+void s3_set_host ( char * const str )  
+{ S3Host = str == NULL ? NULL :  strdup(str); }
+
+/// Set S3 MimeType
+void s3_set_mime ( char * const str )
+{ MimeType = str ? strdup(str) : NULL; }
+
+/// Set S3 AccessControl
+void s3_set_acl ( char * const str )
+{ AccessControl = str ? strdup(str) : NULL; }
+
+
+/// Upload the file into currently selected bucket
+/// \param b I/O buffer
+/// \param file filename
+int s3_put ( IOBuf * b, char * const file )
+{
+  char * const method = "PUT";
+  char  resource [1024];
+  char * date = NULL;
+
+  char * signature = GetStringToSign ( resource, sizeof(resource), 
+				       &date, method, Bucket, file ); 
+  int sc = s3_do_put( b, signature, date, resource ); 
+  free ( signature );
+  return sc;
+
+}
+
+
+/// Download the file from the current bucket
+/// \param b I/O buffer
+/// \param file filename 
+int s3_get ( IOBuf * b, char * const file )
+{
+  char * const method = "GET";
+  
+  char  resource [1024];
+  char * date = NULL;
+
+  
+  char * signature = GetStringToSign ( resource, sizeof(resource), 
+				       &date, method, Bucket, file ); 
+  int sc = s3_do_get( b, signature, date, resource ); 
+  free ( signature );
+  return sc;
+}
+
+
+
+static int s3_do_put ( IOBuf *b, char * const signature, 
+		       char * const date, char * const resource )
+{
+  char Buf[1024];
+
+  CURL* ch =  curl_easy_init( );
+  struct curl_slist *slist=NULL;
+
+  if (MimeType) {
+    snprintf ( Buf, sizeof(Buf), "Content-Type: %s", MimeType );
+    slist = curl_slist_append(slist, Buf );
+  }
+
+  if (AccessControl) {
+    snprintf ( Buf, sizeof(Buf), "x-amz-acl: %s", AccessControl );
+    slist = curl_slist_append(slist, Buf );
+  }
+
+  snprintf ( Buf, sizeof(Buf), "Date: %s", date );
+  slist = curl_slist_append(slist, Buf );
+  snprintf ( Buf, sizeof(Buf), "Authorization: AWS %s:%s", awsKeyID, signature );
+  slist = curl_slist_append(slist, Buf );
+
+  snprintf ( Buf, sizeof(Buf), "http://%s/%s", S3Host , resource );
+
+  curl_easy_setopt ( ch, CURLOPT_HTTPHEADER, slist);
+  curl_easy_setopt ( ch, CURLOPT_URL, Buf );
+  curl_easy_setopt ( ch, CURLOPT_READDATA, b );
+  if (!debug)
+    curl_easy_setopt ( ch, CURLOPT_WRITEFUNCTION, writedummyfunc );
+  curl_easy_setopt ( ch, CURLOPT_READFUNCTION, readfunc );
+  curl_easy_setopt ( ch, CURLOPT_HEADERFUNCTION, header );
+  curl_easy_setopt ( ch, CURLOPT_HEADERDATA, b );
+  curl_easy_setopt ( ch, CURLOPT_VERBOSE, debug );
+  curl_easy_setopt ( ch, CURLOPT_UPLOAD, 1 );
+  curl_easy_setopt ( ch, CURLOPT_INFILESIZE, b->len );
+  curl_easy_setopt ( ch, CURLOPT_FOLLOWLOCATION, 1 );
+
+  int  sc  = curl_easy_perform(ch);
+  /** \todo check the return code  */
+  __debug ( "Return Code: %d ", sc );
+  
+  curl_slist_free_all(slist);
+
+  return sc;
+
+}
+
+
+static int s3_do_get ( IOBuf *b, char * const signature, 
+		       char * const date, char * const resource )
+{
+  char Buf[1024];
+
+  CURL* ch =  curl_easy_init( );
+  struct curl_slist *slist=NULL;
+
+  slist = curl_slist_append(slist, "If-Modified-Since: Tue, 26 May 2009 18:58:55 GMT" );
+  slist = curl_slist_append(slist, "ETag: \"6ea58533db38eca2c2cc204b7550aab6\"");
+
+  snprintf ( Buf, sizeof(Buf), "Date: %s", date );
+  slist = curl_slist_append(slist, Buf );
+  snprintf ( Buf, sizeof(Buf), "Authorization: AWS %s:%s", awsKeyID, signature );
+  slist = curl_slist_append(slist, Buf );
+
+  snprintf ( Buf, sizeof(Buf), "http://%s/%s", S3Host, resource );
+
+  curl_easy_setopt ( ch, CURLOPT_HTTPHEADER, slist);
+  curl_easy_setopt ( ch, CURLOPT_URL, Buf );
+  curl_easy_setopt ( ch, CURLOPT_WRITEFUNCTION, writefunc );
+  curl_easy_setopt ( ch, CURLOPT_WRITEDATA, b );
+  curl_easy_setopt ( ch, CURLOPT_HEADERFUNCTION, header );
+  curl_easy_setopt ( ch, CURLOPT_HEADERDATA, b );
+  curl_easy_setopt ( ch, CURLOPT_VERBOSE, debug );
+
+  int  sc  = curl_easy_perform(ch);
+  /** \todo check the return code  */
+  __debug ( "Return Code: %d ", sc );
+  
+  curl_slist_free_all(slist);
+
+  return sc;
+
+}
+
+
+
+
+
+
+static char* __aws_sign ( char * const str )
+{
+  HMAC_CTX ctx;
+  unsigned char MD[256];
+  unsigned len;
+
+  __debug("StrToSign:%s", str );
+
+  HMAC_CTX_init(&ctx);
+  HMAC_Init(&ctx, awsKey, strlen(awsKey), EVP_sha1());
+  HMAC_Update(&ctx,(unsigned char*)str, strlen(str));
+  HMAC_Final(&ctx,(unsigned char*)MD,&len);
+  HMAC_CTX_cleanup(&ctx);
+
+  char * b64 = __b64_encode (MD,len);
+  __debug("Signature:  %s", b64 );
+
+  return b64;
+}
+/*!
+  \}
+*/
+
+
+
+#define SQS_REQ_TAIL   "&Signature=%s" "&SignatureVersion=1" "&Timestamp=%s" "&Version=2009-02-01"
+/*!
+  \defgroup sqs SQS Interface Functions
+  \{
+*/
+
+
+/// Create SQS queue
+/// \param b I/O buffer
+/// \param name queue name
+/// \return on success return 0, otherwise error code
+int sqs_create_queue ( IOBuf *b, char * const name )
+{
+  __debug ( "Creating Que: %s\n", name );
+
+  char  resource [1024];
+  char  customSign [1024];
+  char * date = NULL;
+  char * signature = NULL;
+  
+  char * Req = 
+    "http://%s/"
+    "?Action=CreateQueue"
+    "&QueueName=%s"
+    "&AWSAccessKeyId=%s"
+    SQS_REQ_TAIL ;
+
+  char * Sign = "ActionCreateQueue"
+                "AWSAccessKeyId%s"
+                "QueueName%s"
+                "SignatureVersion1"
+                "Timestamp%sVersion2009-02-01";
+
+  date = __aws_get_iso_date  ();
+  snprintf ( customSign, sizeof(customSign), Sign, awsKeyID, name, date );
+  signature =  SQSSign ( customSign );
+
+  snprintf ( resource, sizeof(resource), SQSHost, Req , name, awsKeyID, signature, date );
+
+  int sc = SQSRequest( b, "POST", resource ); 
+  free ( signature );
+  return sc;
+
+}
+
+/// Retrieve URL of the queue
+/// \param b I/O buffer
+/// \param prefix queue prefix. better use the whole name
+/// \return on success return 0, otherwise error code
+///
+/// URL is placed into the I/O buffer. User get_line to retrieve it
+int sqs_list_queues ( IOBuf *b, char * const prefix )
+{
+  __debug ( "Listing Queues PFX: %s\n", prefix );
+
+  char  resource [1024];
+  char  customSign [1024];
+  char * date = NULL;
+  char * signature = NULL;
+  
+  char * Req = 
+    "http://%s/"
+    "?Action=ListQueues"
+    "&QueueNamePrefix=%s"
+    "&AWSAccessKeyId=%s"
+      SQS_REQ_TAIL ;
+
+  char * Sign = "ActionListQueues"
+                "AWSAccessKeyId%s"
+                "QueueNamePrefix%s"
+                "SignatureVersion1"
+                "Timestamp%sVersion2009-02-01";
+
+  date = __aws_get_iso_date  ();
+  snprintf ( customSign, sizeof(customSign), Sign, awsKeyID, prefix, date );
+  signature =  SQSSign ( customSign );
+
+  snprintf ( resource, sizeof(resource), Req , SQSHost , prefix, awsKeyID,
+	     signature, date );
+
+  IOBuf *nb = aws_iobuf_new();
+  int sc = SQSRequest( nb, "POST", resource ); 
+  free ( signature );
+
+  if ( nb->result != NULL )
+    b-> result = strdup(nb->result);
+  b-> code   = nb->code;
+
+  /// \todo This only retrieves just one line in the string..
+  ///       make that all URLs are returned
+
+  if ( b->code == 200 )
+    {
+      /// Parse Out the List Of Queues
+      while(-1)
+	{
+	  char Ln[1024];
+	  aws_iobuf_getline ( nb, Ln, sizeof(Ln));
+	  if ( Ln[0] == 0 ) break;
+	  char *q = strstr ( Ln, "<QueueUrl>" );
+	  if ( q != 0 )
+	    {
+	      q += 10;
+	      char * end = NULL;
+	      end = strstr ( q, "</QueueUrl>" );
+	      if ( *end != 0 )
+		{
+		  * end = 0;
+		  aws_iobuf_append ( b, q, strlen(q ));
+		  aws_iobuf_append ( b, "\n", 1 );
+		}
+	    }
+	}      
+    }
+  aws_iobuf_free ( nb );
+
+  return sc;
+}
+
+
+/// Retrieve queue attributes
+/// \param b I/O buffer
+/// \param url queue url. Use sqs_list_queues to retrieve
+/// \param timeOut queue visibility timeout
+/// \param nMesg   approximate number of messages in the queue
+/// \return on success return 0, otherwise error code
+int sqs_get_queueattributes ( IOBuf *b, char * url, int *timeOut, int *nMesg )
+{
+  __debug ( "Getting Que Attributes\n" );
+
+  char  resource [1024];
+  char  customSign [1024];
+  char * date = NULL;
+  char * signature = NULL;
+
+  char * Req = 
+    "%s/"
+    "?Action=GetQueueAttributes"
+    "&AttributeName.1=VisibilityTimeout"
+    "&AttributeName.2=ApproximateNumberOfMessages"
+    "&AWSAccessKeyId=%s"
+    SQS_REQ_TAIL ;
+
+  char * Sign = 
+    "ActionGetQueueAttributes"
+    "AttributeName.1VisibilityTimeout"
+    "AttributeName.2ApproximateNumberOfMessages"
+    "AWSAccessKeyId%s"
+    "SignatureVersion1"
+    "Timestamp%s"
+    "Version2009-02-01";
+
+  date = __aws_get_iso_date  ();
+  snprintf ( customSign, sizeof(customSign), Sign, awsKeyID, date );
+  signature =  SQSSign ( customSign );
+
+  snprintf ( resource, sizeof(resource), Req , url, awsKeyID, signature, date );
+
+  const char *pfxVisTO = "<Name>VisibilityTimeout</Name><Value>";
+  const char *pfxQLen  = "<Name>ApproximateNumberOfMessages</Name><Value>";
+
+
+  int sc = SQSRequest( b, "POST", resource ); 
+  while(-1) 
+    {
+      char Ln[1024];
+      aws_iobuf_getline ( b, Ln, sizeof(Ln));
+      if ( Ln[0] == 0 ) break;
+      
+      char *q;
+      q = strstr ( Ln, pfxVisTO );
+      if ( q != 0 ) { *timeOut = atoi(q+strlen(pfxVisTO));  }
+      q = strstr ( Ln, pfxQLen );
+      if ( q != 0 ) { *nMesg = atoi(q+strlen(pfxQLen));  }
+    }
+
+  free ( signature );
+  return sc;
+}
+
+/// Set queue visibility timeout
+/// \param b I/O buffer
+/// \param url queue url. Use sqs_list_queues to retrieve
+/// \param sec queue visibility timeout
+/// \return on success return 0, otherwise error code
+int sqs_set_queuevisibilitytimeout ( IOBuf *b, char * url, int sec )
+{
+  __debug ( "Setting Visibility Timeout : %d\n", sec );
+
+  char  resource [1024];
+  char  customSign [1024];
+  char * date = NULL;
+  char * signature = NULL;
+
+  char * Req = 
+    "%s/"
+    "?Action=SetQueueAttributes"
+    "&Attribute.1.Name=VisibilityTimeout"
+    "&Attribute.1.Value=%d"
+    "&AWSAccessKeyId=%s"
+    SQS_REQ_TAIL ;
+
+  char * Sign = 
+    "ActionSetQueueAttributes"
+    "Attribute.1.NameVisibilityTimeout"
+    "Attribute.1.Value%d"
+    "AWSAccessKeyId%s"
+    "SignatureVersion1"
+    "Timestamp%s"
+    "Version2009-02-01";
+
+  date = __aws_get_iso_date  ();
+  snprintf ( customSign, sizeof(customSign), Sign, sec, awsKeyID, date );
+  signature =  SQSSign ( customSign );
+
+  snprintf ( resource, sizeof(resource), Req , 
+	     url, sec, awsKeyID, signature, date );
+
+  int sc = SQSRequest( b, "POST", resource ); 
+  free ( signature );
+  return sc;
+}
+
+/// Send a message to the queue
+/// \param b I/O buffer
+/// \param url queue url. Use sqs_list_queues to retrieve
+/// \param msg a message to send
+/// \return on success return 0, otherwise error code
+int sqs_send_message ( IOBuf *b, char * const url, char * const msg )
+{
+  __debug ( "Sending Message to the queue %s\n[%s]",
+	  url, msg );
+
+  char  resource [10900];
+  char  customSign [10900];
+  char * date = NULL;
+  char * signature = NULL;
+  char  encodedMsg[8192];
+
+  __aws_urlencode ( msg, encodedMsg, sizeof(encodedMsg));
+  __debug ( "Encoded MSG %s", encodedMsg );
+
+  char * Req = 
+    "%s/"
+    "?Action=SendMessage"
+    "&MessageBody=%s"
+    "&AWSAccessKeyId=%s"
+    SQS_REQ_TAIL ;
+
+  char * Sign = 
+    "ActionSendMessage"
+    "AWSAccessKeyId%s"
+    "MessageBody%s"
+    "SignatureVersion1"
+    "Timestamp%s"
+    "Version2009-02-01";
+
+  date = __aws_get_iso_date  ();
+  snprintf ( customSign, sizeof(customSign), Sign, awsKeyID, msg, date );
+  signature =  SQSSign ( customSign );
+
+  snprintf ( resource, sizeof(resource), Req , 
+	     url, encodedMsg, awsKeyID, signature, date );
+
+  int sc = SQSRequest( b, "POST", resource ); 
+  free ( signature );
+  return sc;
+}
+
+/// Retrieve a message from the queue
+/// \param b I/O buffer
+/// \param url queue url. Use sqs_list_queues to retrieve
+/// \param id Message receipt handle. 
+/// \return on success return 0, otherwise error code
+///
+/// Message contents are placed into I/O buffer
+/// Caller has to allocate enough memory for the receipt handle 
+/// 1024 bytes should be enough
+int sqs_get_message ( IOBuf * b, char * const url, char * id  )
+{
+  __debug ( "Retieving message from: %s", url );
+
+  char  resource [10900];
+  char  customSign [10900];
+  char * date = NULL;
+  char * signature = NULL;
+
+  char * Req = 
+    "%s/"
+    "?Action=ReceiveMessage"
+    "&AWSAccessKeyId=%s"
+    SQS_REQ_TAIL ;
+
+  char * Sign = 
+    "ActionReceiveMessage"
+    "AWSAccessKeyId%s"
+    "SignatureVersion1"
+    "Timestamp%s"
+    "Version2009-02-01";
+
+  date = __aws_get_iso_date  ();
+  snprintf ( customSign, sizeof(customSign), Sign, awsKeyID, date );
+  signature =  SQSSign ( customSign );
+
+  snprintf ( resource, sizeof(resource), Req , 
+	     url, awsKeyID, signature, date );
+  free ( signature );
+
+  IOBuf * bf = aws_iobuf_new();
+  int sc = SQSRequest( bf, "POST", resource ); 
+
+  b->code = bf->code;
+  b->result = strdup(bf->result);
+  
+  if ( bf->code != 200 ) { aws_iobuf_free(bf);  return sc; }
+
+      /// \todo This is really bad. Must get a real message parser
+      int inBody = 0;
+      while(-1) 
+	{
+	  char Ln[1024];
+	  aws_iobuf_getline ( bf, Ln, sizeof(Ln));
+	  if ( Ln[0] == 0 ) break;
+
+	  __debug ( "%s|%s|", inBody ? ">>": "", Ln );
+	  
+	  char *q;
+	  char *e;
+
+	  /// Handle a body already being processed..
+	  if ( inBody )
+	    {
+	      e = strstr ( Ln, "</Body>" );
+	      if ( e ) { *e = 0; inBody = 0; }
+	      aws_iobuf_append (b,Ln,strlen(Ln));
+	      if ( ! inBody ) break;
+	      continue;     
+	    }
+
+	  q = strstr ( Ln, "<ReceiptHandle>" );
+	  if ( q != 0 ) 
+	    {
+	      q += 15;
+	      e = strstr ( Ln, "</ReceiptHandle>" );
+	      *e = 0;
+	      strcpy ( id, q );
+	      q = e+1;
+	      q = strstr ( q, "<Body>" );
+	      if ( q != 0 ) 
+		{
+		  q += 6;
+		  e = strstr ( q, "</Body>" );
+		  if ( e ) *e = 0; else inBody = 1;
+		  aws_iobuf_append (b,q,strlen(q));
+		}
+	    }
+	}
+     
+
+  return sc;
+}
+
+/// Delete processed message from the queue
+/// \param bf I/O buffer
+/// \param url queue url. Use sqs_list_queues to retrieve
+/// \param receipt Message receipt handle. 
+/// \return on success return 0, otherwise error code
+///
+int sqs_delete_message ( IOBuf * bf, char * const url, char * receipt )
+{
+  char  resource [10900];
+  char  customSign [10900];
+  char * date = NULL;
+  char * signature = NULL;
+
+  char * Req = 
+    "%s/"
+    "?Action=DeleteMessage"
+    "&ReceiptHandle=%s"
+    "&AWSAccessKeyId=%s"
+      SQS_REQ_TAIL ;
+
+  char * Sign = 
+    "ActionDeleteMessage"
+    "AWSAccessKeyId%s"
+    "ReceiptHandle%s"
+    "SignatureVersion1"
+    "Timestamp%s"
+    "Version2009-02-01";
+
+  date = __aws_get_iso_date  ();
+  snprintf ( customSign, sizeof(customSign), Sign, awsKeyID, receipt, date );
+  signature =  SQSSign ( customSign );
+
+  char encReceipt[1024];
+  __aws_urlencode ( receipt, encReceipt, sizeof(encReceipt));
+
+  snprintf ( resource, sizeof(resource), Req , url, encReceipt, awsKeyID, signature, date );
+  free ( signature );
+
+  int sc = SQSRequest( bf, "POST", resource ); 
+  return sc;
+}
+
+/*!
+  \}
+*/
+
+
+
+/*!
+  \defgroup iobuf I/O Buffer functions
+  \{
+*/
+
+/// \todo Place sentinels at the begining of the buffer
+
+/// Create a new I/O buffer
+/// \return a newly allocated I/O buffer
+IOBuf * aws_iobuf_new ()
+{
+  IOBuf * bf = malloc(sizeof(IOBuf));
+
+  memset(bf, 0, sizeof(IOBuf));
+
+  return bf;
+}
+
+
+/// Append data to I/O buffer
+/// \param B  I/O buffer
+/// \param d  pointer to the data to be appended
+/// \param len length of the data to be appended
+void   aws_iobuf_append ( IOBuf *B, char * d, int len )
+{
+
+  IOBufNode * N = malloc(sizeof(IOBufNode));
+  N->next = NULL;
+  N->buf  = malloc(len+1);
+  memcpy(N->buf,d,len);
+  N->buf[len] = 0;
+  B->len += len;
+
+  if ( B->first == NULL )
+    {
+      B->first   = N;
+      B->current = N;
+      B->pos     = N->buf;
+    }
+  else
+    {
+      // Find the last block
+      IOBufNode * D = B->first;
+      while(D->next != NULL ) D = D->next;
+      D->next = N;
+    }
+}
+
+/// Read the next line from the buffer
+///  \param B I/O buffer
+///  \param Line  character array to store the read line in
+///  \param size  size of the character array Line
+///  \return  number of characters read or 0 
+int    aws_iobuf_getline   ( IOBuf * B, char * Line, int size )
+{
+  int ln = 0;
+  memset ( Line, 0, size );
+
+  if ( B->current == NULL ) return 0;
+
+  while ( size - ln > 1 )
+    {
+      if ( *B->pos == '\n' ) { B->pos++; Line[ln] = '\n'; ln++; break; }
+      if ( *B->pos == 0 ) 
+      {
+	B->current = B->current->next;
+	if ( B->current == NULL ) break;
+	B->pos = B->current->buf;
+	continue;
+      }
+      Line[ln] = * B->pos;
+      ln++;
+      
+      B->pos++;
+      // At the end of the block switch again
+    }
+  B->len -= ln;
+  return ln;
+}
+
+/// Release IO Buffer
+/// \param  bf I/O buffer to be deleted
+void   aws_iobuf_free ( IOBuf * bf )
+{ 
+  /// Release Things
+  IOBufNode * N = bf->first;
+  if ( bf->result  != NULL ) free ( bf->result  );
+  if ( bf->lastMod != NULL ) free ( bf->lastMod );
+  if ( bf->eTag    != NULL ) free ( bf->eTag    );
+  free (bf);
+
+  if ( N == NULL ) return;
+
+  /// Walk down the list and release blocks
+  while ( N->next != NULL )
+    {
+      IOBufNode * NN = N->next;
+      free(N);
+      N = NN;
+    }
+  if ( N != NULL ) free ( N );
+}
+
+/*!
+  \}
+*/
diff -Nurd -X.diff_ignore freeciv/server/aws4c.h freeciv/server/aws4c.h
--- freeciv/server/aws4c.h	1970-01-01 02:00:00.000000000 +0200
+++ freeciv/server/aws4c.h	2012-05-16 22:10:12.000000000 +0300
@@ -0,0 +1,71 @@
+
+/*
+ *
+ * Copyright(c) 2009,  Vlad Korolev,  <vlad[@]v-lad.org >
+ *
+ * This software is licensed as described in the file COPYING, which
+ * you should have received as part of this distribution. The terms
+ * are also available at http://www.gnu.org/licenses/lgpl-3.0.txt
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the COPYING file.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ */
+
+
+/// IOBuf Node
+typedef struct _IOBufNode
+{
+  char * buf;
+  struct _IOBufNode * next;
+} IOBufNode;
+
+/// IOBuf structure
+typedef struct IOBuf 
+{
+  IOBufNode * first;
+  IOBufNode * current;
+  char   * pos;
+
+  char * result;
+  char * lastMod;
+  char * eTag;
+  int contentLen;
+  int len;
+  int code;
+
+} IOBuf;
+
+
+
+void aws_init ();
+void aws_set_id ( char * const str );    
+void aws_set_key ( char * const str );
+void aws_set_keyid ( char * const str );
+int aws_read_config ( char * const ID );
+void aws_set_debug (int d);
+
+
+void s3_set_bucket ( char * const str );
+int s3_get ( IOBuf * b, char * const file );
+int s3_put ( IOBuf * b, char * const file );
+void s3_set_host ( char * const str );
+void s3_set_mime ( char * const str );
+void s3_set_acl ( char * const str );
+
+
+int sqs_create_queue ( IOBuf *b, char * const name );
+int sqs_list_queues ( IOBuf *b, char * const prefix );
+int sqs_get_queueattributes ( IOBuf *b, char * url, int *TimeOut, int *nMesg );
+int sqs_set_queuevisibilitytimeout ( IOBuf *b, char * url, int sec );
+int sqs_get_message ( IOBuf * b, char * const url, char * id  );
+int sqs_send_message ( IOBuf *b, char * const url, char * const msg );
+int sqs_delete_message ( IOBuf * bf, char * const url, char * receipt );
+
+IOBuf * aws_iobuf_new ();
+void   aws_iobuf_append ( IOBuf *B, char * d, int len );
+int    aws_iobuf_getline   ( IOBuf * B, char * Line, int size );
+void   aws_iobuf_free ( IOBuf * bf );
+
diff -Nurd -X.diff_ignore freeciv/server/commands.c freeciv/server/commands.c
--- freeciv/server/commands.c	2012-05-16 20:56:43.000000000 +0300
+++ freeciv/server/commands.c	2012-05-16 22:10:12.000000000 +0300
@@ -409,7 +409,7 @@
       "all cities and units etc.  Use with care!"),
    VCF_NONE, 50
   },
-  {"save",	ALLOW_ADMIN,
+  {"save",	ALLOW_CTRL,
    /* TRANS: translate text between <> only */
    N_("save\n"
       "save <file-name>"),
diff -Nurd -X.diff_ignore freeciv/server/Makefile.am freeciv/server/Makefile.am
--- freeciv/server/Makefile.am	2012-05-16 20:56:43.000000000 +0300
+++ freeciv/server/Makefile.am	2012-05-16 22:10:15.000000000 +0300
@@ -23,6 +23,8 @@
 		aiiface.h	\
 		auth.c		\
 		auth.h		\
+		aws4c.c		\
+		aws4c.h		\
 		barbarian.c	\
 		barbarian.h	\
 		cityhand.c	\
@@ -59,6 +61,8 @@
 		meta.h		\
 		notify.c	\
 		notify.h	\
+		netsave.c	\
+		netsave.h	\
 		plrhand.c	\
 		plrhand.h	\
 		report.c	\
diff -Nurd -X.diff_ignore freeciv/server/netsave.c freeciv/server/netsave.c
--- freeciv/server/netsave.c	1970-01-01 02:00:00.000000000 +0200
+++ freeciv/server/netsave.c	2012-05-16 22:10:12.000000000 +0300
@@ -0,0 +1,885 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "astring.h"
+#include "fcintl.h"
+#include "genlist.h"
+#include "hash.h"
+#include "inputfile.h"
+#include "ioz.h"
+#include "log.h"
+#include "mem.h"
+#include "sbuffer.h"
+#include "shared.h"
+#include "support.h"
+
+#include "aws4c.h"
+#include "netsave.h"
+
+#define SAVE_TABLES TRUE	/* set to 0 for old-style savefiles */
+#define SECF_DEBUG_ENTRIES FALSE/* LOG_DEBUG each entry value */
+
+#define SPECVEC_TAG astring
+#include "specvec.h"
+
+/* An 'entry' is a string, integer or string vector;
+ * Whether it is string or int or string vector is determined by whether
+ * svalue/vec_values is NULL.
+ */
+struct entry {
+  char *name;			/* name, not including section prefix */
+  int  ivalue;			/* value if integer */
+  char *svalue;			/* value if string (in sbuffer) */
+  char **vec_values;		/* string vector values */
+  int dim;			/* vector's size */
+  int  used;			/* number of times entry looked up */
+  char *comment;                /* comment, may be NULL */
+  bool escaped;                 /* " or $. Usually TRUE */
+};
+
+/* create a 'struct entry_list' and related functions: */
+#define SPECLIST_TAG entry
+#include "speclist.h"
+
+#define entry_list_iterate(entlist, pentry) \
+       TYPED_LIST_ITERATE(struct entry, entlist, pentry)
+#define entry_list_iterate_end  LIST_ITERATE_END
+
+
+struct section {
+  char *name;
+  struct entry_list *entries;
+};
+
+/* create a 'struct section_list' and related functions: */
+#define SPECLIST_TAG section
+#include "speclist.h"
+
+#define section_list_iterate(seclist, psection) \
+       TYPED_LIST_ITERATE(struct section, seclist, psection)
+#define section_list_iterate_end  LIST_ITERATE_END
+
+#define section_list_iterate_rev(seclist, psection) \
+       TYPED_LIST_ITERATE_REV(struct section, seclist, psection)
+#define section_list_iterate_rev_end  LIST_ITERATE_REV_END
+
+/* The hash table and some extra data: */
+struct hash_data {
+  struct hash_table *htbl;
+  int num_entries_hashbuild;
+  bool allow_duplicates;
+  int num_duplicates;
+};
+
+
+/***************************************************************
+ Returns a pointer to an internal buffer (can only get one
+ string at a time) with str escaped the opposite of minstrdup.
+ Specifically, any newline, backslash, or double quote is
+ escaped with a backslash.
+ Adds appropriate delimiters: "" if escaped, $$ unescaped.
+ The internal buffer is grown as necessary, and not normally
+ freed (since this will be called frequently.)  A call with
+ str=NULL frees the buffer and does nothing else (returns NULL).
+***************************************************************/
+static char *moutstr(char *str, bool full_escapes)
+{
+  static char *buf = NULL;
+  static int nalloc = 0;
+
+  int len;			/* required length, including terminator */
+  char *c, *dest;
+
+  if (!str) {
+    freelog(LOG_DEBUG, "moutstr alloc was %d", nalloc);
+    free(buf);
+    buf = NULL;
+    nalloc = 0;
+    return NULL;
+  }
+  
+  len = strlen(str)+3;
+  if (full_escapes) {
+    for(c=str; *c != '\0'; c++) {
+      if (*c == '\n' || *c == '\\' || *c == '\"') {
+        len++;
+      }
+    }
+  }
+  if (len > nalloc) {
+    nalloc = 2 * len + 1;
+    buf = fc_realloc(buf, nalloc);
+  }
+  
+  dest = buf;
+  *dest++ = (full_escapes ? '\"' : '$');
+  while(*str != '\0') {
+    if (full_escapes && (*str == '\n' || *str == '\\' || *str == '\"')) {
+      *dest++ = '\\';
+      if (*str == '\n') {
+	*dest++ = 'n';
+	str++;
+      } else {
+	*dest++ = *str++;
+      }
+    } else {
+      *dest++ = *str++;
+    }
+  }
+  *dest++ = (full_escapes ? '\"' : '$');
+  *dest = '\0';
+  return buf;
+}
+
+
+bool net_file_save(struct section_file *my_section_file,
+                       const char *filename)
+{
+  char real_filename[1024];
+  const struct genlist_link *ent_iter, *save_iter, *col_iter;
+  struct entry *pentry, *col_pentry;
+  int i;
+  char S[256];
+
+  aws_init ();
+  aws_set_debug  ( 0 );
+  int rc = aws_read_config  ( "freeciv" );
+  if ( rc )
+    {
+      puts ( "Could not find a credential in the config file" );
+      puts ( "Make sure your ~/.awsAuth file is correct" );
+      exit ( 1 );
+    }
+
+  s3_set_bucket ("freeciv-net-savegames");
+  s3_set_mime ("text/plain");
+  s3_set_acl ("public-read");
+
+  IOBuf * bf = aws_iobuf_new ();
+
+  /* SAVE GAME START  */
+
+  interpret_tilde(real_filename, sizeof(real_filename), filename);
+
+
+  section_list_iterate(my_section_file->sections, psection) {
+    //fz_fprintf(fs, "\n[%s]\n", psection->name);
+    my_snprintf (S, sizeof(S), "\n[%s]\n", psection->name);
+    aws_iobuf_append ( bf, S, strlen(S));
+
+    /* Following doesn't use entry_list_iterate() because we want to do
+     * tricky things with the iterators...
+     */
+    for (ent_iter = genlist_head(entry_list_base(psection->entries));
+         ent_iter && (pentry = genlist_link_data(ent_iter));
+         ent_iter = genlist_link_next(ent_iter)) {
+
+      /* Tables: break out of this loop if this is a non-table
+       * entry (pentry and ent_iter unchanged) or after table (pentry
+       * and ent_iter suitably updated, pentry possibly NULL).
+       * After each table, loop again in case the next entry
+       * is another table.
+       */
+      for(;;) {
+	char *c, *first, base[64];
+	int offset, irow, icol, ncol;
+	
+	/* Example: for first table name of "xyz0.blah":
+	 *  first points to the original string pentry->name
+	 *  base contains "xyz";
+	 *  offset=5 (so first+offset gives "blah")
+	 *  note strlen(base)=offset-2
+	 */
+
+	if(!SAVE_TABLES) break;
+	
+	c = first = pentry->name;
+	if(*c == '\0' || !my_isalpha(*c)) break;
+	for (; *c != '\0' && my_isalpha(*c); c++) {
+	  /* nothing */
+	}
+	if(strncmp(c,"0.",2) != 0) break;
+	c+=2;
+	if(*c == '\0' || !my_isalnum(*c)) break;
+
+	offset = c - first;
+	first[offset-2] = '\0';
+	sz_strlcpy(base, first);
+	first[offset-2] = '0';
+	//fz_fprintf(fs, "%s={", base);
+        my_snprintf (S, sizeof(S), "%s={", base);
+        aws_iobuf_append ( bf, S, strlen(S));
+
+
+
+	/* Save an iterator at this first entry, which we can later use
+	 * to repeatedly iterate over column names:
+	 */
+	save_iter = ent_iter;
+
+	/* write the column names, and calculate ncol: */
+	ncol = 0;
+	col_iter = save_iter;
+        for(; (col_pentry = genlist_link_data(col_iter));
+            col_iter = genlist_link_next(col_iter)) {
+	  if(strncmp(col_pentry->name, first, offset) != 0)
+	    break;
+	  //fz_fprintf(fs, "%c\"%s\"", (ncol==0?' ':','), col_pentry->name+offset);
+          my_snprintf (S, sizeof(S), "%c\"%s\"", (ncol==0?' ':','), col_pentry->name+offset);
+          aws_iobuf_append ( bf, S, strlen(S));
+
+
+
+	  ncol++;
+	}
+	//fz_fprintf(fs, "\n");
+        my_snprintf (S, sizeof(S), "\n");
+        aws_iobuf_append ( bf, S, strlen(S));
+
+
+	/* Iterate over rows and columns, incrementing ent_iter as we go,
+	 * and writing values to the table.  Have a separate iterator
+	 * to the column names to check they all match.
+	 */
+	irow = icol = 0;
+	col_iter = save_iter;
+	for(;;) {
+	  char expect[128];	/* pentry->name we're expecting */
+
+	  pentry = genlist_link_data(ent_iter);
+	  col_pentry = genlist_link_data(col_iter);
+
+	  my_snprintf(expect, sizeof(expect), "%s%d.%s",
+		      base, irow, col_pentry->name+offset);
+
+	  /* break out of tabular if doesn't match: */
+	  if((!pentry) || (strcmp(pentry->name, expect) != 0)) {
+	    if(icol != 0) {
+	      /* If the second or later row of a table is missing some
+	       * entries that the first row had, we drop out of the tabular
+	       * format.  This is inefficient so we print a warning message;
+	       * the calling code probably needs to be fixed so that it can
+	       * use the more efficient tabular format.
+	       *
+	       * FIXME: If the first row is missing some entries that the
+	       * second or later row has, then we'll drop out of tabular
+	       * format without an error message. */
+	      freelog(LOG_ERROR,
+		      "In file %s, there is no entry in the registry for \n"
+		      "%s.%s (or the entries are out of order. This means a \n"
+		      "less efficient non-tabular format will be used. To\n"
+		      "avoid this make sure all rows of a table are filled\n"
+		      "out with an entry for every column.",
+		      real_filename, psection->name, expect);
+	      freelog(LOG_ERROR,
+                      /* TRANS: No full stop after the URL, could cause confusion. */
+                      _("Please report this message at %s"),
+		      BUG_URL);
+	      //fz_fprintf(fs, "\n");
+              my_snprintf (S, sizeof(S), "\n");
+              aws_iobuf_append ( bf, S, strlen(S));
+
+
+	    }
+	    //fz_fprintf(fs, "}\n");
+            my_snprintf (S, sizeof(S), "}\n");
+            aws_iobuf_append ( bf, S, strlen(S));
+
+
+	    break;
+	  }
+
+	  if(icol>0) {
+	    //fz_fprintf(fs, ",");
+            my_snprintf (S, sizeof(S), ",");
+            aws_iobuf_append ( bf, S, strlen(S));
+           }
+
+	  if(pentry->svalue) {
+	    //fz_fprintf(fs, "%s", moutstr(pentry->svalue, pentry->escaped));
+             my_snprintf (S, sizeof(S), "%s", moutstr(pentry->svalue, pentry->escaped));
+             aws_iobuf_append ( bf, S, strlen(S));
+
+	  } else {
+	    //fz_fprintf(fs, "%d", pentry->ivalue);
+             my_snprintf (S, sizeof(S), "%d", pentry->ivalue);
+             aws_iobuf_append ( bf, S, strlen(S));
+
+          }
+
+          ent_iter = genlist_link_next(ent_iter);
+          col_iter = genlist_link_next(col_iter);
+	  
+	  icol++;
+	  if(icol==ncol) {
+	    //fz_fprintf(fs, "\n");
+            my_snprintf (S, sizeof(S), "\n");
+            aws_iobuf_append ( bf, S, strlen(S));
+
+	    irow++;
+	    icol = 0;
+	    col_iter = save_iter;
+	  }
+	}
+	if(!pentry) break;
+      }
+      if(!pentry) break;
+      
+      if (pentry->vec_values) {
+        //fz_fprintf(fs, "%s=%s", pentry->name,
+	//           moutstr(pentry->vec_values[0], pentry->escaped));
+        my_snprintf (S, sizeof(S), "%s=%s", pentry->name,
+	           moutstr(pentry->vec_values[0], pentry->escaped));
+        aws_iobuf_append ( bf, S, strlen(S));
+
+
+	for (i = 1; i < pentry->dim; i++) {
+	  //fz_fprintf(fs, ", %s", moutstr(pentry->vec_values[i], pentry->escaped));
+           my_snprintf (S, sizeof(S), ", %s", moutstr(pentry->vec_values[i], pentry->escaped) );
+           aws_iobuf_append ( bf, S, strlen(S));
+
+	}
+      } else if (pentry->svalue) {
+	//fz_fprintf(fs, "%s=%s", pentry->name, moutstr(pentry->svalue, pentry->escaped));
+           my_snprintf (S, sizeof(S), "%s=%s", pentry->name, moutstr(pentry->svalue, pentry->escaped));
+           aws_iobuf_append ( bf, S, strlen(S));
+
+      } else {
+	//fz_fprintf(fs, "%s=%d", pentry->name, pentry->ivalue);
+        my_snprintf (S, sizeof(S), "%s=%d", pentry->name, pentry->ivalue);
+        aws_iobuf_append ( bf, S, strlen(S));
+
+
+      }
+      
+      if (pentry->comment) {
+	//fz_fprintf(fs, "  # %s\n", pentry->comment);
+        my_snprintf (S, sizeof(S), "  # %s\n", pentry->comment);
+        aws_iobuf_append ( bf, S, strlen(S));
+
+
+      } else {
+	//fz_fprintf(fs, "\n");
+        my_snprintf (S, sizeof(S), "\n");
+        aws_iobuf_append ( bf, S, strlen(S));
+
+
+      }
+    }
+  }
+  section_list_iterate_end;
+  
+  (void) moutstr(NULL, TRUE);		/* free internal buffer */
+
+  /* SAVE GAME END*/
+
+  int rv = s3_put ( bf, real_filename );
+
+  printf ( "RV %d\n", rv );
+
+  printf ( "CODE    [%d] \n", bf->code );
+  printf ( "RESULT  [%s] \n", bf->result );
+  printf ( "LEN     [%d] \n", bf->len );
+  printf ( "LASTMOD [%s] \n", bf->lastMod );
+  printf ( "ETAG    [%s] \n", bf->eTag );
+
+  while(-1)
+    {
+  char Ln[1024];
+  int sz = aws_iobuf_getline ( bf, Ln, sizeof(Ln));
+  if ( Ln[0] == 0 ) break;
+  printf ( "S[%3d] %s", sz, Ln );
+    }
+
+
+  return TRUE;
+
+}
+
+
+/***************************************************************
+  Copies a string. Backslash followed by a genuine newline always
+  removes the newline.
+  If full_escapes is TRUE:
+    - '\n' -> newline translation.
+    - Other '\c' sequences (any character 'c') are just passed
+      through with the '\' removed (eg, includes '\\', '\"')
+***************************************************************/
+static char *minstrdup(struct sbuffer *sb, const char *str,
+                       bool full_escapes)
+{
+  char *dest = sbuf_malloc(sb, strlen(str)+1);
+  char *d2=dest;
+  if(dest) {
+    while (*str != '\0') {
+      if (*str == '\\' && *(str+1) == '\n') {
+        /* Escape followed by newline. Skip both */
+        str += 2;
+      } else if (full_escapes && *str=='\\') {
+	str++;
+        if (*str=='n') {
+	  *dest++='\n';
+	  str++;
+	}
+      } else {
+	*dest++=*str++;
+      }
+
+    }
+
+    *dest='\0';
+  }
+  return d2;
+}
+
+
+
+/**************************************************************************
+  Initialize the entry struct and set to default (empty) values.
+**************************************************************************/
+static void entry_init(struct entry *pentry)
+{
+  pentry->name = NULL;
+  pentry->svalue = NULL;
+  pentry->ivalue = 0;
+  pentry->used = 0;
+  pentry->dim = 0;
+  pentry->vec_values = NULL;
+  pentry->comment = NULL;
+  pentry->escaped = TRUE;
+}
+
+/**************************************************************************
+  Return a new entry struct, allocated from sb, with given name,
+  and where tok is a "value" return token from inputfile.
+  The entry value has any escaped double-quotes etc removed.
+**************************************************************************/
+static struct entry *new_entry(struct sbuffer *sb, const char *name,
+			       const char *tok)
+{
+  struct entry *pentry;
+
+  pentry = sbuf_malloc(sb, sizeof(struct entry));
+  entry_init(pentry);
+  pentry->name = sbuf_strdup(sb, name);
+  if (tok[0] != '-' && !my_isdigit(tok[0])) {
+    /* It is not integer, but string with some border character. */
+    pentry->escaped = (tok[0] != '$'); /* Border character '$' means no escapes */
+
+    /* minstrdup() starting after border character */
+    pentry->svalue = minstrdup(sb, tok+1, pentry->escaped);
+    if (SECF_DEBUG_ENTRIES) {
+      freelog(LOG_DEBUG, "entry %s '%s'", name, pentry->svalue);
+    }
+  } else {
+    if (sscanf(tok, "%d", &pentry->ivalue) != 1) {
+      freelog(LOG_ERROR, "'%s' isn't an integer", tok);
+    }
+    if (SECF_DEBUG_ENTRIES) {
+      freelog(LOG_DEBUG, "entry %s %d", name, pentry->ivalue);
+    }
+  }
+  return pentry;
+}
+
+
+
+/**************************************************************************
+...
+**************************************************************************/
+static struct section*
+section_file_append_section(struct section_file *sf, const char *sec_name)
+{
+  struct section *psection;
+
+  psection = sbuf_malloc(sf->sb, sizeof(*psection));
+  psection->name = sbuf_strdup(sf->sb, sec_name);
+  psection->entries = entry_list_new();
+  section_list_append(sf->sections, psection);
+
+  if (!hash_insert(sf->hash_sections, psection->name, psection)) {
+    freelog(LOG_ERROR, "Section \"%s\" name collision", sec_name);
+  }
+
+  return psection;
+}
+
+
+
+/**************************************************************************
+ Insert a entry into the hash table.  The key is malloced here (using sbuf;
+ malloc somewhere required by hash implementation).
+**************************************************************************/
+static void secfilehash_insert(struct section_file *file,
+			       char *key, struct entry *data)
+{
+  struct entry *hentry;
+
+  key = sbuf_strdup(file->sb, key);
+  hentry = hash_replace(file->hashd->htbl, key, data);
+  if (hentry) {
+    if (file->hashd->allow_duplicates) {
+      hentry->used = 1;
+      file->hashd->num_duplicates++;
+      /* Subsequent entries replace earlier ones; could do differently so
+	 that first entry would be used and following ones ignored.
+	 Need to mark the replaced one as used or else it will show
+	 up when we iterate the sections and entries (since hash
+	 lookup will never find it to mark it as used).
+      */
+    } else {
+      freelog(LOG_FATAL, "Tried to insert same value twice: %s (sectionfile %s)",
+	      key, secfile_filename(file));
+      exit(EXIT_FAILURE);
+    }
+  }
+}
+
+/**************************************************************************
+ Build a hash table for the file.  Note that the section_file should
+ not be modified (except to free it) subsequently.
+ If allow_duplicates is true, then relax normal condition that
+ all entries must have unique names; in this case for duplicates
+ the hash ref will be to the _last_ entry.
+**************************************************************************/
+static void secfilehash_build(struct section_file *file, bool allow_duplicates)
+{
+  struct hash_data *hashd;
+  char buf[256];
+
+  hashd = file->hashd = fc_malloc(sizeof(struct hash_data));
+  hashd->htbl = hash_new_nentries(hash_fval_string, hash_fcmp_string,
+				  file->num_entries);
+  
+  hashd->num_entries_hashbuild = file->num_entries;
+  hashd->allow_duplicates = allow_duplicates;
+  hashd->num_duplicates = 0;
+  
+  section_list_iterate(file->sections, psection) {
+    entry_list_iterate(psection->entries, pentry) {
+      my_snprintf(buf, sizeof(buf), "%s.%s", psection->name, pentry->name);
+      secfilehash_insert(file, buf, pentry);
+    }
+    entry_list_iterate_end;
+  }
+  section_list_iterate_end;
+  
+  if (hashd->allow_duplicates) {
+    freelog(LOG_DEBUG, "Hash duplicates during build: %d",
+	    hashd->num_duplicates);
+  }
+}
+
+
+
+/****************************************************************************
+  Return the section with the given name, or NULL if there is none.
+****************************************************************************/
+static struct section *find_section_by_name(struct section_file *sf,
+					    const char *name)
+{
+  return hash_lookup_data(sf->hash_sections, name);
+}	
+
+
+/**************************************************************************
+...
+**************************************************************************/
+static bool section_file_read_dup(struct section_file *sf,
+      	      	      	      	  const char *filename,
+      	      	      	      	  struct inputfile *inf,
+				  bool allow_duplicates,
+				  const char *requested_section)
+{
+  struct section *psection = NULL;
+  struct entry *pentry;
+  bool table_state = FALSE;	/* 1 when within tabular format */
+  int table_lineno = 0;		/* row number in tabular, 0=top data row */
+  struct sbuffer *sb;
+  const char *tok;
+  int i;
+  struct astring base_name = ASTRING_INIT;    /* for table or single entry */
+  struct astring entry_name = ASTRING_INIT;
+  struct astring_vector columns;    /* astrings for column headings */
+  bool found_my_section = FALSE;
+
+  section_file_init(sf);
+  if (filename) {
+    sf->filename = mystrdup(filename);
+  } else {
+    sf->filename = NULL;
+  }
+  astring_vector_init(&columns);
+  sb = sf->sb;
+
+  if (filename) {
+    freelog(LOG_VERBOSE, "Reading registry from \"%s\"", filename);
+  } else {
+    freelog(LOG_VERBOSE, "Reading registry");
+  }
+
+  while(!inf_at_eof(inf)) {
+    if (inf_token(inf, INF_TOK_EOL))
+      continue;
+    if (inf_at_eof(inf)) {
+      /* may only realise at eof after trying to read eol above */
+      break;
+    }
+    tok = inf_token(inf, INF_TOK_SECTION_NAME);
+    if (tok) {
+      if (found_my_section) {
+	/* This shortcut will stop any further loading after the requested
+	 * section has been loaded (i.e., at the start of a new section).
+	 * This is needed to make the behavior useful, since the whole
+	 * purpose is to short-cut further loading of the file.  However
+	 * normally a section may be split up, and that will no longer
+	 * work here because it will be short-cut. */
+	inf_log(inf, LOG_DEBUG, "found requested section; finishing");
+	return TRUE;
+      }
+      if (table_state) {
+	inf_log(inf, LOG_ERROR, "new section during table");
+        return FALSE;
+      }
+      /* Check if we already have a section with this name.
+	 (Could ignore this and have a duplicate sections internally,
+	 but then secfile_get_secnames_prefix would return duplicates.)
+	 Duplicate section in input are likely to be useful for includes.
+      */
+      psection = find_section_by_name(sf, tok);
+      if (!psection) {
+	if (!requested_section || strcmp(tok, requested_section) == 0) {
+	  psection = section_file_append_section(sf, tok);
+	  if (requested_section) {
+	    found_my_section = TRUE;
+	  }
+	}
+      }
+      (void) inf_token_required(inf, INF_TOK_EOL);
+      continue;
+    }
+    if (inf_token(inf, INF_TOK_TABLE_END)) {
+      if (!table_state) {
+	inf_log(inf, LOG_ERROR, "misplaced \"}\"");
+        return FALSE;
+      }
+      (void) inf_token_required(inf, INF_TOK_EOL);
+      table_state = FALSE;
+      continue;
+    }
+    if (table_state) {
+      i = -1;
+      do {
+	int num_columns = astring_vector_size(&columns);
+
+	i++;
+	inf_discard_tokens(inf, INF_TOK_EOL);  	/* allow newlines */
+	if (!(tok = inf_token_required(inf, INF_TOK_VALUE))) {
+          return FALSE;
+        }
+
+	if (i < num_columns) {
+	  astr_minsize(&entry_name, base_name.n + 10 + columns.p[i].n);
+	  my_snprintf(entry_name.str, entry_name.n_alloc, "%s%d.%s",
+		      base_name.str, table_lineno, columns.p[i].str);
+	} else {
+	  astr_minsize(&entry_name,
+		       base_name.n + 20 + columns.p[num_columns - 1].n);
+	  my_snprintf(entry_name.str, entry_name.n_alloc, "%s%d.%s,%d",
+		      base_name.str, table_lineno,
+		      columns.p[num_columns - 1].str,
+		      (int) (i - num_columns + 1));
+	}
+	if (psection) {
+	  /* Load this entry (if psection == NULL the entry is silently
+	   * skipped). */
+	  pentry = new_entry(sb, entry_name.str, tok);
+	  entry_list_append(psection->entries, pentry);
+	  sf->num_entries++;
+	}
+      } while(inf_token(inf, INF_TOK_COMMA));
+      
+      (void) inf_token_required(inf, INF_TOK_EOL);
+      table_lineno++;
+      continue;
+    }
+    
+    if (!(tok = inf_token_required(inf, INF_TOK_ENTRY_NAME))) {
+      return FALSE;
+    }
+
+    /* need to store tok before next calls: */
+    astr_minsize(&base_name, strlen(tok)+1);
+    strcpy(base_name.str, tok);
+
+    inf_discard_tokens(inf, INF_TOK_EOL);  	/* allow newlines */
+    
+    if (inf_token(inf, INF_TOK_TABLE_START)) {
+      i = -1;
+      do {
+	i++;
+	inf_discard_tokens(inf, INF_TOK_EOL);  	/* allow newlines */
+	if (!(tok = inf_token_required(inf, INF_TOK_VALUE))) {
+          return FALSE;
+        }
+	if( tok[0] != '\"' ) {
+	  inf_log(inf, LOG_ERROR, "table column header non-string");
+          return FALSE;
+	}
+	{ 	/* expand columns: */
+	  int j, n_prev;
+	  n_prev = astring_vector_size(&columns);
+	  for (j = i + 1; j < n_prev; j++) {
+	    astr_free(&columns.p[j]);
+	  }
+	  astring_vector_reserve(&columns, i + 1);
+	  for (j = n_prev; j < i + 1; j++) {
+	    astr_init(&columns.p[j]);
+	  }
+	}
+	astr_minsize(&columns.p[i], strlen(tok));
+	strcpy(columns.p[i].str, tok+1);
+	
+      } while(inf_token(inf, INF_TOK_COMMA));
+      
+      (void) inf_token_required(inf, INF_TOK_EOL);
+      table_state = TRUE;
+      table_lineno=0;
+      continue;
+    }
+    /* ordinary value: */
+    i = -1;
+    do {
+      i++;
+      inf_discard_tokens(inf, INF_TOK_EOL);  	/* allow newlines */
+      if (!(tok = inf_token_required(inf, INF_TOK_VALUE))) {
+        return FALSE;
+      }
+      if (i==0) {
+	pentry = new_entry(sb, base_name.str, tok);
+      } else {
+	astr_minsize(&entry_name, base_name.n + 20);
+	my_snprintf(entry_name.str, entry_name.n_alloc,
+		    "%s,%d", base_name.str, i);
+	pentry = new_entry(sb, entry_name.str, tok);
+      }
+      if (psection) {
+	/* Load this entry (if psection == NULL the entry is silently
+	 * skipped). */
+	entry_list_append(psection->entries, pentry);
+	sf->num_entries++;
+      }
+    } while(inf_token(inf, INF_TOK_COMMA));
+    (void) inf_token_required(inf, INF_TOK_EOL);
+  }
+  
+  if (table_state) {
+    if (filename) {
+      freelog(LOG_FATAL, "finished registry %s before end of table\n", filename);
+    } else {
+      freelog(LOG_FATAL, "finished registry before end of table\n");
+    }
+    exit(EXIT_FAILURE);
+  }
+  
+  astr_free(&base_name);
+  astr_free(&entry_name);
+  for (i = 0; i < astring_vector_size(&columns); i++) {
+    astr_free(&columns.p[i]);
+  }
+  astring_vector_free(&columns);
+  
+  secfilehash_build(sf, allow_duplicates);
+    
+  return TRUE;
+}
+
+
+/**************************************************************************
+  Load a section_file, but disallow (die on) duplicate entries.
+**************************************************************************/
+bool net_file_load(struct section_file *my_section_file,
+			           const char *filename)
+{
+  char real_filename[1024];
+  struct inputfile *inf;
+  bool success;
+
+  char savedata[512000];
+
+
+  FILE *stream;
+
+  savedata[0] = '\0';
+
+  aws_init ();
+  aws_set_debug ( 0 );
+  int rc = aws_read_config  ( "freeciv" );
+  if ( rc )
+    {
+      puts ( "Could not find a credential in the config file" );
+      puts ( "Make sure your ~/.awsAuth file is correct" );
+      exit ( 1 );
+    }
+
+  s3_set_host ( "s3.amazonaws.com");
+  s3_set_bucket ("freeciv-net-savegames");
+
+
+  IOBuf * bf = aws_iobuf_new ();
+
+  interpret_tilde(real_filename, sizeof(real_filename), filename);
+
+  int rv = s3_get ( bf, real_filename );
+
+  printf ( "RV %d\n", rv );
+
+  printf ( "CODE    [%d] \n", bf->code );
+  printf ( "RESULT  [%s] \n", bf->result );
+  printf ( "LEN     [%d] \n", bf->len );
+  printf ( "C-LEN   [%d] \n", bf->contentLen );
+  printf ( "LASTMOD [%s] \n", bf->lastMod );
+  printf ( "ETAG    [%s] \n", bf->eTag );
+
+  while (-1) {
+    char Ln[1024];
+    int sz = aws_iobuf_getline ( bf, Ln, sizeof(Ln));
+    if ( Ln[0] == 0 ) break;
+    sz_strlcat(savedata, Ln);
+  }
+
+  stream = fmemopen (savedata, strlen (savedata), "r");
+
+  inf = inf_from_stream(fz_from_stream(stream), datafilename);
+
+  if (!inf) {
+    return FALSE;
+  }
+  success = section_file_read_dup(my_section_file, real_filename,
+			       inf, FALSE, NULL);
+
+  inf_close(inf);
+
+  return success;
+}
+
diff -Nurd -X.diff_ignore freeciv/server/netsave.h freeciv/server/netsave.h
--- freeciv/server/netsave.h	1970-01-01 02:00:00.000000000 +0200
+++ freeciv/server/netsave.h	2012-05-16 22:10:12.000000000 +0300
@@ -0,0 +1,28 @@
+
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__NETSAVE_H
+#define FC__NETSAVE_H
+
+#include "ioz.h"
+#include "shared.h"		/* bool type and fc__attribute */
+#include "registry.h"
+
+
+bool net_file_save(struct section_file *my_section_file,
+                       const char *filename);
+
+bool net_file_load(struct section_file *my_section_file,
+			           const char *filename);
+
+#endif  /* FC__NETSAVE_H */
diff -Nurd -X.diff_ignore freeciv/server/savegame.c freeciv/server/savegame.c
--- freeciv/server/savegame.c	2012-05-16 20:56:43.000000000 +0300
+++ freeciv/server/savegame.c	2012-05-16 22:10:15.000000000 +0300
@@ -407,8 +407,9 @@
     break;
   }
 
-  assert(0);
-  return '?';
+  // FIXME: should not get here!
+  //assert(0);
+  return 'a';
 }
 
 /****************************************************************************
diff -Nurd -X.diff_ignore freeciv/server/srv_main.c freeciv/server/srv_main.c
--- freeciv/server/srv_main.c	2012-05-16 21:34:28.000000000 +0300
+++ freeciv/server/srv_main.c	2012-05-16 22:10:12.000000000 +0300
@@ -100,6 +100,7 @@
 #include "gamehand.h"
 #include "ggzserver.h"
 #include "handchat.h"
+#include "netsave.h"
 #include "maphand.h"
 #include "meta.h"
 #include "notify.h"
@@ -1045,7 +1046,8 @@
   struct timer *timer_cpu, *timer_user;
 
   if (!orig_filename) {
-    filename[0] = '\0';
+    con_write(C_FAIL, _("Failed saving game. Missing filename."));
+    return;
   } else {
     sz_strlcpy(filename, orig_filename);
   }
@@ -1100,12 +1102,12 @@
 
     if (!scenario) {
       /* Ensure the saves directory exists. */
-      make_dir(srvarg.saves_pathname);
+      //make_dir(srvarg.saves_pathname);
 
       sz_strlcpy(tmpname, srvarg.saves_pathname);
     } else {
       /* Make sure scenario directory exist */
-      make_dir(srvarg.scenarios_pathname);
+      //make_dir(srvarg.scenarios_pathname);
 
       sz_strlcpy(tmpname, srvarg.scenarios_pathname);
     }
@@ -1117,12 +1119,21 @@
     sz_strlcpy(filename, tmpname);
   }
 
-  if (!section_file_save(&file, filename, game.info.save_compress_level,
-                         game.info.save_compress_type))
+
+  if (!net_file_save(&file, filename))
     con_write(C_FAIL, _("Failed saving game as %s"), filename);
   else
     con_write(C_OK, _("Game saved as %s"), filename);
 
+
+  /* Don't save to disk. Webclient saves to Amazon S3.
+
+    if (!section_file_save(&file, filename, game.info.save_compress_level,
+                         game.info.save_compress_type))
+    con_write(C_FAIL, _("Failed saving game as %s"), filename);
+  else
+    con_write(C_OK, _("Game saved as %s"), filename);*/
+
   section_file_free(&file);
 
   freelog(LOG_VERBOSE, "Save time: %g seconds (%g apparent)",
diff -Nurd -X.diff_ignore freeciv/server/stdinhand.c freeciv/server/stdinhand.c
--- freeciv/server/stdinhand.c	2012-05-16 20:56:43.000000000 +0300
+++ freeciv/server/stdinhand.c	2012-05-16 22:10:15.000000000 +0300
@@ -65,6 +65,7 @@
 #include "mapgen.h"
 #include "maphand.h"
 #include "meta.h"
+#include "netsave.h"
 #include "notify.h"
 #include "plrhand.h"
 #include "report.h"
@@ -699,11 +700,6 @@
 **************************************************************************/
 static bool save_command(struct connection *caller, char *arg, bool check)
 {
-  if (is_restricted(caller)) {
-    cmd_reply(CMD_SAVE, caller, C_FAIL,
-              _("You cannot save games manually on this server."));
-    return FALSE;
-  }
   if (!check) {
     save_game(arg, "User request", FALSE);
   }
@@ -3448,39 +3444,11 @@
     return FALSE;
   }
 
-  {
-    /* it is a normal savegame or maybe a scenario */
-    char testfile[MAX_LEN_PATH];
-    const char *paths[] = { "", "scenario/", NULL };
-    const char *exts[] = {
-      "sav", "gz", "bz2", "sav.gz", "sav.bz2", NULL
-    };
-    const char **path, **ext, *found = NULL;
-
-    for (path = paths; !found && *path; path++) {
-      for (ext = exts; !found && *ext; ext++) {
-        my_snprintf(testfile, sizeof(testfile), "%s%s.%s",
-                    *path, filename, *ext);
-        if ((found = datafilename(testfile))) {
-          sz_strlcpy(arg, found);
-        }
-      }
-    }
-
-    if (is_restricted(caller) && !found) {
-      cmd_reply(CMD_LOAD, caller, C_FAIL, _("Cannot find savegame or "
-                "scenario with the name \"%s\"."), filename);
-      return FALSE;
-    }
-
-    if (!found) {
-      sz_strlcpy(arg, filename);
-    }
-  }
+  sz_strlcpy(arg, filename);
 
   /* attempt to parse the file */
 
-  if (!section_file_load_nodup(&file, arg)) {
+  if (!net_file_load(&file, arg)) {
     cmd_reply(CMD_LOAD, caller, C_FAIL, _("Could not load savefile: %s"), arg);
     send_load_game_info(FALSE);
     return FALSE;
