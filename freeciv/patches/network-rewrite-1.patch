diff -Nurd -X.diff_ignore freeciv/common/connection.h freeciv/common/connection.h
--- freeciv/common/connection.h	2012-09-02 01:13:25.000000000 +0300
+++ freeciv/common/connection.h	2012-09-02 01:26:46.000000000 +0300
@@ -41,11 +41,13 @@
 /* common */
 #include "fc_types.h"
 
+#include <jansson.h>
+
 struct genhash;
 struct timer_list;
 struct conn_pattern_list;
 
-#define MAX_LEN_PACKET   4096
+#define MAX_LEN_PACKET   65536
 
 #define MAX_LEN_BUFFER   (MAX_LEN_PACKET * 128)
 #define MAX_LEN_CAPSTR    512
@@ -142,6 +144,7 @@
   struct socket_packet_buffer *buffer;
   struct socket_packet_buffer *send_buffer;
   struct timer *last_write;
+  json_t *json_packet;
 
   double ping_time;
   
diff -Nurd -X.diff_ignore freeciv/common/dataio.c freeciv/common/dataio.c
--- freeciv/common/dataio.c	2012-09-02 00:54:27.000000000 +0300
+++ freeciv/common/dataio.c	2012-09-02 01:44:55.000000000 +0300
@@ -196,8 +196,13 @@
 /**************************************************************************
   Insert value using 8 bits. May overflow.
 **************************************************************************/
-void dio_put_uint8(struct data_out *dout, int value)
+void dio_put_uint8(struct data_out *dout, char *key, int value)
 {
+  json_object_set_new(dout->json, key, json_integer(value));
+}
+
+void dio_put_uint8_old(struct data_out *dout, int value)
+ {
   if (enough_space(dout, 1)) {
     uint8_t x = value;
 
@@ -210,7 +215,7 @@
 /**************************************************************************
   Insert value using 16 bits. May overflow.
 **************************************************************************/
-void dio_put_uint16(struct data_out *dout, int value)
+void dio_put_uint16_old(struct data_out *dout, int value)
 {
   if (enough_space(dout, 2)) {
     uint16_t x = htons(value);
@@ -224,6 +229,15 @@
 /**************************************************************************
   Insert value using 16 bits.
 **************************************************************************/
+void dio_put_uint16(struct data_out *dout, char *key, int value)
+{
+  json_object_set_new(dout->json, key, json_integer(value));
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+#if 0
 void dio_put_uint32(struct data_out *dout, int value)
 {
   if (enough_space(dout, 4)) {
@@ -308,11 +322,12 @@
     }
   }
 }
+#endif
 
 /**************************************************************************
   Insert block directly from memory.
 **************************************************************************/
-void dio_put_memory(struct data_out *dout, const void *value, size_t size)
+void dio_put_memory_old(struct data_out *dout, const void *value, size_t size)
 {
   if (enough_space(dout, size)) {
     memcpy(ADD_TO_POINTER(dout->dest, dout->current), value, size);
@@ -323,18 +338,18 @@
 /**************************************************************************
   Insert NULL-terminated string. Conversion callback is used if set.
 **************************************************************************/
-void dio_put_string(struct data_out *dout, const char *value)
+void dio_put_string_old(struct data_out *dout, const char *value)
 {
   if (put_conv_callback) {
     size_t length;
     char *buffer;
 
     if ((buffer = (*put_conv_callback) (value, &length))) {
-      dio_put_memory(dout, buffer, length + 1);
+      dio_put_memory_old(dout, buffer, length + 1);
       free(buffer);
     }
   } else {
-    dio_put_memory(dout, value, strlen(value) + 1);
+    dio_put_memory_old(dout, value, strlen(value) + 1);
   }
 }
 
@@ -343,6 +358,7 @@
   value string each bit is represented by one character, value '1' indicating
   TRUE bit.
 **************************************************************************/
+#if 0
 void dio_put_bit_string(struct data_out *dout, const char *value)
 {
   /* Note that size_t is often an unsigned type, so we must be careful
@@ -440,11 +456,106 @@
   }
 }
 
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_worklist(struct data_out *dout, char *key, const struct worklist *pwl)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_uint8(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_uint32(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_sint8(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_sint16(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_sint32(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_bool8(struct data_out *dout, char *key, bool *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, values[i] ? json_true() : json_false());
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
 /**************************************************************************
  Receive uint8 value to dest. In case of failure, value stored to dest
  will be zero. Note that zero is legal value even when there is no failure.
 **************************************************************************/
-bool dio_get_uint8(struct data_in *din, int *dest)
+bool dio_get_uint8_old(struct data_in *din, int *dest)
 {
   if (enough_data(din, 1)) {
     if (dest) {
@@ -464,11 +575,100 @@
   return TRUE;
 }
 
+bool dio_get_uint8(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get uint8 with key: %s", key);
+    return FALSE;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get unit8 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
 /**************************************************************************
  Receive uint16 value to dest. In case of failure, value stored to dest
  will be zero. Note that zero is legal value even when there is no failure.
 **************************************************************************/
-bool dio_get_uint16(struct data_in *din, int *dest)
+bool dio_get_uint16(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get uint16 with key: %s", key);
+    return FALSE;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get unit16 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+bool dio_get_uint32(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get uint32 with key: %s", key);
+    return FALSE;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get unit32 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+bool dio_get_bit_string(json_t *json_packet, char *key, char *dest,
+ 			size_t max_dest_size)
+{
+  /* TODO: implement */
+  return TRUE;
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+bool dio_get_tech_list(json_t *json_packet, char *key, int *dest)
+{
+  /* TODO: implement */
+  return TRUE;
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+bool dio_get_worklist(json_t *json_packet, char *key, struct worklist *pwl)
+{
+  /* TODO: implement */
+  return TRUE;
+}
+
+/**************************************************************************
+ Receive uint16 value to dest. In case of failure, value stored to dest
+ will be zero. Note that zero is legal value even when there is no failure.
+**************************************************************************/
+bool dio_get_uint16_old(struct data_in *din, int *dest)
 {
   if (enough_data(din, 2)) {
     if (dest) {
@@ -492,6 +692,7 @@
  Receive uint32 value to dest. In case of failure, value stored to dest
  will be zero. Note that zero is legal value even when there is no failure.
 **************************************************************************/
+#if 0
 bool dio_get_uint32(struct data_in *din, int *dest)
 {
   if (enough_data(din, 4)) {
@@ -606,11 +807,12 @@
 
   return TRUE;
 }
+#endif
 
 /**************************************************************************
   Take string. Conversion callback is used.
 **************************************************************************/
-bool dio_get_string(struct data_in *din, char *dest, size_t max_dest_size)
+bool dio_get_string_old(struct data_in *din, char *dest, size_t max_dest_size)
 {
   char *c;
   size_t ps_len;		/* length in packet, not including null */
@@ -653,6 +855,7 @@
 /**************************************************************************
   Take bits and produce string containing chars '0' and '1'
 **************************************************************************/
+#if 0
 bool dio_get_bit_string(struct data_in *din, char *dest,
 			size_t max_dest_size)
 {
@@ -815,10 +1018,31 @@
 
   return retval;
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_uint8_vec8(json_t *json_packet, char *key, int **values, int stop_value)
+{
+  /* TODO: implement */
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_uint16_vec8(json_t *json_packet, char *key, int **values,
+                         int stop_value)
+{
+  /* TODO: implement */
+  return TRUE;
+}
 
 /**************************************************************************
  Receive vector of uint6 values.
 **************************************************************************/
+#if 0
 bool dio_get_uint16_vec8(struct data_in *din, int **values, int stop_value)
 {
   int count, inx;
@@ -858,10 +1082,21 @@
 
   return retval;
 }
+#endif
+
+/**************************************************************************
+  ..
+**************************************************************************/
+bool dio_get_requirement(json_t *json_packet, char *key, struct requirement *preq)
+{
+  /* TODO: implement */
+  return TRUE;
+}
 
 /**************************************************************************
   Serialize a requirement.
 **************************************************************************/
+#if 0
 void dio_put_requirement(struct data_out *dout, const struct requirement *preq)
 {
   int type, range, value;
@@ -875,3 +1110,217 @@
   dio_put_bool8(dout, survives);
   dio_put_bool8(dout, negated);
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_uint32(struct data_out *dout, char *key, int value)
+{
+  json_object_set_new(dout->json, key, json_integer(value));
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_bool8(struct data_out *dout, char *key, bool value)
+{
+  json_object_set_new(dout->json, key, value ? json_true() : json_false());
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_bool32(struct data_out *dout, char *key, bool value)
+{
+  json_object_set_new(dout->json, key, value ? json_true() : json_false());
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_uint8_vec8(struct data_out *dout, char *key, int *values, int stop_value)
+{
+  /* TODO: implement. */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_uint16_vec8(struct data_out *dout, char *key, int *values,
+                         int stop_value)
+{
+  /* TODO: implement. */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_memory(struct data_out *dout, char *key, const void *value, size_t size)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_string(struct data_out *dout, char *key, const char *value)
+{
+  json_object_set_new(dout->json, key, json_string(value));
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_string_array(struct data_out *dout, char *key, 
+		          const char *value, int size)
+{
+  int i;
+
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    if (value != NULL) {
+      json_array_append_new(array, json_string(value + i));
+    }
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_bit_string(struct data_out *dout, char *key, const char *value)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_tech_list(struct data_out *dout, char *key, const int *value)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+  ..
+**************************************************************************/
+void dio_put_requirement(struct data_out *dout, char *key, const struct requirement *preq, int size)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_bool8(json_t *json_packet, char *key, bool * dest)
+{
+  json_t *pbool = json_object_get(json_packet, key);
+
+  if (!pbool) {
+    log_error("ERROR: Unable to get bool8 with key: %s", key);
+    return FALSE;
+  } 
+  *dest = json_is_true(pbool);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get bool with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_bool32(json_t *json_packet, char *key, bool * dest)
+{
+  json_t *pbool = json_object_get(json_packet, key);
+
+  if (!pbool) {
+    log_error("ERROR: Unable to get bool32 with key: %s", key);
+    return FALSE;
+  }
+  *dest = json_is_true(pbool);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get bool32 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_sint8(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get sint8 with key: %s", key);
+    return FALSE;
+  }
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get sint8 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_sint16(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get sint16 with key: %s", key);
+    return FALSE;
+  }
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get sint16 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_memory(json_t *json_packet, char *key, void *dest, size_t dest_size)
+{
+  /* TODO: implement */ 
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_string(json_t *json_packet, char *key, char *dest, size_t max_dest_size)
+{
+  json_t *pstring = json_object_get(json_packet, key);
+
+  if (!pstring) {
+    log_error("ERROR: Unable to get string with key: %s", key);
+    return FALSE;
+  }
+  const char *result_str = json_string_value(pstring);
+
+  if (dest && !(*get_conv_callback) (dest, max_dest_size, result_str, strlen(result_str))) {
+    log_error("ERROR: Unable to get string with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
diff -Nurd -X.diff_ignore freeciv/common/dataio.h freeciv/common/dataio.h
--- freeciv/common/dataio.h	2012-09-02 00:54:27.000000000 +0300
+++ freeciv/common/dataio.h	2012-09-02 01:29:44.000000000 +0300
@@ -20,6 +20,8 @@
 #include "bitvector.h"
 #include "support.h"            /* bool type */
 
+#include <jansson.h>
+
 struct worklist;
 struct requirement;
 
@@ -33,6 +35,7 @@
 
 struct data_out {
   void *dest;
+  json_t *json;
   size_t dest_size, used, current;
   bool too_short;		/* set to 1 if try to read past end */
 };
@@ -57,6 +60,8 @@
 
 /* gets */
 
+#if 0
+
 bool dio_get_uint8(struct data_in *din, int *dest);
 bool dio_get_uint16(struct data_in *din, int *dest);
 bool dio_get_uint32(struct data_in *din, int *dest);
@@ -81,11 +86,41 @@
 bool dio_get_uint8_vec8(struct data_in *din, int **values, int stop_value);
 bool dio_get_uint16_vec8(struct data_in *din, int **values, int stop_value);
 
+#else
+
+bool dio_get_uint8(json_t *json_packet, char *key, int *dest);
+bool dio_get_uint16(json_t *json_packet, char *key, int *dest);
+bool dio_get_uint32(json_t *json_packet, char *key, int *dest);
+
+bool dio_get_uint16_old(struct data_in *din, int *dest);
+bool dio_get_uint8_old(struct data_in *din, int *dest);
+bool dio_get_sint8(json_t *json_packet, char *key, int *dest);
+bool dio_get_sint16(json_t *json_packet, char *key, int *dest);
+#define dio_get_sint32(d,v,x) dio_get_uint32(d,v,x)
+
+
+bool dio_get_bool8(json_t *json_packet, char *key, bool *dest);
+bool dio_get_bool32(json_t *json_packet, char *key, bool *dest);
+bool dio_get_memory(json_t *json_packet, char *key, void *dest, size_t dest_size);
+bool dio_get_string(json_t *json_packet, char *key, char *dest, size_t max_dest_size);
+bool dio_get_string_old(struct data_in *din, char *dest, size_t max_dest_size);
+bool dio_get_bit_string(json_t *json_packet, char *key, char *dest,
+ 			size_t max_dest_size);
+bool dio_get_tech_list(json_t *json_packet, char *key, int *dest);
+bool dio_get_worklist(json_t *json_packet, char *key, struct worklist *pwl);
+bool dio_get_requirement(json_t *json_packet, char *key, struct requirement *preq);
+
+bool dio_get_uint8_vec8(json_t *json_packet, char *key, int **values, int stop_value);
+bool dio_get_uint16_vec8(json_t *json_packet, char *key, int **values, int stop_value);
+#endif
+
 /* Should be a function but we need some macro magic. */
 #define DIO_BV_GET(pdin, bv) \
   dio_get_memory((pdin), (bv).vec, sizeof((bv).vec))
 
 /* puts */
+
+#if 0
 void dio_put_uint8(struct data_out *dout, int value);
 void dio_put_uint16(struct data_out *dout, int value);
 void dio_put_uint32(struct data_out *dout, int value);
@@ -114,6 +149,48 @@
 #define DIO_BV_PUT(pdout, bv) \
   dio_put_memory((pdout), (bv).vec, sizeof((bv).vec))
 
+#else
+
+void dio_put_uint8(struct data_out *dout, char *key, int value);
+void dio_put_uint8_old(struct data_out *dout, int value);
+void dio_put_uint16(struct data_out *dout, char *key, int value);
+void dio_put_uint32(struct data_out *dout, char *key, int value);
+void dio_put_uint16_old(struct data_out *dout, int value);
+
+void dio_put_array_uint8(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_uint32(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint8(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint16(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint32(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_bool8(struct data_out *dout, char *key, bool *values, int size);
+
+#define dio_put_sint8(d,k,v) dio_put_uint8(d,k,v)
+#define dio_put_sint16(d,k,v) dio_put_uint16(d,k,v)
+#define dio_put_sint32(d,k,v) dio_put_uint32(d,k,v)
+
+void dio_put_bool8(struct data_out *dout, char *key, bool value);
+void dio_put_bool32(struct data_out *dout, char *key, bool value);
+
+void dio_put_memory(struct data_out *dout, char *key, const void *value, size_t size);
+void dio_put_string(struct data_out *dout, char *key, const char *value);
+void dio_put_bit_string(struct data_out *dout, char *key, const char *value);
+void dio_put_city_map(struct data_out *dout, char *key, const char *value);
+void dio_put_tech_list(struct data_out *dout, char *key, const int *value);
+void dio_put_worklist(struct data_out *dout, char *key, const struct worklist *pwl);
+void dio_put_requirement(struct data_out *dout, char *key, const struct requirement *preq, int size);
+
+void dio_put_uint8_vec8(struct data_out *dout, char *key, int *values, int stop_value);
+void dio_put_uint16_vec8(struct data_out *dout, char *key, int *values, int stop_value);
+void dio_put_string_old(struct data_out *dout, const char *value);
+void dio_put_memory_old(struct data_out *dout, const void *value, size_t size);
+void dio_put_string_array(struct data_out *dout, char *key, const char *value, int size);
+
+/* Should be a function but we need some macro magic. */
+#define DIO_BV_PUT(pdout, type, bv) \
+  dio_put_memory((pdout), type, (bv).vec, sizeof((bv).vec))
+
+#endif
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff -Nurd -X.diff_ignore freeciv/common/generate_packets.py freeciv/common/generate_packets.py
--- freeciv/common/generate_packets.py	2012-09-02 01:13:25.000000000 +0300
+++ freeciv/common/generate_packets.py	2012-09-02 01:27:54.000000000 +0300
@@ -249,7 +249,7 @@
         if self.is_array==1:
             tmp="real_packet->%(name)s[i] = %(name)s[i]"%self.__dict__
             return '''  {
-    int i;
+    int i; /* this is for put. */
 
     for (i = 0; i < %(array_size_u) s; i++) {
       %(tmp)s;
@@ -347,41 +347,36 @@
     # Returns code which put this field.
     def get_put(self):
         if self.dataio_type=="bitvector":
-            return "DIO_BV_PUT(&dout, packet->%(name)s);"%self.__dict__
+            return "DIO_BV_PUT(&dout, \"%(name)s\", packet->%(name)s);"%self.__dict__
 
         if self.struct_type=="float" and not self.is_array:
-            return "  dio_put_uint32(&dout, (int)(real_packet->%(name)s * %(float_factor)d));"%self.__dict__
+            return "  dio_put_uint32(&dout, \"%(name)s\", (int)(real_packet->%(name)s * %(float_factor)d));"%self.__dict__
         
         if self.dataio_type in ["worklist"]:
-            return "  dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s);"%self.__dict__
+            return "  dio_put_%(dataio_type)s(&dout, \"%(name)s\", &real_packet->%(name)s);"%self.__dict__
 
         if self.dataio_type in ["memory"]:
-            return "  dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
+            return "  dio_put_%(dataio_type)s(&dout, \"%(name)s\", &real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
         
         arr_types=["string","bit_string","city_map","tech_list",
                    "unit_list","building_list"]
         if (self.dataio_type in arr_types and self.is_array==1) or \
            (self.dataio_type not in arr_types and self.is_array==0):
-            return "  dio_put_%(dataio_type)s(&dout, real_packet->%(name)s);"%self.__dict__
-        if self.is_struct:
-            if self.is_array==2:
-                c="dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s[i][j]);"%self.__dict__
-            else:
-                c="dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s[i]);"%self.__dict__
-        elif self.dataio_type=="string":
-            c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i]);"%self.__dict__
+            return "  dio_put_%(dataio_type)s(&dout, \"%(name)s\", real_packet->%(name)s);"%self.__dict__
+        if self.dataio_type=="string":
             array_size_u=self.array_size1_u
+            self.__dict__["array_size_u"] = array_size_u
+            c="/* dio_put_%(dataio_type)s(&dout, \"%(name)s\", real_packet->%(name)s[i]; */"%self.__dict__
 
         elif self.struct_type=="float":
-            if self.is_array==2:
-                c="  dio_put_uint32(&dout, (int)(real_packet->%(name)s[i][j] * %(float_factor)d));"%self.__dict__
-            else:
-                c="  dio_put_uint32(&dout, (int)(real_packet->%(name)s[i] * %(float_factor)d));"%self.__dict__
+            c="/* dio_put_uint32(&dout, \"%(name)s\", (int)(real_packet->%(name)s[i] * %(float_factor)d)); */"%self.__dict__
+        elif self.dataio_type=="requirement":
+            c="  dio_put_%(dataio_type)s(&dout, \"%(name)s\", (struct requirement *)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
         else:
             if self.is_array==2:
-                c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i][j]);"%self.__dict__
+                c=" /* dio_put_array_%(dataio_type)s(&dout, \"%(name)s\", real_packet->%(name)s[i][j]); */"%self.__dict__
             else:
-                c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i]);"%self.__dict__
+                c="dio_put_array_%(dataio_type)s(&dout, \"%(name)s\", (void *)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
 
         if not self.diff:
             if self.is_array==2 and self.dataio_type!="string":
@@ -398,11 +393,7 @@
             else:
                 return '''
     {
-      int i;
-
-      for (i = 0; i < %(array_size_u)s; i++) {
         %(c)s
-      }
     } '''%self.get_dict(vars())
         else:
             return '''
@@ -444,64 +435,64 @@
             return '''{
   int tmp;
   
-  dio_get_uint32(&din, &tmp);
+  dio_get_uint32(pc->json_packet, "%(name)s", &tmp);
   real_packet->%(name)s = (float)(tmp) / %(float_factor)d.0;
 }'''%self.__dict__
 
         if self.dataio_type=="bitvector":
-            return "DIO_BV_GET(&din, real_packet->%(name)s);"%self.__dict__
+            return "/* DIO_BV_GET(pc->json_packet, real_packet->%(name)s); */"%self.__dict__
         if self.dataio_type in ["string","bit_string","city_map"] and \
            self.is_array!=2:
-            return "dio_get_%(dataio_type)s(&din, real_packet->%(name)s, sizeof(real_packet->%(name)s));"%self.__dict__
+            return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", real_packet->%(name)s, sizeof(real_packet->%(name)s));"%self.__dict__
         if self.is_struct and self.is_array==0:
-            return "dio_get_%(dataio_type)s(&din, &real_packet->%(name)s);"%self.__dict__
+            return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s);"%self.__dict__
         if self.dataio_type in ["tech_list","unit_list","building_list"]:
-            return "dio_get_%(dataio_type)s(&din, real_packet->%(name)s);"%self.__dict__
+            return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", real_packet->%(name)s);"%self.__dict__
         if not self.is_array:
             if self.struct_type=="bool":
-                return "dio_get_%(dataio_type)s(&din, &real_packet->%(name)s);"%self.__dict__
+                return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s);"%self.__dict__
             return '''{
   int readin;
 
-  dio_get_%(dataio_type)s(&din, &readin);
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", &readin);
   real_packet->%(name)s = readin;
 }'''%self.__dict__
 
         if self.is_struct:
             if self.is_array==2:
-                c="dio_get_%(dataio_type)s(&din, &real_packet->%(name)s[i][j]);"%self.__dict__
+                c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s[i][j]);"%self.__dict__
             else:
-                c="dio_get_%(dataio_type)s(&din, &real_packet->%(name)s[i]);"%self.__dict__
+                c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s[i]);"%self.__dict__
         elif self.dataio_type=="string":
-            c="dio_get_%(dataio_type)s(&din, real_packet->%(name)s[i], sizeof(real_packet->%(name)s[i]));"%self.__dict__
+            c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", real_packet->%(name)s[i], sizeof(real_packet->%(name)s[i]));"%self.__dict__
         elif self.struct_type=="float":
             if self.is_array==2:
                 c='''int tmp;
 
-    dio_get_uint32(&din, &tmp);
+    dio_get_uint32(pc->json_packet, "%(name)s", &tmp);
     real_packet->%(name)s[i][j] = (float)(tmp) / %(float_factor)d.0;'''%self.__dict__
             else:
                 c='''int tmp;
 
-    dio_get_uint32(&din, &tmp);
+    dio_get_uint32(pc->json_packet, "%(name)s", &tmp);
     real_packet->%(name)s[i] = (float)(tmp) / %(float_factor)d.0;'''%self.__dict__
         elif self.struct_type=="bool":
             if self.is_array==2:
-                c="dio_get_%(dataio_type)s(&din, &real_packet->%(name)s[i][j]);"%self.__dict__
+                c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s[i][j]);"%self.__dict__
             else:
-                c="dio_get_%(dataio_type)s(&din, &real_packet->%(name)s[i]);"%self.__dict__
+                c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s[i]);"%self.__dict__
         elif self.is_array==2:
             c='''{
   int readin;
 
-  dio_get_%(dataio_type)s(&din, &readin);
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", &readin);
   real_packet->%(name)s[i][j] = readin;
 }'''%self.__dict__
         else:
             c='''{
   int readin;
 
-  dio_get_%(dataio_type)s(&din, &readin);
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", &readin);
   real_packet->%(name)s[i] = readin;
 }'''%self.__dict__
         if self.is_array==2:
@@ -521,8 +512,8 @@
             else:
                 extra=""
             if self.dataio_type=="memory":
-                return '''%(extra)s
-  dio_get_%(dataio_type)s(&din, real_packet->%(name)s, %(array_size_u)s);'''%self.get_dict(vars())
+                return ''' /* not supported yet. %(extra)s
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", real_packet->%(name)s, %(array_size_u)s);*/'''%self.get_dict(vars())
             elif self.is_array==2 and self.dataio_type!="string":
                 return '''
 {
@@ -548,7 +539,7 @@
 for (;;) {
   int i;
 
-  if (!dio_get_uint8(&din, &i)) {
+  if (!dio_get_uint8(pc->json_packet, "%(name)s", &i)) {
     break;
   }
   if (i == 255) {
@@ -854,7 +845,7 @@
 '''%self.get_dict(vars())
 
         body=body+'''
-  DIO_BV_PUT(&dout, fields);
+  DIO_BV_PUT(&dout, \"fields\", fields);
 '''
 
         for field in self.key_fields:
@@ -895,7 +886,7 @@
   struct %(packet_name)s *old;
   struct genhash **hash = pc->phs.received + type;
 '''
-            delta_body1="\n  DIO_BV_GET(&din, fields);\n"
+            delta_body1="\n  DIO_BV_GET(pc->json_packet, fields);\n"
             body1=""
             for field in self.key_fields:
                 body1=body1+prefix("  ",field.get_get())+"\n"
diff -Nurd -X.diff_ignore freeciv/common/packets.c freeciv/common/packets.c
--- freeciv/common/packets.c	2012-09-02 00:57:34.000000000 +0300
+++ freeciv/common/packets.c	2012-09-02 01:26:46.000000000 +0300
@@ -43,6 +43,8 @@
 #include "events.h"
 #include "map.h"
 
+#include <jansson.h>
+
 #include "packets.h"
 
 #ifdef USE_COMPRESSION
@@ -347,7 +349,7 @@
     enum packet_type type;
     int itype;
   } utype;
-  int typeb1, typeb2;
+  /*  int typeb1, typeb2; */
   struct data_in din;
 #ifdef USE_COMPRESSION
   bool compressed_packet = FALSE;
@@ -366,7 +368,7 @@
   }
 
   dio_input_init(&din, pc->buffer->data, pc->buffer->ndata);
-  dio_get_uint16(&din, &len_read);
+  dio_get_uint16_old(&din, &len_read);
 
   /* The non-compressed case */
   whole_packet_len = len_read;
@@ -472,6 +474,7 @@
     return NULL;
   }
 
+#if 0
   /* Instead of one dio_get_uint16() we do twice dio_get_uint8().
    * Older (<= 2.4) versions had 8bit type field, and we detect
    * here if this is initial PACKET_SERVER_JOIN_REQ from such a client. */
@@ -485,6 +488,36 @@
   }
 
   utype.type = utype.itype;
+#else
+
+  /* Parse JSON packet. */
+  json_error_t error;
+
+  dio_get_uint16_old(&din, &utype.itype);
+
+  dio_get_string_old(&din, (char*)pc->buffer->data, pc->buffer->ndata);
+
+  pc->json_packet = json_loadb((char*)pc->buffer->data, whole_packet_len, 0, &error);
+
+  memmove(pc->buffer->data, pc->buffer->data, pc->buffer->ndata);
+  pc->buffer->ndata = 0;
+
+  if (!pc->json_packet) {
+    log_error("ERROR: Unable to parse packet: %s", pc->buffer->data);
+    return NULL;
+  }
+
+  json_t *pint = json_object_get(pc->json_packet, "type");
+
+  if (!pint) {
+    log_error("ERROR: Unable to get packet type.");
+    return NULL;
+  } 
+
+  json_int_t packet_type = json_integer_value(pint);
+  utype.type = packet_type;
+
+#endif
 
   log_packet("got packet type=(%s)%d len=%d from %s",
              packet_name(utype.type), utype.itype, whole_packet_len,
@@ -551,9 +584,9 @@
 {
   struct data_in din;
   int len;
-
+ 
   dio_input_init(&din, buffer->data, buffer->ndata);
-  dio_get_uint16(&din, &len);
+  dio_get_uint16_old(&din, &len);
   memmove(buffer->data, buffer->data + len, buffer->ndata - len);
   buffer->ndata -= len;
   log_debug("remove_packet_from_buffer: remove %d; remaining %d",
@@ -563,6 +596,7 @@
 /**************************************************************************
   Sanity check packet
 **************************************************************************/
+#if 0
 void check_packet(struct data_in *din, struct connection *pc)
 {
   size_t rem = dio_input_remaining(din);
@@ -601,6 +635,7 @@
     }
   }
 }
+#endif
 
 /**************************************************************************
  Updates pplayer->attribute_block according to the given packet.
diff -Nurd -X.diff_ignore freeciv/common/packets.def freeciv/common/packets.def
--- freeciv/common/packets.def	2012-09-02 01:13:25.000000000 +0300
+++ freeciv/common/packets.def	2012-09-02 01:26:46.000000000 +0300
@@ -194,9 +194,9 @@
 type MEMORY             = memory(unsigned char)
 type REQUIREMENT        = requirement(struct requirement)
 type STRING             = string(char)
-type TECH_LIST          = tech_list(int)
-type UNIT_LIST          = unit_list(int)
-type BUILDING_LIST      = building_list(int)
+# type TECH_LIST          = tech_list(int)
+# type UNIT_LIST          = unit_list(int)
+# type BUILDING_LIST      = building_list(int)
 type WORKLIST           = worklist(struct worklist)
 
 # typedefs for enums
@@ -765,7 +765,7 @@
   UINT32 diplstate_id; key
   PLAYER plr1;
   PLAYER plr2;
-  UINT8 type;
+  UINT32 ds_type;
   UINT16 turns_left;
   UINT8 has_reason_to_cancel;
   UINT16 contact_turns_left;
@@ -1322,9 +1322,9 @@
   UINT8 groups[MAX_NUM_NATION_GROUPS:ngroups];
 
   GOVERNMENT init_government_id;
-  TECH_LIST init_techs[MAX_NUM_TECH_LIST];
-  UNIT_LIST init_units[MAX_NUM_UNIT_LIST];
-  BUILDING_LIST init_buildings[MAX_NUM_BUILDING_LIST];
+  # TECH_LIST init_techs[MAX_NUM_TECH_LIST];
+  # UNIT_LIST init_units[MAX_NUM_UNIT_LIST];
+  # BUILDING_LIST init_buildings[MAX_NUM_BUILDING_LIST];
 end
 
 PACKET_RULESET_CITY = 149; sc, lsend
diff -Nurd -X.diff_ignore freeciv/common/packets.h freeciv/common/packets.h
--- freeciv/common/packets.h	2012-09-02 00:54:26.000000000 +0300
+++ freeciv/common/packets.h	2012-09-02 01:26:46.000000000 +0300
@@ -33,6 +33,7 @@
 #include "team.h"
 #include "unittype.h"
 #include "worklist.h"
+#include <jansson.h>
 
 
 #define MAX_LEN_USERNAME        10        /* see below */
@@ -106,44 +107,40 @@
 
 #define SEND_PACKET_START(type) \
   unsigned char buffer[MAX_LEN_PACKET]; \
+  char *json_buffer = NULL; \
   struct data_out dout; \
+  dout.json = json_object(); \
   \
   dio_output_init(&dout, buffer, sizeof(buffer)); \
-  dio_put_uint16(&dout, 0); \
-  dio_put_uint16(&dout, type); \
+  dio_put_uint16_old(&dout, 0); \
+  dio_put_uint16_old(&dout, type); \
+  dio_put_uint8(&dout, "pid", type); \
   PACKET_TYPE_SANITY(type)
 
 #define SEND_PACKET_END \
   { \
+    json_buffer = json_dumps(dout.json, JSON_COMPACT | JSON_ENSURE_ASCII); \
+    if (json_buffer) { \
+      dio_put_string_old(&dout, json_buffer);	  \
+    } \
     size_t size = dio_output_used(&dout); \
     \
     dio_output_rewind(&dout); \
-    dio_put_uint16(&dout, size); \
+    dio_put_uint16_old(&dout, size); \
+    free(json_buffer); \
+    json_decref(dout.json); \
     fc_assert(!dout.too_short); \
     return send_packet_data(pc, buffer, size); \
   }
 
 #define RECEIVE_PACKET_START(type, result) \
-  struct data_in din; \
-  struct type *result = fc_malloc(sizeof(*result)); \
-  \
-  dio_input_init(&din, pc->buffer->data, 2); \
-  { \
-    int size; \
-  \
-    dio_get_uint16(&din, &size); \
-    dio_input_init(&din, pc->buffer->data, MIN(size, pc->buffer->ndata)); \
-  } \
-  dio_get_uint16(&din, NULL); \
-  dio_get_uint16(&din, NULL);
+  struct type *result = fc_malloc(sizeof(*result));
 
 #define RECEIVE_PACKET_END(result) \
-  check_packet(&din, pc); \
-  remove_packet_from_buffer(pc->buffer); \
+  json_decref(pc->json_packet); \
   return result;
 
 int send_packet_data(struct connection *pc, unsigned char *data, int len);
-void check_packet(struct data_in *din, struct connection *pc);
 
 /* Utilities to exchange strings and string vectors. */
 #define PACKET_STRVEC_SEPARATOR '\3'
diff -Nurd -X.diff_ignore freeciv/configure.ac freeciv/configure.ac
--- freeciv/configure.ac	2012-09-02 01:12:23.000000000 +0300
+++ freeciv/configure.ac	2012-09-02 01:26:46.000000000 +0300
@@ -1012,7 +1012,7 @@
 
 dnl Checks for additional server libraries:
 if test "x$server" = "xyes"; then
-    SERVER_LIBS="-lm ${SERVER_LIBS} -lssl"
+    SERVER_LIBS="-lm ${SERVER_LIBS} -lssl -ljansson"
 
     dnl Some systems (e.g., BeOS) need this lib
     AC_CHECK_LIB(bind, gethostbyaddr, SERVER_LIBS="-lbind $SERVER_LIBS")
diff -Nurd -X.diff_ignore freeciv/server/handchat.c freeciv/server/handchat.c
--- freeciv/server/handchat.c	2012-09-02 00:51:12.000000000 +0300
+++ freeciv/server/handchat.c	2012-09-02 01:26:46.000000000 +0300
@@ -19,7 +19,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#include <glib.h>
+
 /* utility */
+#include "fciconv.h"
 #include "fcintl.h"
 #include "log.h"
 #include "shared.h"
@@ -319,19 +322,32 @@
 void handle_chat_msg_req(struct connection *pconn, const char *message)
 {
   char real_message[MAX_LEN_MSG], *cp;
+  char raw_message[MAX_LEN_MSG];
+  char* unesc_message;
   bool double_colon;
 
-  sz_strlcpy(real_message, message);
+  sz_strlcpy(raw_message, message);
 
   /* This loop to prevent players from sending multiple lines which can
    * be abused */
-  for (cp = real_message; *cp != '\0'; cp++) {
-    if (*cp == '\n' || *cp == '\r') {
+  for (cp = raw_message; *cp != '\0'; cp++) {
+    if (*cp == '\n' || *cp == '\r' || *cp == '<' || *cp == '>' || *cp == '"' || *cp == '\'') {
       *cp = '\0';
       break;
     }
   }
 
+  unesc_message = g_uri_unescape_string(raw_message, NULL);
+  if (unesc_message) {
+      convert_string(unesc_message,
+ 	  	       "latin1",
+		       "UTF-8",
+		       (char*)real_message, sizeof(real_message));
+      g_free(unesc_message);
+  } else {
+    return;
+  }
+
   /* Server commands are prefixed with '/', which is an obvious
      but confusing choice: even before this feature existed,
      novice players were trying /who, /nick etc.
diff -Nurd -X.diff_ignore freeciv/server/plrhand.c freeciv/server/plrhand.c
--- freeciv/server/plrhand.c	2012-09-02 01:13:15.000000000 +0300
+++ freeciv/server/plrhand.c	2012-09-02 01:26:46.000000000 +0300
@@ -1054,12 +1054,12 @@
       || (receiver
           && player_diplstate_get(receiver, plr1)->contact_turns_left > 0)
       || (receiver && receiver == plr2)) {
-    packet_ds->type                 = ds->type;
+    packet_ds->ds_type              = ds->type;
     packet_ds->turns_left           = ds->turns_left;
     packet_ds->has_reason_to_cancel = ds->has_reason_to_cancel;
     packet_ds->contact_turns_left   = ds->contact_turns_left;
   } else {
-    packet_ds->type                 = DS_WAR;
+    packet_ds->ds_type              = DS_WAR;
     packet_ds->turns_left           = 0;
     packet_ds->has_reason_to_cancel = 0;
     packet_ds->contact_turns_left   = 0;
diff -Nurd -X.diff_ignore freeciv/server/ruleset.c freeciv/server/ruleset.c
--- freeciv/server/ruleset.c	2012-09-02 01:13:25.000000000 +0300
+++ freeciv/server/ruleset.c	2012-09-02 01:26:46.000000000 +0300
@@ -4428,6 +4428,8 @@
     packet.ngroups = i;
 
     packet.init_government_id = government_number(n->init_government);
+
+#if 0
     fc_assert(ARRAY_SIZE(packet.init_techs) == ARRAY_SIZE(n->init_techs));
     for (i = 0; i < MAX_NUM_TECH_LIST; i++) {
       packet.init_techs[i] = n->init_techs[i];
@@ -4443,6 +4445,7 @@
       /* Impr_type_id to int */
       packet.init_buildings[i] = n->init_buildings[i];
     }
+#endif
 
     lsend_packet_ruleset_nation(dest, &packet);
   } nations_iterate_end;
diff -Nurd -X.diff_ignore freeciv/server/sernet.c freeciv/server/sernet.c
--- freeciv/server/sernet.c	2012-09-02 00:51:12.000000000 +0300
+++ freeciv/server/sernet.c	2012-09-02 01:26:46.000000000 +0300
@@ -136,7 +136,7 @@
 static void send_ping_times_to_all(void);
 
 static void get_lanserver_announcement(void);
-static void send_lanserver_response(void);
+/* static void send_lanserver_response(void); */
 
 static bool no_input = FALSE;
 
@@ -1364,9 +1364,6 @@
 ********************************************************************/
 static void get_lanserver_announcement(void)
 {
-  char msgbuf[128];
-  struct data_in din;
-  int type;
   fd_set readfs, exceptfs;
   struct timeval tv;
 
@@ -1391,7 +1388,7 @@
      * Generally we just want to run select again. */
   }
 
-  if (FD_ISSET(socklan, &readfs)) {
+  /*if (FD_ISSET(socklan, &readfs)) {
     if (0 < recvfrom(socklan, msgbuf, sizeof(msgbuf), 0, NULL, NULL)) {
       dio_input_init(&din, msgbuf, 1);
       dio_get_uint8(&din, &type);
@@ -1402,13 +1399,14 @@
         log_debug("Received invalid request for server LAN announcement.");
       }
     }
-  }
+  }*/
 }
 
 /********************************************************************
   This function broadcasts an UDP packet to clients with
   that requests information about the server state.
 ********************************************************************/
+#if 0
 static void send_lanserver_response(void)
 {
 #ifndef HAVE_WINSOCK
@@ -1501,14 +1499,14 @@
               srvarg.port );
 
   dio_output_init(&dout, buffer, sizeof(buffer));
-  dio_put_uint8(&dout, SERVER_LAN_VERSION);
-  dio_put_string(&dout, hostname);
-  dio_put_string(&dout, port);
-  dio_put_string(&dout, version);
-  dio_put_string(&dout, status);
-  dio_put_string(&dout, players);
-  dio_put_string(&dout, humans);
-  dio_put_string(&dout, get_meta_message_string());
+  dio_put_uint8(&dout, "ver", SERVER_LAN_VERSION);
+  dio_put_string(&dout, "host", hostname);
+  dio_put_string(&dout, "port", port);
+  dio_put_string(&dout, "version", version);
+  dio_put_string(&dout, "status", status);
+  dio_put_string(&dout, "players", players);
+  dio_put_string(&dout, "humans", humans);
+  dio_put_string(&dout, "msg", get_meta_message_string());
   size = dio_output_used(&dout);
 
   /* Sending packet to client with the information gathered above. */
@@ -1521,3 +1519,4 @@
 
   fc_closesocket(socksend);
 }
+#endif /* 0 */
diff -Nurd -X.diff_ignore freeciv/server/srv_main.c freeciv/server/srv_main.c
--- freeciv/server/srv_main.c	2012-09-02 01:12:31.000000000 +0300
+++ freeciv/server/srv_main.c	2012-09-02 01:26:46.000000000 +0300
@@ -1508,21 +1508,21 @@
                conn_description(pconn));
 
     dio_output_init(&dout, buffer, sizeof(buffer));
-    dio_put_uint16(&dout, 0);
+    dio_put_uint16(&dout, "msg", 0);
 
     /* 1 == PACKET_LOGIN_REPLY in the old client */
-    dio_put_uint8(&dout, 1);
+    dio_put_uint8(&dout, "msg", 1);
 
-    dio_put_bool32(&dout, FALSE);
-    dio_put_string(&dout, _("Your client is too old. To use this server, "
+    dio_put_bool32(&dout, "msg", FALSE);
+    dio_put_string(&dout, "msg", _("Your client is too old. To use this server, "
 			    "please upgrade your client to a "
 			    "Freeciv 2.2 or later."));
-    dio_put_string(&dout, "");
+    dio_put_string(&dout, "msg", "");
 
     {
       size_t size = dio_output_used(&dout);
       dio_output_rewind(&dout);
-      dio_put_uint16(&dout, size);
+      dio_put_uint16(&dout, "size",  size);
 
       /* 
        * Use send_connection_data instead of send_packet_data to avoid
