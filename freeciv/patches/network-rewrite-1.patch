diff -Nurd -X.diff_ignore freeciv/common/connection.h freeciv/common/connection.h
--- freeciv/common/connection.h	2014-09-07 06:49:02.018566169 +0300
+++ freeciv/common/connection.h	2014-09-07 06:52:34.646091880 +0300
@@ -26,6 +26,10 @@
 #include <sys/time.h>
 #endif
 
+#ifdef JSON_CONNECTION
+#include <jansson.h>
+#endif  /* JSON_CONNECTION */
+
 #ifndef JSON_CONNECTION
 #define USE_COMPRESSION
 #endif  /* JSON_CONNECTION */
@@ -48,7 +52,7 @@
 struct conn_pattern_list;
 
 /* Used in the network protocol. */
-#define MAX_LEN_PACKET   4096
+#define MAX_LEN_PACKET    16384
 #define MAX_LEN_CAPSTR    512
 #define MAX_LEN_PASSWORD  512 /* do not change this under any circumstances */
 
@@ -152,6 +156,7 @@
   struct socket_packet_buffer *buffer;
   struct socket_packet_buffer *send_buffer;
   struct timer *last_write;
+  json_t *json_packet;
 
   double ping_time;
   
diff -Nurd -X.diff_ignore freeciv/common/dataio.c freeciv/common/dataio.c
--- freeciv/common/dataio.c	2014-09-07 06:49:02.034566133 +0300
+++ freeciv/common/dataio.c	2014-09-07 06:50:56.182311427 +0300
@@ -222,9 +222,17 @@
 }
 
 /**************************************************************************
+  Insert 8 bit value with json.
+**************************************************************************/
+void dio_put_uint8(struct data_out *dout, char *key, int value)
+{
+  json_object_set_new(dout->json, key, json_integer(value));
+}
+
+/**************************************************************************
   Insert value using 8 bits. May overflow.
 **************************************************************************/
-void dio_put_uint8(struct data_out *dout, int value)
+void dio_put_uint8_old(struct data_out *dout, int value)
 {
   if (value < 0x00 || 0xff < value) {
     log_error("Trying to put %d into 8 bits", value);
@@ -242,7 +250,7 @@
 /**************************************************************************
   Insert value using 16 bits. May overflow.
 **************************************************************************/
-void dio_put_uint16(struct data_out *dout, int value)
+void dio_put_uint16_old(struct data_out *dout, int value)
 {
   if (value < 0x0000 || 0xffff < value) {
     log_error("Trying to put %d into 16 bits", value);
@@ -260,6 +268,15 @@
 /**************************************************************************
   Insert value using 32 bits. May overflow.
 **************************************************************************/
+void dio_put_uint16(struct data_out *dout, char *key, int value)
+{
+  json_object_set_new(dout->json, key, json_integer(value));
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+#if 0
 void dio_put_uint32(struct data_out *dout, int value)
 {
   if (sizeof(value) > 4 && (value < 0x00000000 || 0xffffffff < value)) {
@@ -278,26 +295,26 @@
 /**************************************************************************
   Insert value using 'size' bits. May overflow.
 **************************************************************************/
-void dio_put_type(struct data_out *dout, enum data_type type, int value)
+void dio_put_type(struct data_out *dout, enum data_type type, char *key, int value)
 {
   switch (type) {
   case DIOT_UINT8:
-    dio_put_uint8(dout, value);
+    dio_put_uint8(dout, key, value);
     return;
   case DIOT_UINT16:
-    dio_put_uint16(dout, value);
+    dio_put_uint16(dout, key, value);
     return;
   case DIOT_UINT32:
-    dio_put_uint32(dout, value);
+    dio_put_uint32(dout, key, value);
     return;
   case DIOT_SINT8:
-    dio_put_sint8(dout, value);
+    dio_put_sint8(dout, key, value);
     return;
   case DIOT_SINT16:
-    dio_put_sint16(dout, value);
+    dio_put_sint16(dout, key, value);
     return;
   case DIOT_SINT32:
-    dio_put_sint32(dout, value);
+    dio_put_sint32(dout, key, value);
     return;
   case DIOT_LAST:
     break;
@@ -416,11 +433,12 @@
     }
   }
 }
+#endif
 
 /**************************************************************************
   Insert block directly from memory.
 **************************************************************************/
-void dio_put_memory(struct data_out *dout, const void *value, size_t size)
+void dio_put_memory_old(struct data_out *dout, const void *value, size_t size)
 {
   if (enough_space(dout, size)) {
     memcpy(ADD_TO_POINTER(dout->dest, dout->current), value, size);
@@ -431,18 +449,18 @@
 /**************************************************************************
   Insert NULL-terminated string. Conversion callback is used if set.
 **************************************************************************/
-void dio_put_string(struct data_out *dout, const char *value)
+void dio_put_string_old(struct data_out *dout, const char *value)
 {
   if (put_conv_callback) {
     size_t length;
     char *buffer;
 
     if ((buffer = (*put_conv_callback) (value, &length))) {
-      dio_put_memory(dout, buffer, length + 1);
+      dio_put_memory_old(dout, buffer, length + 1);
       free(buffer);
     }
   } else {
-    dio_put_memory(dout, value, strlen(value) + 1);
+    dio_put_memory_old(dout, value, strlen(value) + 1);
   }
 }
 
@@ -450,6 +468,7 @@
   Insert tech numbers from value array as 8 bit values until there is value
   A_LAST or MAX_NUM_TECH_LIST tech numbers have been inserted.
 **************************************************************************/
+#if 0
 void dio_put_tech_list(struct data_out *dout, const int *value)
 {
   int i;
@@ -511,10 +530,105 @@
   }
 }
 
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_worklist(struct data_out *dout, char *key, const struct worklist *pwl)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_uint8(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_uint32(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_sint8(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_sint16(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_sint32(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_bool8(struct data_out *dout, char *key, bool *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, values[i] ? json_true() : json_false());
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
 /**************************************************************************
  Receive uint8 value to dest.
 **************************************************************************/
-bool dio_get_uint8(struct data_in *din, int *dest)
+bool dio_get_uint8_old(struct data_in *din, int *dest)
 {
   uint8_t x;
 
@@ -533,9 +647,90 @@
 }
 
 /**************************************************************************
+ Receive uint8 value to dest with json.
+**************************************************************************/
+bool dio_get_uint8(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get uint8 with key: %s", key);
+    return FALSE;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get unit8 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+ Receive uint16 value to dest with json.
+**************************************************************************/
+bool dio_get_uint16(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get uint16 with key: %s", key);
+    return FALSE;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get unit16 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+bool dio_get_uint32(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get uint32 with key: %s", key);
+    return FALSE;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get unit32 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+bool dio_get_tech_list(json_t *json_packet, char *key, int *dest)
+{
+  /* TODO: implement */
+  return TRUE;
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+bool dio_get_worklist(json_t *json_packet, char *key, struct worklist *pwl)
+{
+  /* TODO: implement */
+  return TRUE;
+}
+
+/**************************************************************************
  Receive uint16 value to dest.
 **************************************************************************/
-bool dio_get_uint16(struct data_in *din, int *dest)
+bool dio_get_uint16_old(struct data_in *din, int *dest)
 {
   uint16_t x;
 
@@ -556,6 +751,7 @@
 /**************************************************************************
  Receive uint32 value to dest.
 **************************************************************************/
+#if 0
 bool dio_get_uint32(struct data_in *din, int *dest)
 {
   uint32_t x;
@@ -727,11 +923,12 @@
   din->current += dest_size;
   return TRUE;
 }
+#endif
 
 /**************************************************************************
   Take string. Conversion callback is used.
 **************************************************************************/
-bool dio_get_string(struct data_in *din, char *dest, size_t max_dest_size)
+bool dio_get_string_old(struct data_in *din, char *dest, size_t max_dest_size)
 {
   char *c;
   size_t offset, remaining;
@@ -769,6 +966,7 @@
   Take tech numbers until A_LAST encountered, or MAX_NUM_TECH_LIST techs
   retrieved.
 **************************************************************************/
+#if 0
 bool dio_get_tech_list(struct data_in *din, int *dest)
 {
   int i;
@@ -899,10 +1097,31 @@
 
   return TRUE;
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_uint8_vec8(json_t *json_packet, char *key, int **values, int stop_value)
+{
+  /* TODO: implement */
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_uint16_vec8(json_t *json_packet, char *key, int **values,
+                         int stop_value)
+{
+  /* TODO: implement */
+  return TRUE;
+}
 
 /**************************************************************************
  Receive vector of uint6 values.
 **************************************************************************/
+#if 0
 bool dio_get_uint16_vec8(struct data_in *din, int **values, int stop_value)
 {
   int count, inx;
@@ -949,10 +1168,21 @@
 
   return TRUE;
 }
+#endif
+
+/**************************************************************************
+  ..
+**************************************************************************/
+bool dio_get_requirement(json_t *json_packet, char *key, struct requirement *preq)
+{
+  /* TODO: implement */
+  return TRUE;
+}
 
 /**************************************************************************
   Serialize a requirement.
 **************************************************************************/
+#if 0
 void dio_put_requirement(struct data_out *dout, const struct requirement *preq)
 {
   int type, range, value;
@@ -966,3 +1196,233 @@
   dio_put_bool8(dout, survives);
   dio_put_bool8(dout, present);
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_uint32(struct data_out *dout, char *key, int value)
+{
+  json_object_set_new(dout->json, key, json_integer(value));
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_bool8(struct data_out *dout, char *key, bool value)
+{
+  json_object_set_new(dout->json, key, value ? json_true() : json_false());
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_bool32(struct data_out *dout, char *key, bool value)
+{
+  json_object_set_new(dout->json, key, value ? json_true() : json_false());
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_float(struct data_out *dout, char *key, float value, int float_factor)
+{
+  json_object_set_new(dout->json, key, json_real(value));
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_uint8_vec8(struct data_out *dout, char *key, int *values, int stop_value)
+{
+  /* TODO: implement. */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_uint16_vec8(struct data_out *dout, char *key, int *values,
+                         int stop_value)
+{
+  /* TODO: implement. */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_memory(struct data_out *dout, char *key, const void *value, size_t size)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_string(struct data_out *dout, char *key, const char *value)
+{
+  json_object_set_new(dout->json, key, json_string(value));
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_string_array(struct data_out *dout, char *key, 
+		          const char *value, int size)
+{
+  int i;
+
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    if (value != NULL) {
+      json_array_append_new(array, json_string(value + i));
+    }
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_tech_list(struct data_out *dout, char *key, const int *value)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+  ..
+**************************************************************************/
+void dio_put_requirement(struct data_out *dout, char *key, const struct requirement *preq, int size)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_bool8(json_t *json_packet, char *key, bool * dest)
+{
+  json_t *pbool = json_object_get(json_packet, key);
+
+  if (!pbool) {
+    log_error("ERROR: Unable to get bool8 with key: %s", key);
+    return FALSE;
+  } 
+  *dest = json_is_true(pbool);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get bool with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_bool32(json_t *json_packet, char *key, bool *dest)
+{
+  json_t *pbool = json_object_get(json_packet, key);
+
+  if (!pbool) {
+    log_error("ERROR: Unable to get bool32 with key: %s", key);
+    return FALSE;
+  }
+  *dest = json_is_true(pbool);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get bool32 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+  ...
+**************************************************************************/
+bool dio_get_float(json_t *json_packet, char *key, float *dest, int float_factor)
+{
+  json_t *preal = json_object_get(json_packet, key);
+
+  if (!preal) {
+    log_error("ERROR: Unable to get real with key: %s", key);
+    return FALSE;
+  }
+  *dest = json_real_value(preal);
+
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_sint8(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get sint8 with key: %s", key);
+    return FALSE;
+  }
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get sint8 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_sint16(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get sint16 with key: %s", key);
+    return FALSE;
+  }
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get sint16 with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_memory(json_t *json_packet, char *key, void *dest, size_t dest_size)
+{
+  /* TODO: implement */ 
+  return TRUE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+bool dio_get_string(json_t *json_packet, char *key, char *dest, size_t max_dest_size)
+{
+  json_t *pstring = json_object_get(json_packet, key);
+
+  if (!pstring) {
+    log_error("ERROR: Unable to get string with key: %s", key);
+    return FALSE;
+  }
+  const char *result_str = json_string_value(pstring);
+
+  if (dest && !(*get_conv_callback) (dest, max_dest_size, result_str, strlen(result_str))) {
+    log_error("ERROR: Unable to get string with key: %s", key);
+    return FALSE;
+  }
+
+  return TRUE;
+}
diff -Nurd -X.diff_ignore freeciv/common/dataio.h freeciv/common/dataio.h
--- freeciv/common/dataio.h	2014-09-07 06:49:02.018566169 +0300
+++ freeciv/common/dataio.h	2014-09-07 06:50:56.182311427 +0300
@@ -20,6 +20,8 @@
 #include "bitvector.h"
 #include "support.h"            /* bool type */
 
+#include <jansson.h>
+
 struct worklist;
 struct requirement;
 
@@ -30,6 +32,7 @@
 
 struct data_out {
   void *dest;
+  json_t *json;
   size_t dest_size, used, current;
   bool too_short;		/* set to 1 if try to read past end */
 };
@@ -72,6 +75,8 @@
 bool dio_get_type(struct data_in *din, enum data_type type, int *dest)
     fc__attribute((nonnull (3)));
 
+#if 0
+
 bool dio_get_uint8(struct data_in *din, int *dest)
     fc__attribute((nonnull (2)));
 bool dio_get_uint16(struct data_in *din, int *dest)
@@ -118,7 +123,44 @@
 
 #define DIO_GET(f, d, k, ...) dio_get_##f(d, ## __VA_ARGS__)
 
+#else
+
+bool dio_get_uint8(json_t *json_packet, char *key, int *dest);
+bool dio_get_uint16(json_t *json_packet, char *key, int *dest);
+bool dio_get_uint32(json_t *json_packet, char *key, int *dest);
+
+bool dio_get_uint16_old(struct data_in *din, int *dest);
+bool dio_get_uint8_old(struct data_in *din, int *dest);
+bool dio_get_sint8(json_t *json_packet, char *key, int *dest);
+bool dio_get_sint16(json_t *json_packet, char *key, int *dest);
+#define dio_get_sint32(d,v,x) dio_get_uint32(d,v,x)
+
+
+bool dio_get_bool8(json_t *json_packet, char *key, bool *dest);
+bool dio_get_bool32(json_t *json_packet, char *key, bool *dest);
+bool dio_get_float(json_t *json_packet, char *key, float *dest, int float_factor);
+bool dio_get_memory(json_t *json_packet, char *key, void *dest, size_t dest_size);
+bool dio_get_string(json_t *json_packet, char *key, char *dest, size_t max_dest_size);
+bool dio_get_string_old(struct data_in *din, char *dest, size_t max_dest_size);
+bool dio_get_bit_string(json_t *json_packet, char *key, char *dest,
+ 			size_t max_dest_size);
+bool dio_get_tech_list(json_t *json_packet, char *key, int *dest);
+bool dio_get_worklist(json_t *json_packet, char *key, struct worklist *pwl);
+bool dio_get_requirement(json_t *json_packet, char *key, struct requirement *preq);
+
+bool dio_get_uint8_vec8(json_t *json_packet, char *key, int **values, int stop_value);
+bool dio_get_uint16_vec8(json_t *json_packet, char *key, int **values, int stop_value);
+
+/* Should be a function but we need some macro magic. */
+#define DIO_BV_GET(pdin, bv)                          \
+  dio_get_memory((pdin), (bv).vec, sizeof((bv).vec))
+
+#define DIO_GET(f, d, k, ...) dio_get_##f(pc->json_packet, k, ## __VA_ARGS__)
+
+#endif
+
 /* puts */
+#if 0
 void dio_put_type(struct data_out *dout, enum data_type type, int value);
 
 void dio_put_uint8(struct data_out *dout, int value);
@@ -151,6 +193,53 @@
 
 #define DIO_PUT(f, d, k, ...) dio_put_##f(d, ## __VA_ARGS__)
 
+#else
+
+void dio_put_type(struct data_out *dout, enum data_type type, char *key, int value);
+
+void dio_put_uint8(struct data_out *dout, char *key, int value);
+void dio_put_uint8_old(struct data_out *dout, int value);
+void dio_put_uint16(struct data_out *dout, char *key, int value);
+void dio_put_uint32(struct data_out *dout, char *key, int value);
+void dio_put_uint16_old(struct data_out *dout, int value);
+
+void dio_put_array_uint8(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_uint32(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint8(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint16(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint32(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_bool8(struct data_out *dout, char *key, bool *values, int size);
+
+#define dio_put_sint8(d,k,v) dio_put_uint8(d,k,v)
+#define dio_put_sint16(d,k,v) dio_put_uint16(d,k,v)
+#define dio_put_sint32(d,k,v) dio_put_uint32(d,k,v)
+
+void dio_put_bool8(struct data_out *dout, char *key, bool value);
+void dio_put_bool32(struct data_out *dout, char *key, bool value);
+void dio_put_float(struct data_out *dout, char *key, float value, int float_factor);
+
+void dio_put_memory(struct data_out *dout, char *key, const void *value, size_t size);
+void dio_put_string(struct data_out *dout, char *key, const char *value);
+void dio_put_bit_string(struct data_out *dout, char *key, const char *value);
+void dio_put_city_map(struct data_out *dout, char *key, const char *value);
+void dio_put_tech_list(struct data_out *dout, char *key, const int *value);
+void dio_put_worklist(struct data_out *dout, char *key, const struct worklist *pwl);
+void dio_put_requirement(struct data_out *dout, char *key, const struct requirement *preq, int size);
+
+void dio_put_uint8_vec8(struct data_out *dout, char *key, int *values, int stop_value);
+void dio_put_uint16_vec8(struct data_out *dout, char *key, int *values, int stop_value);
+void dio_put_string_old(struct data_out *dout, const char *value);
+void dio_put_memory_old(struct data_out *dout, const void *value, size_t size);
+void dio_put_string_array(struct data_out *dout, char *key, const char *value, int size);
+
+/* Should be a function but we need some macro magic. */
+#define DIO_BV_PUT(pdout, type, bv) \
+  dio_put_memory((pdout), type, (bv).vec, sizeof((bv).vec))
+
+#define DIO_PUT(f, d, k, ...) dio_put_##f(d, k, ## __VA_ARGS__)
+
+#endif
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff -Nurd -X.diff_ignore freeciv/common/generate_packets.py freeciv/common/generate_packets.py
--- freeciv/common/generate_packets.py	2014-09-07 06:50:35.198358235 +0300
+++ freeciv/common/generate_packets.py	2014-09-07 06:50:56.182311427 +0300
@@ -249,7 +249,7 @@
         if self.is_array==1:
             tmp="real_packet->%(name)s[i] = %(name)s[i]"%self.__dict__
             return '''  {
-    int i;
+    int i; /* this is for put. */
 
     for (i = 0; i < %(array_size_u) s; i++) {
       %(tmp)s;
@@ -363,25 +363,20 @@
         if (self.dataio_type in arr_types and self.is_array==1) or \
            (self.dataio_type not in arr_types and self.is_array==0):
             return "  DIO_PUT(%(dataio_type)s, &dout, \"%(name)s\", real_packet->%(name)s);"%self.__dict__
-        if self.is_struct:
-            if self.is_array==2:
-                c="dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s[i][j]);"%self.__dict__
-            else:
-                c="dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s[i]);"%self.__dict__
         elif self.dataio_type=="string":
-            c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i]);"%self.__dict__
+            c="/* dio_put_%(dataio_type)s(&dout, \"%(name)s\", real_packet->%(name)s[i]);*/"%self.__dict__
             array_size_u=self.array_size1_u
+            self.__dict__["array_size_u"] = array_size_u
 
         elif self.struct_type=="float":
-            if self.is_array==2:
-                c="  dio_put_float(&dout, real_packet->%(name)s[i][j], %(float_factor)d);"%self.__dict__
-            else:
-                c="  dio_put_float(&dout, real_packet->%(name)s[i], %(float_factor)d);"%self.__dict__
+            c="/*  dio_put_float(&dout, \"%(name)s\", real_packet->%(name)s[i], %(float_factor)d); */"%self.__dict__
+        elif self.dataio_type=="requirement":
+            c="  dio_put_%(dataio_type)s(&dout, \"%(name)s\", (struct requirement *)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
         else:
             if self.is_array==2:
-                c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i][j]);"%self.__dict__
+                c="/* dio_put_%(dataio_type)s(&dout, \"%(name)s\", real_packet->%(name)s[i][j]); */"%self.__dict__
             else:
-                c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i]);"%self.__dict__
+                c="dio_put_array_%(dataio_type)s(&dout, \"%(name)s\", (void *)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
 
         if not self.diff:
             if self.is_array==2 and self.dataio_type!="string":
@@ -398,11 +393,7 @@
             else:
                 return '''
     {
-      int i;
-
-      for (i = 0; i < %(array_size_u)s; i++) {
         %(c)s
-      }
     } '''%self.get_dict(vars())
         else:
             return '''
@@ -445,9 +436,11 @@
   RECEIVE_PACKET_FIELD_ERROR(%(name)s);
 }'''%self.__dict__
         if self.dataio_type=="bitvector":
-            return '''if (!DIO_BV_GET(&din, real_packet->%(name)s)) {
+            return '''#if 0
+if (!DIO_BV_GET(&din, real_packet->%(name)s)) {
   RECEIVE_PACKET_FIELD_ERROR(%(name)s);
-}'''%self.__dict__
+}
+#endif'''%self.__dict__
         if self.dataio_type in ["string","bit_string","city_map"] and \
            self.is_array!=2:
             return '''if (!DIO_GET(%(dataio_type)s, &din, \"%(name)s\", real_packet->%(name)s, sizeof(real_packet->%(name)s))) {
@@ -542,10 +535,10 @@
             else:
                 extra=""
             if self.dataio_type=="memory":
-                return '''%(extra)s
-  if (!dio_get_%(dataio_type)s(&din, real_packet->%(name)s, %(array_size_u)s)){
+                return ''' /* not supported yet. %(extra)s
+  if (!dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", real_packet->%(name)s, %(array_size_u)s)){
     RECEIVE_PACKET_FIELD_ERROR(%(name)s);
-  }'''%self.get_dict(vars())
+  } */'''%self.get_dict(vars())
             elif self.is_array==2 and self.dataio_type!="string":
                 return '''
 {
@@ -921,7 +914,7 @@
   struct %(packet_name)s *old;
   struct genhash **hash = pc->phs.received + %(type)s;
 '''
-            delta_body1="\n  DIO_BV_GET(&din, fields);\n"
+            delta_body1="\n  DIO_BV_GET(pc->json_packet, fields);\n"
             body1=""
             for field in self.key_fields:
                 body1=body1+prefix("  ",field.get_get())+"\n"
diff -Nurd -X.diff_ignore freeciv/common/packets.c freeciv/common/packets.c
--- freeciv/common/packets.c	2014-09-07 06:49:02.022566160 +0300
+++ freeciv/common/packets.c	2014-09-07 06:50:56.182311427 +0300
@@ -43,6 +43,8 @@
 #include "events.h"
 #include "map.h"
 
+#include <jansson.h>
+
 #include "packets.h"
 
 #ifdef USE_COMPRESSION
@@ -378,7 +380,7 @@
   }
 
   dio_input_init(&din, pc->buffer->data, pc->buffer->ndata);
-  dio_get_type(&din, pc->packet_header.length, &len_read);
+  dio_get_uint16_old(&din, &len_read);
 
   /* The non-compressed case */
   whole_packet_len = len_read;
@@ -488,8 +490,35 @@
     return NULL;
   }
 
+#if 0
   dio_get_type(&din, pc->packet_header.type, &utype.itype);
   utype.type = utype.itype;
+#else
+
+  /* Parse JSON packet. */
+  json_error_t error;
+
+  pc->json_packet = json_loadb((char*)pc->buffer->data + 4, whole_packet_len, 0, &error);
+
+  memmove(pc->buffer->data, pc->buffer->data, pc->buffer->ndata);
+  pc->buffer->ndata = 0;
+
+  if (!pc->json_packet) {
+    log_error("ERROR: Unable to parse packet: %s", pc->buffer->data);
+    return NULL;
+  }
+
+  json_t *pint = json_object_get(pc->json_packet, "type");
+
+  if (!pint) {
+    log_error("ERROR: Unable to get packet type.");
+    return NULL;
+  } 
+
+  json_int_t packet_type = json_integer_value(pint);
+  utype.type = packet_type;
+
+#endif
 
   log_packet("got packet type=(%s)%d len=%d from %s",
              packet_name(utype.type), utype.itype, whole_packet_len,
@@ -561,9 +590,9 @@
 {
   struct data_in din;
   int len;
-
+ 
   dio_input_init(&din, buffer->data, buffer->ndata);
-  dio_get_uint16(&din, &len);
+  dio_get_uint16_old(&din, &len);
   memmove(buffer->data, buffer->data + len, buffer->ndata - len);
   buffer->ndata -= len;
   log_debug("remove_packet_from_buffer: remove %d; remaining %d",
@@ -624,6 +653,7 @@
 /**************************************************************************
   Sanity check packet
 **************************************************************************/
+#if 0
 bool packet_check(struct data_in *din, struct connection *pc)
 {
   size_t rem = dio_input_remaining(din);
@@ -644,6 +674,7 @@
   }
   return TRUE;
 }
+#endif
 
 /**************************************************************************
  Updates pplayer->attribute_block according to the given packet.
diff -Nurd -X.diff_ignore freeciv/common/packets.h freeciv/common/packets.h
--- freeciv/common/packets.h	2014-09-07 06:49:02.018566169 +0300
+++ freeciv/common/packets.h	2014-09-07 06:50:56.182311427 +0300
@@ -34,6 +34,7 @@
 #include "traderoutes.h"
 #include "unittype.h"
 #include "worklist.h"
+#include <jansson.h>
 
 
 /* Used in network protocol. */
@@ -113,42 +114,36 @@
 
 #define SEND_PACKET_START(packet_type) \
   unsigned char buffer[MAX_LEN_PACKET]; \
+  char *json_buffer = NULL; \
   struct data_out dout; \
+  dout.json = json_object(); \
   \
   dio_output_init(&dout, buffer, sizeof(buffer)); \
-  dio_put_type(&dout, pc->packet_header.length, 0); \
-  dio_put_type(&dout, pc->packet_header.type, packet_type);
+  dio_put_uint16_old(&dout, 0); \
+  dio_put_uint16_old(&dout, packet_type); \
+  dio_put_uint8(&dout, "pid", packet_type);
 
 #define SEND_PACKET_END(packet_type) \
   { \
+    json_buffer = json_dumps(dout.json, JSON_COMPACT | JSON_ENSURE_ASCII); \
+    if (json_buffer) { \
+      dio_put_string_old(&dout, json_buffer); \
+    } \
     size_t size = dio_output_used(&dout); \
     \
     dio_output_rewind(&dout); \
-    dio_put_type(&dout, pc->packet_header.length, size); \
+    dio_put_uint16_old(&dout, size); \
+    free(json_buffer); \
+    json_decref(dout.json); \
     fc_assert(!dout.too_short); \
     return send_packet_data(pc, buffer, size, packet_type); \
   }
 
 #define RECEIVE_PACKET_START(packet_type, result) \
-  struct data_in din; \
-  struct packet_type packet_buf, *result = &packet_buf; \
-  \
-  dio_input_init(&din, pc->buffer->data, \
-                 data_type_size(pc->packet_header.length)); \
-  { \
-    int size; \
-  \
-    dio_get_type(&din, pc->packet_header.length, &size); \
-    dio_input_init(&din, pc->buffer->data, MIN(size, pc->buffer->ndata)); \
-  } \
-  dio_input_skip(&din, (data_type_size(pc->packet_header.length) \
-                        + data_type_size(pc->packet_header.type)));
+  struct packet_type packet_buf, *result = &packet_buf;
 
 #define RECEIVE_PACKET_END(result) \
-  if (!packet_check(&din, pc)) { \
-    return NULL; \
-  } \
-  remove_packet_from_buffer(pc->buffer); \
+  json_decref(pc->json_packet); \
   result = fc_malloc(sizeof(*result)); \
   *result = packet_buf; \
   return result;
@@ -159,7 +154,6 @@
 
 int send_packet_data(struct connection *pc, unsigned char *data, int len,
                      enum packet_type packet_type);
-bool packet_check(struct data_in *din, struct connection *pc);
 
 /* Utilities to exchange strings and string vectors. */
 #define PACKET_STRVEC_SEPARATOR '\3'
diff -Nurd -X.diff_ignore freeciv/server/handchat.c freeciv/server/handchat.c
--- freeciv/server/handchat.c	2014-09-07 06:49:02.278565588 +0300
+++ freeciv/server/handchat.c	2014-09-07 06:50:56.182311427 +0300
@@ -19,7 +19,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#include <glib.h>
+
 /* utility */
+#include "fciconv.h"
 #include "fcintl.h"
 #include "log.h"
 #include "shared.h"
@@ -319,14 +322,17 @@
 void handle_chat_msg_req(struct connection *pconn, const char *message)
 {
   char real_message[MAX_LEN_MSG], *cp;
+  char* unesc_message;
   bool double_colon;
 
-  sz_strlcpy(real_message, message);
+  unesc_message = g_uri_unescape_string(message, NULL);
+  sz_strlcpy(real_message, unesc_message);
+  g_free(unesc_message);
 
   /* This loop to prevent players from sending multiple lines which can
    * be abused */
   for (cp = real_message; *cp != '\0'; cp++) {
-    if (*cp == '\n' || *cp == '\r') {
+    if (*cp == '\n' || *cp == '\r' || *cp == '<' || *cp == '>' || *cp == '"' || *cp == '\'') {
       *cp = '\0';
       break;
     }
diff -Nurd -X.diff_ignore freeciv/server/plrhand.c freeciv/server/plrhand.c
--- freeciv/server/plrhand.c	2014-09-07 06:49:02.230565695 +0300
+++ freeciv/server/plrhand.c	2014-09-07 06:50:56.186311418 +0300
@@ -1224,12 +1224,12 @@
       || (receiver
           && player_diplstate_get(receiver, plr1)->contact_turns_left > 0)
       || (receiver && receiver == plr2)) {
-    packet_ds->type                 = ds->type;
+    packet_ds->ds_type              = ds->type;
     packet_ds->turns_left           = ds->turns_left;
     packet_ds->has_reason_to_cancel = ds->has_reason_to_cancel;
     packet_ds->contact_turns_left   = ds->contact_turns_left;
   } else {
-    packet_ds->type                 = DS_WAR;
+    packet_ds->ds_type              = DS_WAR;
     packet_ds->turns_left           = 0;
     packet_ds->has_reason_to_cancel = 0;
     packet_ds->contact_turns_left   = 0;
diff -Nurd -X.diff_ignore freeciv/server/ruleset.c freeciv/server/ruleset.c
--- freeciv/server/ruleset.c	2014-09-07 06:50:35.198358235 +0300
+++ freeciv/server/ruleset.c	2014-09-07 06:50:56.186311418 +0300
@@ -6135,6 +6135,8 @@
     packet.ngroups = i;
 
     packet.init_government_id = government_number(n->init_government);
+
+#if 0
     fc_assert(ARRAY_SIZE(packet.init_techs) == ARRAY_SIZE(n->init_techs));
     for (i = 0; i < MAX_NUM_TECH_LIST; i++) {
       packet.init_techs[i] = n->init_techs[i];
@@ -6150,6 +6152,7 @@
       /* Impr_type_id to int */
       packet.init_buildings[i] = n->init_buildings[i];
     }
+#endif
 
     lsend_packet_ruleset_nation(dest, &packet);
   } nations_iterate_end;
diff -Nurd -X.diff_ignore freeciv/server/sernet.c freeciv/server/sernet.c
--- freeciv/server/sernet.c	2014-09-07 06:49:02.146565883 +0300
+++ freeciv/server/sernet.c	2014-09-07 06:50:56.198311391 +0300
@@ -129,7 +129,7 @@
 static void send_ping_times_to_all(void);
 
 static void get_lanserver_announcement(void);
-static void send_lanserver_response(void);
+/* static void send_lanserver_response(void); */
 
 static bool no_input = FALSE;
 
@@ -1401,9 +1401,6 @@
 ********************************************************************/
 static void get_lanserver_announcement(void)
 {
-  char msgbuf[128];
-  struct data_in din;
-  int type;
   fd_set readfs, exceptfs;
   struct timeval tv;
 
@@ -1432,7 +1429,7 @@
      * Generally we just want to run select again. */
   }
 
-  if (FD_ISSET(socklan, &readfs)) {
+  /*if (FD_ISSET(socklan, &readfs)) {
     if (0 < recvfrom(socklan, msgbuf, sizeof(msgbuf), 0, NULL, NULL)) {
       dio_input_init(&din, msgbuf, 1);
       dio_get_uint8(&din, &type);
@@ -1443,13 +1440,14 @@
         log_debug("Received invalid request for server LAN announcement.");
       }
     }
-  }
+  }*/
 }
 
 /********************************************************************
   This function broadcasts an UDP packet to clients with
   that requests information about the server state.
 ********************************************************************/
+#if 0
 static void send_lanserver_response(void)
 {
 #ifndef HAVE_WINSOCK
@@ -1542,14 +1540,14 @@
               srvarg.port );
 
   dio_output_init(&dout, buffer, sizeof(buffer));
-  dio_put_uint8(&dout, SERVER_LAN_VERSION);
-  dio_put_string(&dout, hostname);
-  dio_put_string(&dout, port);
-  dio_put_string(&dout, version);
-  dio_put_string(&dout, status);
-  dio_put_string(&dout, players);
-  dio_put_string(&dout, humans);
-  dio_put_string(&dout, get_meta_message_string());
+  dio_put_uint8(&dout, "ver", SERVER_LAN_VERSION);
+  dio_put_string(&dout, "host", hostname);
+  dio_put_string(&dout, "port", port);
+  dio_put_string(&dout, "version", version);
+  dio_put_string(&dout, "status", status);
+  dio_put_string(&dout, "players", players);
+  dio_put_string(&dout, "humans", humans);
+  dio_put_string(&dout, "msg", get_meta_message_string());
   size = dio_output_used(&dout);
 
   /* Sending packet to client with the information gathered above. */
@@ -1562,3 +1560,4 @@
 
   fc_closesocket(socksend);
 }
+#endif /* 0 */
