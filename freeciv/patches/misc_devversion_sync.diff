diff -Nurd -X.diff_ignore freeciv/server/citytools.c freeciv/server/citytools.c
--- freeciv/server/citytools.c	2012-05-20 04:29:29.000000000 +0300
+++ freeciv/server/citytools.c	2012-05-20 08:27:07.000000000 +0300
@@ -1778,6 +1778,11 @@
   char impr_buf[MAX_NUM_ITEMS + 1];
   char can_build_impr_buf[MAX_NUM_ITEMS + 1];
   char can_build_unit_buf[MAX_NUM_ITEMS + 1];
+  char food_output_buf[MAX_NUM_ITEMS + 1];
+  char shield_output_buf[MAX_NUM_ITEMS + 1];
+  char trade_output_buf[MAX_NUM_ITEMS + 1];
+  struct tile *pcenter = city_tile(pcity);
+  int c = 0;
 
   packet->id=pcity->id;
   packet->owner = player_number(city_owner(pcity));
@@ -1872,6 +1877,7 @@
   packet->did_buy = pcity->did_buy;
   packet->did_sell = pcity->did_sell;
   packet->was_happy = pcity->was_happy;
+  packet->unhappy = city_unhappy(pcity);
 
   packet->walls = city_got_citywalls(pcity);
 
@@ -1898,7 +1904,28 @@
   } improvement_iterate_end;
   impr_buf[improvement_count()] = '\0';
   sz_strlcpy(packet->improvements, impr_buf);
-  
+
+  city_tile_iterate_cxy(city_map_radius_sq_get(pcity), pcenter, ptile, x, y) {
+    char f[2];
+    char s[2];
+    char t[2];
+
+    my_snprintf(f, sizeof(f), "%d", city_tile_output_now(pcity, ptile, O_FOOD));
+    my_snprintf(s, sizeof(s), "%d", city_tile_output_now(pcity, ptile, O_SHIELD));
+    my_snprintf(t, sizeof(t), "%d", city_tile_output_now(pcity, ptile, O_TRADE));
+    food_output_buf[c] = f[0];
+    shield_output_buf[c] = s[0];
+    trade_output_buf[c] = t[0];
+
+    c += 1;
+
+  } city_tile_iterate_cxy_end;
+  food_output_buf[c] = '\0';
+  shield_output_buf[c] = '\0';
+  trade_output_buf[c] = '\0';
+  sz_strlcpy(packet->food_output, food_output_buf);
+  sz_strlcpy(packet->shield_output, shield_output_buf);
+  sz_strlcpy(packet->trade_output, trade_output_buf);
 }
 
 /**************************************************************************
diff -Nurd -X.diff_ignore freeciv/server/plrhand.c freeciv/server/plrhand.c
--- freeciv/server/plrhand.c	2012-05-20 04:54:47.000000000 +0300
+++ freeciv/server/plrhand.c	2012-05-20 08:19:47.000000000 +0300
@@ -807,6 +807,8 @@
     packet->score = 0;
   }
 
+  packet->net_income = player_get_expected_income(plr);
+
   if (info_level >= INFO_MEETING) {
     packet->gold = plr->economic.gold;
     pgov = government_of_player(plr);
diff -Nurd -X.diff_ignore freeciv/server/ruleset.c freeciv/server/ruleset.c
--- freeciv/server/ruleset.c	2012-05-20 05:07:47.000000000 +0300
+++ freeciv/server/ruleset.c	2012-05-20 08:24:49.000000000 +0300
@@ -2540,12 +2540,12 @@
 **************************************************************************/
 static void load_ruleset_nations(struct section_file *file)
 {
-  const char *bad_leader, *govern;
+  const char *govern;
   struct government *gov;
-  int i2, j, k;
+  int j, k;
   size_t dim;
   char temp_name[MAX_LEN_NAME];
-  const char **groups, **leaders, **civilwar_nations, **conflicts;
+  const char **groups, **civilwar_nations, **conflicts;
   const char *name;
   int barb_land_count = 0;
   int barb_sea_count = 0;
@@ -2609,65 +2609,54 @@
     pl->conflicts_with[j] = NO_NATION_SELECTED; /* extra at end of list */
     free(conflicts);
 
-    /* nation leaders */
-
-    leaders = secfile_lookup_str_vec(file, &dim, "%s.leader", sec_name);
-    if (dim > MAX_NUM_LEADERS) {
-      log_error("Nation %s: Too many leaders; using %d of %d",
-                nation_rule_name(pl), MAX_NUM_LEADERS, (int) dim);
-      dim = MAX_NUM_LEADERS;
-    } else if (dim < 1) {
-      ruleset_error(LOG_FATAL,
-                    "Nation %s: number of leaders is %d; at least one is required.",
-                    nation_rule_name(pl), (int) dim);
+    /* Nation leaders (backported from Freeciv 2.3.x). */
+    for (j = 0; j < MAX_NUM_LEADERS; j++) {
+      name = secfile_lookup_str(file, "%s.leaders%d.name", sec_name, j);
+      if (NULL == name) {
+        pl->leader_count = j;
+        pl->leaders = fc_calloc(j, sizeof(*(pl->leaders)));
+        break;
+      }
     }
-    pl->leader_count = dim;
-    pl->leaders = fc_calloc(dim /*exact*/, sizeof(*(pl->leaders)));
 
-    for(j = 0; j < dim; j++) {
-      pl->leaders[j].name = mystrdup(leaders[j]);
-      if (check_name(leaders[j])) {
-	pl->leaders[j].name[MAX_LEN_NAME - 1] = '\0';
+    for (j = 0; j < MAX_NUM_LEADERS; j++) {
+      const char *sex;
+      bool is_male = FALSE;
+
+      name = secfile_lookup_str(file, "%s.leaders%d.name", sec_name, j);
+      if (NULL == name) {
+        /* No more to read. */
+        break;
       }
-    }
-    free(leaders);
 
-    /* check if leader name is not already defined */
-    if ((bad_leader = check_leader_names(i, &i2))) {
-        if (i == i2) {
-          ruleset_error(LOG_FATAL,
-                        "Nation %s: leader \"%s\" defined more than once.",
-                        nation_rule_name(pl),
-                        bad_leader);
-        } else {
-          ruleset_error(LOG_FATAL,
-                        "Nations %s and %s share the same leader \"%s\".",
-                        nation_rule_name(pl),
-                        nation_rule_name(nation_by_number(i2)),
-                        bad_leader);
-        }
-    }
-    /* read leaders'sexes */
-    leaders = secfile_lookup_str_vec(file, &dim, "%s.leader_sex", sec_name);
-    if (dim != pl->leader_count) {
-      ruleset_error(LOG_FATAL,
-                    "Nation %s: the leader sex count (%d) "
-                    "is not equal to the number of leaders (%d)",
-                    nation_rule_name(pl), (int) dim, pl->leader_count);
-    }
-    for (j = 0; j < dim; j++) {
-      if (0 == mystrcasecmp(leaders[j], "Male")) {
-        pl->leaders[j].is_male = TRUE;
-      } else if (0 == mystrcasecmp(leaders[j], "Female")) {
-        pl->leaders[j].is_male = FALSE;
-      } else {
-        log_error("Nation %s, leader %s: sex must be either Male or Female; "
-                  "assuming Male",
-                  nation_rule_name(pl), pl->leaders[j].name);
-	pl->leaders[j].is_male = TRUE;
+      if (check_name(name)) {
+        /* The ruleset contains a name that is too long. This shouldn't
+         * happen - if it does, the author should get immediate feedback */
+        sz_strlcpy(temp_name, name);
+        /*ruleset_error(LOG_ERROR, "Nation %s: leader name \"%s\" "
+                      "is too long; shortening it to \"%s\".",
+                      nation_rule_name(pnation), name, temp_name);*/
+        name = temp_name;
       }
+
+      sex = secfile_lookup_str(file, "%s.leaders%d.sex", sec_name, j);
+      if (NULL == sex) {
+        /*ruleset_error(LOG_FATAL, "Nation %s: leader \"%s\": %s.",
+                      nation_rule_name(pnation), name, secfile_error());*/
+      } else if (0 == mystrcasecmp("Male", sex)) {
+        is_male = TRUE;
+      } else if (0 != mystrcasecmp("Female", sex)) {
+        /*ruleset_error(LOG_FATAL, "Nation %s: leader \"%s\" has unsupported "
+                      "sex variant \"%s\".",
+                      nation_rule_name(pnation), name, sex);*/
+      }
+
+      pl->leaders[j].name = mystrdup(name);
+      if (check_name(name)) {
+        pl->leaders[j].name[MAX_LEN_NAME - 1] = '\0';
+      }
+      pl->leaders[j].is_male = is_male;
     }
-    free(leaders);
     
     pl->is_available = secfile_lookup_bool_default(file, TRUE,
                                                    "%s.is_available",
diff -Nurd -X.diff_ignore freeciv/server/sernet.c freeciv/server/sernet.c
--- freeciv/server/sernet.c	2012-05-20 05:51:42.000000000 +0300
+++ freeciv/server/sernet.c	2012-05-20 08:19:47.000000000 +0300
@@ -1185,7 +1185,7 @@
     }
     fc_assert(i < ARRAY_SIZE(packet.conn_id));
     packet.conn_id[i] = pconn->id;
-    packet.ping_time[i] = pconn->ping_time;
+    packet.ping_time[i] = pconn->ping_time * 1000;
     i++;
   } conn_list_iterate_end;
   packet.connections = i;
diff -Nurd -X.diff_ignore freeciv/server/unithand.c freeciv/server/unithand.c
--- freeciv/server/unithand.c	2012-05-20 08:19:10.000000000 +0300
+++ freeciv/server/unithand.c	2012-05-20 08:19:47.000000000 +0300
@@ -689,6 +689,7 @@
 		       "UTF-8",
 		       (char*)result_buf, sizeof(result_buf));
       city_build(pplayer, punit, result_buf);
+      g_free(unescaped_text);
     }
   } else if (res == AB_ADD_OK) {
     city_add_unit(pplayer, punit);
