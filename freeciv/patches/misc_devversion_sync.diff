diff -Nurd -X.diff_ignore freeciv/server/citytools.c freeciv/server/citytools.c
--- freeciv/server/citytools.c	2012-05-19 01:03:32.000000000 +0300
+++ freeciv/server/citytools.c	2012-05-19 01:41:27.000000000 +0300
@@ -1803,6 +1803,11 @@
   char impr_buf[MAX_NUM_ITEMS + 1];
   char can_build_impr_buf[MAX_NUM_ITEMS + 1];
   char can_build_unit_buf[MAX_NUM_ITEMS + 1];
+  char food_output_buf[MAX_NUM_ITEMS + 1];
+  char shield_output_buf[MAX_NUM_ITEMS + 1];
+  char trade_output_buf[MAX_NUM_ITEMS + 1];
+  struct tile *pcenter = city_tile(pcity);
+  int c = 0;
 
   packet->id=pcity->id;
   packet->owner = player_number(city_owner(pcity));
@@ -1896,6 +1901,7 @@
   packet->did_buy = pcity->did_buy;
   packet->did_sell = pcity->did_sell;
   packet->was_happy = pcity->was_happy;
+  packet->unhappy = city_unhappy(pcity);
 
   packet->walls = city_got_citywalls(pcity);
 
@@ -1922,7 +1928,28 @@
   } improvement_iterate_end;
   impr_buf[improvement_count()] = '\0';
   sz_strlcpy(packet->improvements, impr_buf);
-  
+
+  city_tile_iterate_cxy(pcenter, ptile, x, y) {
+    char f[2];
+    char s[2];
+    char t[2];
+
+    my_snprintf(f, sizeof(f), "%d", city_tile_output_now(pcity, ptile, O_FOOD));
+    my_snprintf(s, sizeof(s), "%d", city_tile_output_now(pcity, ptile, O_SHIELD));
+    my_snprintf(t, sizeof(t), "%d", city_tile_output_now(pcity, ptile, O_TRADE));
+    food_output_buf[c] = f[0];
+    shield_output_buf[c] = s[0];
+    trade_output_buf[c] = t[0];
+
+    c += 1;
+
+  } city_tile_iterate_cxy_end;
+  food_output_buf[c] = '\0';
+  shield_output_buf[c] = '\0';
+  trade_output_buf[c] = '\0';
+  sz_strlcpy(packet->food_output, food_output_buf);
+  sz_strlcpy(packet->shield_output, shield_output_buf);
+  sz_strlcpy(packet->trade_output, trade_output_buf);
 }
 
 /**************************************************************************
diff -Nurd -X.diff_ignore freeciv/server/plrhand.c freeciv/server/plrhand.c
--- freeciv/server/plrhand.c	2012-05-19 01:03:32.000000000 +0300
+++ freeciv/server/plrhand.c	2012-05-19 01:42:21.000000000 +0300
@@ -812,6 +812,8 @@
     packet->score = 0;
   }
 
+  packet->net_income = player_get_expected_income(plr);
+
   if (info_level >= INFO_MEETING) {
     packet->gold = plr->economic.gold;
     pgov = government_of_player(plr);
diff -Nurd -X.diff_ignore freeciv/server/ruleset.c freeciv/server/ruleset.c
--- freeciv/server/ruleset.c	2012-05-19 01:03:32.000000000 +0300
+++ freeciv/server/ruleset.c	2012-05-19 01:46:58.000000000 +0300
@@ -2430,11 +2430,11 @@
 **************************************************************************/
 static void load_ruleset_nations(struct section_file *file)
 {
-  char *bad_leader, *govern;
+  char *govern;
   struct government *gov;
-  int dim, i, i2, j, k, nval, numgroups;
+  int dim, i, j, k, nval, numgroups;
   char temp_name[MAX_LEN_NAME];
-  char **leaders, **sec, **civilwar_nations, **groups, **conflicts;
+  char **sec, **civilwar_nations, **groups, **conflicts;
   char* name;
   int barb_land_count = 0;
   int barb_sea_count = 0;
@@ -2485,72 +2485,57 @@
     pl->conflicts_with[j] = NO_NATION_SELECTED; /* extra at end of list */
     free(conflicts);
 
-    /* nation leaders */
+    /* Nation leaders (backported from Freeciv 2.3.x). */
+    for (j = 0; j < MAX_NUM_LEADERS; j++) {
+      name = secfile_lookup_str(file, "%s.leaders%d.name", sec[i], j);
+      if (NULL == name) {
+        pl->leader_count = j;
+        pl->leaders = fc_calloc(j, sizeof(*(pl->leaders)));
 
-    leaders = secfile_lookup_str_vec(file, &dim, "%s.leader", sec[i]);
-    if (dim > MAX_NUM_LEADERS) {
-      freelog(LOG_ERROR, "Nation %s: Too many leaders; using %d of %d",
-	      nation_rule_name(pl),
-	      MAX_NUM_LEADERS,
-	      dim);
-      dim = MAX_NUM_LEADERS;
-    } else if (dim < 1) {
-      ruleset_error(LOG_FATAL,
-                    "Nation %s: number of leaders is %d; at least one is required.",
-                    nation_rule_name(pl),
-                    dim);
+        break;
+      }
     }
-    pl->leader_count = dim;
-    pl->leaders = fc_calloc(dim /*exact*/, sizeof(*(pl->leaders)));
 
-    for(j = 0; j < dim; j++) {
-      pl->leaders[j].name = mystrdup(leaders[j]);
-      if (check_name(leaders[j])) {
-	pl->leaders[j].name[MAX_LEN_NAME - 1] = '\0';
+    for (j = 0; j < MAX_NUM_LEADERS; j++) {
+      const char *sex;
+      bool is_male = FALSE;
+
+      name = secfile_lookup_str(file, "%s.leaders%d.name", sec[i], j);
+      if (NULL == name) {
+        /* No more to read. */
+        break;
       }
-    }
-    free(leaders);
 
-    /* check if leader name is not already defined */
-    if ((bad_leader = check_leader_names(i, &i2))) {
-        if (i == i2) {
-          ruleset_error(LOG_FATAL,
-                        "Nation %s: leader \"%s\" defined more than once.",
-                        nation_rule_name(pl),
-                        bad_leader);
-        } else {
-          ruleset_error(LOG_FATAL,
-                        "Nations %s and %s share the same leader \"%s\".",
-                        nation_rule_name(pl),
-                        nation_rule_name(nation_by_number(i2)),
-                        bad_leader);
-        }
-    }
-    /* read leaders'sexes */
-    leaders = secfile_lookup_str_vec(file, &dim, "%s.leader_sex", sec[i]);
-    if (dim != pl->leader_count) {
-      ruleset_error(LOG_FATAL,
-                    "Nation %s: the leader sex count (%d) "
-                    "is not equal to the number of leaders (%d)",
-                    nation_rule_name(pl),
-                    dim,
-                    pl->leader_count);
-    }
-    for (j = 0; j < dim; j++) {
-      if (0 == mystrcasecmp(leaders[j], "Male")) {
-        pl->leaders[j].is_male = TRUE;
-      } else if (0 == mystrcasecmp(leaders[j], "Female")) {
-        pl->leaders[j].is_male = FALSE;
-      } else {
-        freelog(LOG_ERROR,
-		"Nation %s, leader %s: sex must be either Male or Female; "
-		"assuming Male",
-		nation_rule_name(pl),
-		pl->leaders[j].name);
-	pl->leaders[j].is_male = TRUE;
+      if (check_name(name)) {
+        /* The ruleset contains a name that is too long. This shouldn't
+         * happen - if it does, the author should get immediate feedback */
+        sz_strlcpy(temp_name, name);
+        /*ruleset_error(LOG_ERROR, "Nation %s: leader name \"%s\" "
+                      "is too long; shortening it to \"%s\".",
+                      nation_rule_name(pnation), name, temp_name);*/
+        name = temp_name;
       }
+
+      sex = secfile_lookup_str(file, "%s.leaders%d.sex", sec[i], j);
+      if (NULL == sex) {
+        /*ruleset_error(LOG_FATAL, "Nation %s: leader \"%s\": %s.",
+                      nation_rule_name(pnation), name, secfile_error());*/
+      } else if (0 == mystrcasecmp("Male", sex)) {
+        is_male = TRUE;
+      } else if (0 != mystrcasecmp("Female", sex)) {
+        /*ruleset_error(LOG_FATAL, "Nation %s: leader \"%s\" has unsupported "
+                      "sex variant \"%s\".",
+                      nation_rule_name(pnation), name, sex);*/
+      }
+
+      pl->leaders[j].name = mystrdup(name);
+      if (check_name(name)) {
+        pl->leaders[j].name[MAX_LEN_NAME - 1] = '\0';
+      }
+      pl->leaders[j].is_male = is_male;
+
+      //(void) nation_leader_new(pnation, name, is_male);
     }
-    free(leaders);
     
     pl->is_available = secfile_lookup_bool_default(file, TRUE,
                                                    "%s.is_available", sec[i]);
diff -Nurd -X.diff_ignore freeciv/server/sernet.c freeciv/server/sernet.c
--- freeciv/server/sernet.c	2012-05-19 01:08:53.000000000 +0300
+++ freeciv/server/sernet.c	2012-05-19 01:48:08.000000000 +0300
@@ -1192,7 +1192,7 @@
     }
     assert(i < ARRAY_SIZE(packet.conn_id));
     packet.conn_id[i] = pconn->id;
-    packet.ping_time[i] = pconn->ping_time;
+    packet.ping_time[i] = pconn->ping_time * 1000;
     i++;
   } conn_list_iterate_end;
   packet.connections = i;
diff -Nurd -X.diff_ignore freeciv/server/unithand.c freeciv/server/unithand.c
--- freeciv/server/unithand.c	2012-05-19 01:03:31.000000000 +0300
+++ freeciv/server/unithand.c	2012-05-19 01:51:45.000000000 +0300
@@ -730,6 +730,7 @@
 		       "UTF-8",
 		       (char*)result_buf, sizeof(result_buf));
       city_build(pplayer, punit, result_buf);
+      g_free(unescaped_text);
     }
   } else if (res == AB_ADD_OK) {
     city_add_unit(pplayer, punit);
@@ -833,6 +834,108 @@
 }
 
 /**************************************************************************
+  This function handles GOTO path requests from the client.
+**************************************************************************/
+void handle_goto_path_req(struct player *pplayer, int unit_id, int x, int y)
+{
+  struct unit *punit = player_find_unit_by_id(pplayer, unit_id);
+  struct tile *ptile = map_pos_to_tile(x, y);
+  struct pf_parameter parameter;
+  struct pf_map *pfm;
+  struct pf_path *path;
+  struct tile *old_tile;
+  int i = 0;
+  struct packet_goto_path p;
+
+  if (NULL == punit) {
+    /* Shouldn't happen */
+    freelog(LOG_ERROR, "handle_unit_move()"
+           " invalid unit %d",
+           unit_id);
+    return;
+  }
+
+  if (NULL == ptile) {
+    /* Shouldn't happen */
+    freelog(LOG_ERROR, "handle_unit_move()"
+           " invalid %s (%d) tile (%d,%d)",
+           unit_rule_name(punit),
+           unit_id,
+           x, y);
+    return;
+  }
+
+  if (!is_player_phase(unit_owner(punit), game.info.phase)) {
+    /* Client is out of sync, ignore */
+    freelog(LOG_VERBOSE, "handle_unit_move()"
+           " invalid %s (%d) %s != phase %d",
+           unit_rule_name(punit),
+           unit_id,
+           nation_rule_name(nation_of_unit(punit)),
+           game.info.phase);
+    return;
+  }
+
+  p.unit_id = punit->id;
+  p.dest_x = x;
+  p.dest_y = y;
+
+  /* Use path-finding to find a goto path. */
+  pft_fill_unit_parameter(&parameter, punit);
+  pfm = pf_map_new(&parameter);
+  path = pf_map_get_path(pfm, ptile);
+  pf_map_destroy(pfm);
+
+  if (path) {
+
+    p.length = path->length - 1;
+
+    old_tile = path->positions[0].tile;
+
+    /* Remove city spot reservations for AI settlers on city founding
+     * mission, before goto_tile reset. */
+    if (punit->ai.ai_role != AIUNIT_NONE) {
+      ai_unit_new_role(punit, AIUNIT_NONE, NULL);
+    }
+
+    punit->ai.control = FALSE;
+    punit->goto_tile = NULL;
+
+    free_unit_orders(punit);
+    /* If we waited on a tile, reset punit->done_moving */
+    punit->done_moving = (punit->moves_left <= 0);
+    punit->has_orders = TRUE;
+    punit->orders.length = path->length - 1;
+    punit->orders.index = 0;
+    punit->orders.repeat = FALSE;
+    punit->orders.vigilant = FALSE;
+    punit->orders.list
+      = fc_malloc(path->length * sizeof(*(punit->orders.list)));
+    int total_mc = 0;
+    for (i = 0; i < path->length - 1; i++) {
+      struct tile *new_tile = path->positions[i + 1].tile;
+      total_mc += path->positions[1].total_MC;
+      int dir;
+      if (same_pos(new_tile, old_tile)) {
+        dir = -1;
+      } else {
+        dir = get_direction_for_step(old_tile, new_tile);
+      }
+      old_tile = new_tile;
+      p.dir[i] = dir;
+
+    }
+    pf_path_destroy(path);
+    p.turns = total_mc / unit_move_rate(punit);
+    send_packet_goto_path(pplayer->current_conn, &p);
+
+  } else {
+    return ;
+  }
+
+}
+
+/**************************************************************************
   This has been rewritten to handle server-side gotos for the web client.
 **************************************************************************/
 void handle_unit_move(struct player *pplayer, int unit_id, int x, int y)
@@ -931,6 +1034,9 @@
     pf_path_destroy(path);
     return ;
   } else {
+    notify_player(pplayer, punit->tile, E_BAD_COMMAND,
+                  FTC_SERVER_INFO, NULL,
+                  _("The unit can't go there."));
     return ;
   }
 
