diff --git freeciv/server/generator/mapgen.c freeciv/server/generator/mapgen.c
index f2c23ac..f231d05 100644
--- freeciv/server/generator/mapgen.c
+++ freeciv/server/generator/mapgen.c
@@ -2679,6 +2679,35 @@ fair_map_tile_step(struct fair_tile *pmap, struct fair_tile *ptile,
 }
 
 /****************************************************************************
+  Returns whether 'ptile' is at least at 'dist' tiles (in real distance)
+  to the border. Note is also take in account map wrapping.
+****************************************************************************/
+static inline bool
+fair_map_tile_border(struct fair_tile *pmap, struct fair_tile *ptile,
+                     int dist)
+{
+  int nat_x, nat_y;
+
+  index_to_native_pos(&nat_x, &nat_y, ptile - pmap);
+
+  if (!current_topo_has_flag(TF_WRAPX)
+      && (nat_x < dist || nat_x >= map.xsize - dist)) {
+    return TRUE;
+  }
+
+  if (MAP_IS_ISOMETRIC) {
+    dist *= 2;
+  }
+
+  if (!current_topo_has_flag(TF_WRAPY)
+      && (nat_y < dist || nat_y >= map.ysize - dist)) {
+    return TRUE;
+  }
+
+  return FALSE;
+}
+
+/****************************************************************************
   Compare two iter_index values for doing closest team placement.
 ****************************************************************************/
 static int fair_team_placement_closest(const void *a, const void *b)
@@ -3034,12 +3063,14 @@ static struct fair_tile *fair_map_island_new(int size, int startpos_num)
   struct fair_tile *land_tiles[1000];
   struct fair_tile *pftile, *pftile2, *pftile3;
   int fantasy;
+  int sea_around_island = (startpos_num > 0 ? 2 : 1);
   int i, j, k;
 
   size = CLIP(startpos_num, size, ARRAY_SIZE(land_tiles));
   fantasy = (size * 2) / 5;
   pisland = fair_map_new();
   pftile = fair_map_pos_tile(pisland, map.xsize / 2, map.ysize / 2);
+  fc_assert(!fair_map_tile_border(pisland, pftile, sea_around_island));
   pftile->flags |= FTF_ASSIGNED;
   land_tiles[0] = pftile;
   i = 1;
@@ -3053,6 +3084,11 @@ static struct fair_tile *fair_map_island_new(int size, int startpos_num)
 
     for (j = 0; j < map.num_valid_dirs; j++) {
       pftile2 = fair_map_tile_step(pisland, pftile, map.valid_dirs[j]);
+      fc_assert(pftile2 != NULL);
+      if (fair_map_tile_border(pisland, pftile2, sea_around_island)) {
+        continue;
+      }
+
       if (pftile2->flags == FTF_NONE) {
         pftile2->flags = FTF_ASSIGNED;
         land_tiles[i++] = pftile2;
@@ -3066,6 +3102,11 @@ static struct fair_tile *fair_map_island_new(int size, int startpos_num)
     pftile = land_tiles[i - fc_rand(fantasy) - 1];
     pftile2 = fair_map_tile_step(pisland, pftile, map.cardinal_dirs
                                      [fc_rand(map.num_cardinal_dirs)]);
+    fc_assert(pftile2 != NULL);
+    if (fair_map_tile_border(pisland, pftile2, sea_around_island)) {
+      continue;
+    }
+
     if (pftile2->flags == FTF_NONE) {
       pftile2->flags = FTF_ASSIGNED;
       land_tiles[i++] = pftile2;
@@ -3111,33 +3152,20 @@ static struct fair_tile *fair_map_island_new(int size, int startpos_num)
 
   /* Make sea arround the island. */
   for (i = 0; i < size; i++) {
-    pftile = land_tiles[i];
+    square_iterate(index_to_tile(land_tiles[i] - pisland), sea_around_island,
+                   ptile) {
+      pftile = pisland + tile_index(ptile);
 
-    for (j = 0; j < map.num_valid_dirs; j++) {
-      pftile2 = fair_map_tile_step(pisland, pftile, map.valid_dirs[j]);
-      if (pftile2->flags == FTF_NONE) {
-        pftile2->flags = FTF_OCEAN;
-        pftile2->pterrain =
+      if (pftile->flags == FTF_NONE) {
+        pftile->flags = FTF_OCEAN;
+        pftile->pterrain =
             pick_ocean(TERRAIN_OCEAN_DEPTH_MINIMUM
                        + fc_rand(TERRAIN_OCEAN_DEPTH_MAXIMUM / 2));
-      }
-      if (startpos_num > 0) {
-        /* Give a second sea tile. */
-        pftile2->flags |= FTF_ASSIGNED;
-        for (k = 0; k < map.num_valid_dirs; k++) {
-          if (k == DIR_REVERSE(j)) {
-            continue;
-          }
-          pftile3 = fair_map_tile_step(pisland, pftile2, map.valid_dirs[k]);
-          if (pftile3->flags == FTF_NONE) {
-            pftile3->flags |= (FTF_ASSIGNED | FTF_OCEAN);
-            pftile3->pterrain =
-                pick_ocean(TERRAIN_OCEAN_DEPTH_MINIMUM
-                           + fc_rand(TERRAIN_OCEAN_DEPTH_MAXIMUM / 2));
-          }
+        if (startpos_num > 0) {
+          pftile->flags |= FTF_ASSIGNED;
         }
       }
-    }
+    } square_iterate_end;
   }
 
   /* Make resources. */
@@ -3321,6 +3349,7 @@ static struct fair_tile *fair_map_island_new(int size, int startpos_num)
           break;
         }
         pftile = fair_map_tile_step(pisland, pftile, dir);
+        fc_assert(pftile != NULL);
       }
     }
   }
