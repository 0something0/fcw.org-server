diff -Nurd -X.diff_ignore freeciv/common/connection.h freeciv/common/connection.h
--- freeciv/common/connection.h	2012-05-16 22:19:49.000000000 +0300
+++ freeciv/common/connection.h	2012-05-16 22:24:13.000000000 +0300
@@ -126,6 +126,7 @@
   struct socket_packet_buffer *buffer;
   struct socket_packet_buffer *send_buffer;
   struct timer *last_write;
+  json_t *json_packet;
 
   double ping_time;
   
diff -Nurd -X.diff_ignore freeciv/common/dataio.c freeciv/common/dataio.c
--- freeciv/common/dataio.c	2012-05-16 20:56:43.000000000 +0300
+++ freeciv/common/dataio.c	2012-05-16 22:24:13.000000000 +0300
@@ -195,8 +195,13 @@
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_uint8(struct data_out *dout, int value)
+void dio_put_uint8(struct data_out *dout, char *key, int value)
 {
+  json_object_set_new(dout->json, key, json_integer(value));
+}
+
+void dio_put_uint8_old(struct data_out *dout, int value)
+ {
   if (enough_space(dout, 1)) {
     uint8_t x = value;
 
@@ -206,108 +211,68 @@
   }
 }
 
+
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_uint16(struct data_out *dout, int value)
+void dio_put_uint16(struct data_out *dout, char *key, int value)
 {
-  if (enough_space(dout, 2)) {
-    uint16_t x = htons(value);
-
-    assert(sizeof(x) == 2);
-    memcpy(ADD_TO_POINTER(dout->dest, dout->current), &x, 2);
-    dout->current += 2;
-  }
+  json_object_set_new(dout->json, key, json_integer(value));
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_uint32(struct data_out *dout, int value)
+void dio_put_uint32(struct data_out *dout, char *key, int value)
 {
-  if (enough_space(dout, 4)) {
-    uint32_t x = htonl(value);
-
-    assert(sizeof(x) == 4);
-    memcpy(ADD_TO_POINTER(dout->dest, dout->current), &x, 4);
-    dout->current += 4;
-  }
+  json_object_set_new(dout->json, key, json_integer(value));
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_bool8(struct data_out *dout, bool value)
+void dio_put_bool8(struct data_out *dout, char *key, bool value)
 {
-  if (value != TRUE && value != FALSE) {
-    freelog(LOG_ERROR, "Trying to put a non-boolean: %d", (int) value);
-    value = FALSE;
-  }
-
-  dio_put_uint8(dout, value ? 1 : 0);
+  json_object_set_new(dout->json, key, value ? json_true() : json_false());
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_bool32(struct data_out *dout, bool value)
+void dio_put_bool32(struct data_out *dout, char *key, bool value)
 {
-  if (value != TRUE && value != FALSE) {
-    freelog(LOG_ERROR, "Trying to put a non-boolean: %d", (int) value);
-    value = FALSE;
-  }
-
-  dio_put_uint32(dout, value ? 1 : 0);
+  json_object_set_new(dout->json, key, value ? json_true() : json_false());
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_uint8_vec8(struct data_out *dout, int *values, int stop_value)
+void dio_put_uint8_vec8(struct data_out *dout, char *key, int *values, int stop_value)
 {
-  size_t count;
-
-  for (count = 0; values[count] != stop_value; count++) {
-    /* nothing */
-  }
-
-  if (enough_space(dout, 1 + count)) {
-    size_t i;
-
-    dio_put_uint8(dout, count);
-
-    for (i = 0; i < count; i++) {
-      dio_put_uint8(dout, values[i]);
-    }
-  }
+ /* TODO: implement. */
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_uint16_vec8(struct data_out *dout, int *values, int stop_value)
+void dio_put_uint16_vec8(struct data_out *dout, char *key, int *values, int stop_value)
 {
-  size_t count;
-
-  for (count = 0; values[count] != stop_value; count++) {
-    /* nothing */
-  }
-
-  if (enough_space(dout, 1 + 2 * count)) {
-    size_t i;
+  /* TODO: implement */
 
-    dio_put_uint8(dout, count);
+}
 
-    for (i = 0; i < count; i++) {
-      dio_put_uint16(dout, values[i]);
-    }
-  }
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_memory(struct data_out *dout, char *key, const void *value, size_t size)
+{
+  /* TODO: implement */
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_memory(struct data_out *dout, const void *value, size_t size)
+void dio_put_memory_old(struct data_out *dout, const void *value, size_t size)
 {
   if (enough_space(dout, size)) {
     memcpy(ADD_TO_POINTER(dout->dest, dout->current), value, size);
@@ -315,99 +280,184 @@
   }
 }
 
+
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_string(struct data_out *dout, const char *value)
+void dio_put_string(struct data_out *dout, char *key, const char *value)
 {
+  json_object_set_new(dout->json, key, json_string(value));
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_string_array(struct data_out *dout, char *key, 
+		          const char *value, int size)
+{
+  int i;
+
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    if (value != NULL) {
+      json_array_append_new(array, json_string(value + i));
+    }
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+
+void dio_put_string_old(struct data_out *dout, const char *value)
+ {
   if (put_conv_callback) {
     size_t length;
     char *buffer;
 
     if ((buffer = (*put_conv_callback) (value, &length))) {
-      dio_put_memory(dout, buffer, length + 1);
+      dio_put_memory_old(dout, buffer, length + 1);
       free(buffer);
     }
   } else {
-    dio_put_memory(dout, value, strlen(value) + 1);
+    dio_put_memory_old(dout, value, strlen(value) + 1);
+  }
+}
+
+void dio_put_uint16_old(struct data_out *dout, int value)
+{
+  if (enough_space(dout, 2)) {
+    uint16_t x = htons(value);
+
+    assert(sizeof(x) == 2);
+    memcpy(ADD_TO_POINTER(dout->dest, dout->current), &x, 2);
+    dout->current += 2;
   }
 }
 
+
+
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_bit_string(struct data_out *dout, const char *value)
+void dio_put_bit_string(struct data_out *dout, char *key, const char *value)
 {
-  /* Note that size_t is often an unsigned type, so we must be careful
-   * with the math when calculating 'bytes'. */
-  size_t bits = strlen(value), bytes;
-  size_t max = (unsigned short)(-1);
+  /* TODO: implement */
 
-  if (bits > max) {
-    freelog(LOG_ERROR, "Bit string too long: %lu bits.", (unsigned long)bits);
-    assert(FALSE);
-    bits = max;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_tech_list(struct data_out *dout, char *key, const int *value)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_worklist(struct data_out *dout, char *key, const struct worklist *pwl)
+{
+  /* TODO: implement */
+}
+
+void dio_put_array_uint8(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
   }
-  bytes = (bits + 7) / 8;
+  
+  json_object_set_new(dout->json, key, array);
+}
 
-  if (enough_space(dout, bytes + 1)) {
-    size_t i;
+void dio_put_array_uint32(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
 
-    dio_put_uint16(dout, bits);
+}
 
-    for (i = 0; i < bits;) {
-      int bit, data = 0;
+void dio_put_array_sint8(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
 
-      for (bit = 0; bit < 8 && i < bits; bit++, i++) {
-	if (value[i] == '1') {
-	  data |= (1 << bit);
-	}
-      }
-      dio_put_uint8(dout, data);
-    }
+}
+
+void dio_put_array_sint16(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
   }
+  
+  json_object_set_new(dout->json, key, array);
+
 }
 
-/**************************************************************************
-...
-**************************************************************************/
-void dio_put_tech_list(struct data_out *dout, const int *value)
+void dio_put_array_sint32(struct data_out *dout, char *key, int *values, int size)
 {
   int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
 
-  for (i = 0; i < MAX_NUM_TECH_LIST; i++) {
-    dio_put_uint8(dout, value[i]);
-    if (value[i] == A_LAST) {
-      break;
-    }
+}
+
+void dio_put_array_bool8(struct data_out *dout, char *key, bool *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, values[i] ? json_true() : json_false());
   }
+  
+  json_object_set_new(dout->json, key, array);
+
 }
 
+
 /**************************************************************************
-...
+ Receive uint8 value to dest. In case of failure, value stored to dest
+ will be zero. Note that zero is legal value even when there is no failure.
 **************************************************************************/
-void dio_put_worklist(struct data_out *dout, const struct worklist *pwl)
+void dio_get_uint8(json_t *json_packet, char *key, int *dest)
 {
-  dio_put_bool8(dout, pwl->is_valid);
-
-  if (pwl->is_valid) {
-    int i, length = worklist_length(pwl);
+  json_t *pint = json_object_get(json_packet, key);
 
-    dio_put_uint8(dout, length);
-    for (i = 0; i < length; i++) {
-      const struct universal *pcp = &(pwl->entries[i]);
+  if (!pint) {
+    freelog(LOG_ERROR, "ERROR: Unable to get uint8 with key: %s", key);
+    return;
+  } 
+  *dest = json_integer_value(pint);
 
-      dio_put_uint8(dout, pcp->kind);
-      dio_put_uint8(dout, universal_number(pcp));
-    }
+  if (!dest) {
+    freelog(LOG_ERROR, "ERROR: Unable to get unit8 with key: %s", key);
   }
+
 }
 
 /**************************************************************************
  Receive uint8 value to dest. In case of failure, value stored to dest
  will be zero. Note that zero is legal value even when there is no failure.
 **************************************************************************/
-void dio_get_uint8(struct data_in *din, int *dest)
+void dio_get_uint8_old(struct data_in *din, int *dest)
 {
   if (enough_data(din, 1)) {
     if (dest) {
@@ -423,11 +473,12 @@
   }
 }
 
+
 /**************************************************************************
  Receive uint16 value to dest. In case of failure, value stored to dest
  will be zero. Note that zero is legal value even when there is no failure.
 **************************************************************************/
-void dio_get_uint16(struct data_in *din, int *dest)
+void dio_get_uint16_old(struct data_in *din, int *dest)
 {
   if (enough_data(din, 2)) {
     if (dest) {
@@ -443,121 +494,167 @@
   }
 }
 
+
+/**************************************************************************
+ Receive uint16 value to dest. In case of failure, value stored to dest
+ will be zero. Note that zero is legal value even when there is no failure.
+**************************************************************************/
+void dio_get_uint16(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    freelog(LOG_ERROR, "ERROR: Unable to get uint16 with key: %s", key);
+    return;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    freelog(LOG_ERROR, "ERROR: Unable to get unit16 with key: %s", key);
+  }
+
+}
+
 /**************************************************************************
  Receive uint32 value to dest. In case of failure, value stored to dest
  will be zero. Note that zero is legal value even when there is no failure.
 **************************************************************************/
-void dio_get_uint32(struct data_in *din, int *dest)
+void dio_get_uint32(json_t *json_packet, char *key, int *dest)
 {
-  if (enough_data(din, 4)) {
-    if (dest) {
-      uint32_t x;
 
-      assert(sizeof(x) == 4);
-      memcpy(&x, ADD_TO_POINTER(din->src, din->current), 4);
-      *dest = ntohl(x);
-    }
-    din->current += 4;
-  } else if (dest) {
-    *dest = 0;
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    freelog(LOG_ERROR, "ERROR: Unable to get uint32 with key: %s", key);
+    return;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    freelog(LOG_ERROR, "ERROR: Unable to get unit32 with key: %s", key);
   }
+
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_bool8(struct data_in *din, bool * dest)
+void dio_get_bool8(json_t *json_packet, char *key, bool * dest)
 {
-  int ival;
+  json_t *pbool = json_object_get(json_packet, key);
 
-  dio_get_uint8(din, &ival);
+  if (!pbool) {
+    freelog(LOG_ERROR, "ERROR: Unable to get bool8 with key: %s", key);
+    return;
+  } 
+  *dest = json_is_true(pbool);
 
-  if (ival != 0 && ival != 1) {
-    freelog(LOG_ERROR, "Received value isn't boolean: %d", ival);
-    ival = 1;
+  if (!dest) {
+    freelog(LOG_ERROR, "ERROR: Unable to get bool with key: %s", key);
   }
 
-  *dest = (ival != 0);
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_bool32(struct data_in *din, bool * dest)
+void dio_get_bool32(json_t *json_packet, char *key, bool * dest)
 {
-  int ival = 0;
+ json_t *pbool = json_object_get(json_packet, key);
 
-  dio_get_uint32(din, &ival);
+  if (!pbool) {
+    freelog(LOG_ERROR, "ERROR: Unable to get bool32 with key: %s", key);
+    return;
+  } 
+  *dest = json_is_true(pbool);
 
-  if (ival != 0 && ival != 1) {
-    freelog(LOG_ERROR, "Received value isn't boolean: %d", ival);
-    ival = 1;
+  if (!dest) {
+    freelog(LOG_ERROR, "ERROR: Unable to get bool32 with key: %s", key);
   }
 
-  *dest = (ival != 0);
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_sint8(struct data_in *din, int *dest)
+void dio_get_sint8(json_t *json_packet, char *key, int *dest)
 {
-  int tmp;
+  json_t *pint = json_object_get(json_packet, key);
 
-  dio_get_uint8(din, &tmp);
-  if (dest) {
-    if (tmp > 0x7f) {
-      tmp -= 0x100;
-    }
-    *dest = tmp;
+  if (!pint) {
+    freelog(LOG_ERROR, "ERROR: Unable to get sint8 with key: %s", key);
+    return;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    freelog(LOG_ERROR, "ERROR: Unable to get sint8 with key: %s", key);
   }
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_sint16(struct data_in *din, int *dest)
+void dio_get_sint16(json_t *json_packet, char *key, int *dest)
 {
-  int tmp = 0;
+  json_t *pint = json_object_get(json_packet, key);
 
-  dio_get_uint16(din, &tmp);
-  if (dest) {
-    if (tmp > 0x7fff) {
-      tmp -= 0x10000;
-    }
-    *dest = tmp;
+  if (!pint) {
+    freelog(LOG_ERROR, "ERROR: Unable to get sint16 with key: %s", key);
+    return;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    freelog(LOG_ERROR, "ERROR: Unable to get sint16 with key: %s", key);
   }
+
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_memory(struct data_in *din, void *dest, size_t dest_size)
+void dio_get_memory(json_t *json_packet, char *key, void *dest, size_t dest_size)
 {
-  if (enough_data(din, dest_size)) {
-    if (dest) {
-      memcpy(dest, ADD_TO_POINTER(din->src, din->current), dest_size);
-    }
-    din->current += dest_size;
+  /* TODO: implement */ 
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_get_string(json_t *json_packet, char *key, char *dest, size_t max_dest_size)
+{
+
+  json_t *pstring = json_object_get(json_packet, key);
+
+  if (!pstring) {
+    freelog(LOG_ERROR, "ERROR: Unable to get string with key: %s", key);
+    return;
+  } 
+  const char *result_str = json_string_value(pstring);
+
+  if (dest && !(*get_conv_callback) (dest, max_dest_size, result_str, strlen(result_str))) {
+    freelog(LOG_ERROR, "ERROR: Unable to get string with key: %s", key);
   }
+
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_string(struct data_in *din, char *dest, size_t max_dest_size)
+void dio_get_string_old(struct data_in *din, char *dest, size_t max_dest_size)
 {
   char *c;
-  size_t ps_len;		/* length in packet, not including null */
+  size_t ps_len;               /* length in packet, not including null */
   size_t offset, remaining;
-
+ 
   assert(max_dest_size > 0 || dest == NULL);
-
+ 
   if (!enough_data(din, 1)) {
     dest[0] = '\0';
-    return;
+     return;
   }
-
+ 
   remaining = dio_input_remaining(din);
   c = ADD_TO_POINTER(din->src, din->current);
 
@@ -579,204 +676,90 @@
   }
 
   if (!din->too_short) {
-    din->current += (ps_len + 1);	/* past terminator */
+    din->current += (ps_len + 1);      /* past terminator */
   }
 }
 
+
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_bit_string(struct data_in *din, char *dest,
+void dio_get_bit_string(json_t *json_packet, char *key, char *dest,
 			size_t max_dest_size)
 {
-  int npack = 0;		/* number claimed in packet */
-  int i;			/* iterate the bytes */
-
-  assert(dest != NULL && max_dest_size > 0);
-
-  if (!enough_data(din, 1)) {
-    dest[0] = '\0';
-    return;
-  }
-
-  dio_get_uint16(din, &npack);
-  if (npack >= max_dest_size) {
-      freelog(LOG_ERROR, "Have size for %lu, got %d",
-              (unsigned long)max_dest_size, npack);
-    din->bad_bit_string = TRUE;
-    dest[0] = '\0';
-    return;
-  }
-
-  for (i = 0; i < npack;) {
-    int bit, byte_value;
-
-    dio_get_uint8(din, &byte_value);
-    for (bit = 0; bit < 8 && i < npack; bit++, i++) {
-      if (TEST_BIT(byte_value, bit)) {
-	dest[i] = '1';
-      } else {
-	dest[i] = '0';
-      }
-    }
-  }
-
-  dest[npack] = '\0';
-
-  if (din->too_short) {
-    din->bad_bit_string = TRUE;
-  }
+  /* TODO: implement */
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_tech_list(struct data_in *din, int *dest)
+void dio_get_tech_list(json_t *json_packet, char *key, int *dest)
 {
-  int i;
-
-  for (i = 0; i < MAX_NUM_TECH_LIST; i++) {
-    dio_get_uint8(din, &dest[i]);
-    if (dest[i] == A_LAST) {
-      break;
-    }
-  }
+ /* TODO: implement*/ 
 
-  for (; i < MAX_NUM_TECH_LIST; i++) {
-    dest[i] = A_LAST;
-  }
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_worklist(struct data_in *din, struct worklist *pwl)
+void dio_get_worklist(json_t *json_packet, char *key, struct worklist *pwl)
 {
-  dio_get_bool8(din, &pwl->is_valid);
-
-  if (pwl->is_valid) {
-    int i, length;
-
-    worklist_init(pwl);
-
-    dio_get_uint8(din, &length);
-    for (i = 0; i < length; i++) {
-      struct universal prod;
-      int identifier;
-      int kind;
-
-      dio_get_uint8(din, &kind);
-      dio_get_uint8(din, &identifier);
-
-      prod = universal_by_number(kind, identifier);
-      worklist_append(pwl, prod);
-    }
-  }
+  /* TODO: implement */
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_uint8_vec8(struct data_in *din, int **values, int stop_value)
+void dio_get_uint8_vec8(json_t *json_packet, char *key, int **values, int stop_value)
 {
-  int count, inx;
-
-  dio_get_uint8(din, &count);
-  if (values) {
-    *values = fc_calloc((count + 1), sizeof(**values));
-  }
-  for (inx = 0; inx < count; inx++) {
-    dio_get_uint8(din, values ? &((*values)[inx]) : NULL);
-  }
-  if (values) {
-    (*values)[inx] = stop_value;
-  }
+  /* TODO: implement */
 }
 
 /**************************************************************************
  Receive vector of uint6 values.
 **************************************************************************/
-void dio_get_uint16_vec8(struct data_in *din, int **values, int stop_value)
+void dio_get_uint16_vec8(json_t *json_packet, char *key, int **values, int stop_value)
 {
-  int count, inx;
-
-  dio_get_uint8(din, &count);
-  if (values) {
-    *values = fc_calloc((count + 1), sizeof(**values));
-  }
-  for (inx = 0; inx < count; inx++) {
-    dio_get_uint16(din, values ? &((*values)[inx]) : NULL);
-  }
-  if (values) {
-    (*values)[inx] = stop_value;
-  }
+ /* TODO: implement */
 }
 
 /**************************************************************************
   De-serialize a player diplomatic state.
 **************************************************************************/
-void dio_get_diplstate(struct data_in *din, struct player_diplstate *pds)
+void dio_get_diplstate(json_t *json_packet, char *key, struct player_diplstate *pds)
 {
-  int value = 0;
-
-  /* backward compatible order defined for this transaction */
-  dio_get_uint8(din, &value);
-  pds->type = value;
-  dio_get_uint16(din, &pds->turns_left);
-  dio_get_uint16(din, &pds->contact_turns_left);
-  dio_get_uint8(din, &pds->has_reason_to_cancel);
-  dio_get_uint16(din, &pds->first_contact_turn);
-  value = 0;
-  dio_get_uint8(din, &value);
-  pds->max_state = value;
+  /* TODO: implement */
 }
 
 /**************************************************************************
   Serialize a player diplomatic state.
 **************************************************************************/
-void dio_put_diplstate(struct data_out *dout,
-		       const struct player_diplstate *pds)
+void dio_put_diplstate(struct data_out *dout, char *key,
+		       const struct player_diplstate *pds, int size)
 {
-  /* backward compatible order defined for this transaction */
-  dio_put_uint8(dout, pds->type);
-  dio_put_uint16(dout, pds->turns_left);
-  dio_put_uint16(dout, pds->contact_turns_left);
-  dio_put_uint8(dout, pds->has_reason_to_cancel);
-  dio_put_uint16(dout, pds->first_contact_turn);
-  dio_put_uint8(dout, pds->max_state);
+  int i;
+
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(pds[i].type));
+  }
+  
+  json_object_set_new(dout->json, key, array);
 }
 
 /**************************************************************************
   De-serialize a requirement.
 **************************************************************************/
-void dio_get_requirement(struct data_in *din, struct requirement *preq)
+void dio_get_requirement(json_t *json_packet, char *key, struct requirement *preq)
 {
-  int type, range, value;
-  bool survives, negated;
-
-  dio_get_uint8(din, &type);
-  dio_get_sint32(din, &value);
-  dio_get_uint8(din, &range);
-  dio_get_bool8(din, &survives);
-  dio_get_bool8(din, &negated);
-
-  *preq = req_from_values(type, range, survives, negated, value);
+  /* TODO: implement */
 }
 
 /**************************************************************************
   Serialize a requirement.
 **************************************************************************/
-void dio_put_requirement(struct data_out *dout, const struct requirement *preq)
+void dio_put_requirement(struct data_out *dout, char *key, const struct requirement *preq, int size)
 {
-  int type, range, value;
-  bool survives, negated;
-
-  req_get_values(preq, &type, &range, &survives, &negated, &value);
-
-  dio_put_uint8(dout, type);
-  dio_put_sint32(dout, value);
-  dio_put_uint8(dout, range);
-  dio_put_bool8(dout, survives);
-  dio_put_bool8(dout, negated);
+  /* TODO: implement */
 }
 
diff -Nurd -X.diff_ignore freeciv/common/dataio.h freeciv/common/dataio.h
--- freeciv/common/dataio.h	2012-05-16 20:56:43.000000000 +0300
+++ freeciv/common/dataio.h	2012-05-16 22:24:13.000000000 +0300
@@ -14,6 +14,7 @@
 #define FC__DATAIO_H
 
 #include "shared.h"		/* bool type */
+#include <jansson.h>
 
 struct worklist;
 struct player_diplstate;
@@ -29,6 +30,7 @@
 
 struct data_out {
   void *dest;
+  json_t *json;
   size_t dest_size, used, current;
   bool too_short;		/* set to 1 if try to read past end */
 };
@@ -53,60 +55,76 @@
 
 /* gets */
 
-void dio_get_uint8(struct data_in *din, int *dest);
-void dio_get_uint16(struct data_in *din, int *dest);
-void dio_get_uint32(struct data_in *din, int *dest);
+void dio_get_uint8(json_t *json_packet, char *key, int *dest);
+void dio_get_uint16(json_t *json_packet, char *key, int *dest);
+void dio_get_uint32(json_t *json_packet, char *key, int *dest);
+void dio_get_uint16_old(struct data_in *din, int *dest);
+void dio_get_uint8_old(struct data_in *din, int *dest);
 
-void dio_get_sint8(struct data_in *din, int *dest);
-void dio_get_sint16(struct data_in *din, int *dest);
-#define dio_get_sint32(d,v) dio_get_uint32(d,v)
+void dio_get_sint8(json_t *json_packet, char *key, int *dest);
+void dio_get_sint16(json_t *json_packet, char *key, int *dest);
+#define dio_get_sint32(d,v,x) dio_get_uint32(d,v,x)
 
 
-void dio_get_bool8(struct data_in *din, bool *dest);
-void dio_get_bool32(struct data_in *din, bool *dest);
-void dio_get_memory(struct data_in *din, void *dest, size_t dest_size);
-void dio_get_string(struct data_in *din, char *dest, size_t max_dest_size);
-void dio_get_bit_string(struct data_in *din, char *dest,
+void dio_get_bool8(json_t *json_packet, char *key, bool *dest);
+void dio_get_bool32(json_t *json_packet, char *key, bool *dest);
+void dio_get_memory(json_t *json_packet, char *key, void *dest, size_t dest_size);
+void dio_get_string(json_t *json_packet, char *key, char *dest, size_t max_dest_size);
+void dio_get_string_old(struct data_in *din, char *dest, size_t max_dest_size);
+void dio_get_bit_string(json_t *json_packet, char *key, char *dest,
 			size_t max_dest_size);
-void dio_get_tech_list(struct data_in *din, int *dest);
-void dio_get_worklist(struct data_in *din, struct worklist *pwl);
-void dio_get_diplstate(struct data_in *din, struct player_diplstate *pds);
-void dio_get_requirement(struct data_in *din, struct requirement *preq);
+void dio_get_tech_list(json_t *json_packet, char *key, int *dest);
+void dio_get_worklist(json_t *json_packet, char *key, struct worklist *pwl);
+void dio_get_diplstate(json_t *json_packet, char *key, struct player_diplstate *pds);
+void dio_get_requirement(json_t *json_packet, char *key, struct requirement *preq);
 
-void dio_get_uint8_vec8(struct data_in *din, int **values, int stop_value);
-void dio_get_uint16_vec8(struct data_in *din, int **values, int stop_value);
+void dio_get_uint8_vec8(json_t *json_packet, char *key, int **values, int stop_value);
+void dio_get_uint16_vec8(json_t *json_packet, char *key, int **values, int stop_value);
 
 /* Should be a function but we need some macro magic. */
 #define DIO_BV_GET(pdin, bv) \
   dio_get_memory((pdin), (bv).vec, sizeof((bv).vec))
 
 /* puts */
-void dio_put_uint8(struct data_out *dout, int value);
-void dio_put_uint16(struct data_out *dout, int value);
-void dio_put_uint32(struct data_out *dout, int value);
+void dio_put_uint8(struct data_out *dout, char *key, int value);
+void dio_put_uint8_old(struct data_out *dout, int value);
+void dio_put_uint16(struct data_out *dout, char *key, int value);
+void dio_put_uint32(struct data_out *dout, char *key, int value);
+void dio_put_uint16_old(struct data_out *dout, int value);
 
-#define dio_put_sint8(d,v) dio_put_uint8(d,v)
-#define dio_put_sint16(d,v) dio_put_uint16(d,v)
-#define dio_put_sint32(d,v) dio_put_uint32(d,v)
+void dio_put_array_uint8(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_uint32(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint8(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint16(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint32(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_bool8(struct data_out *dout, char *key, bool *values, int size);
 
-void dio_put_bool8(struct data_out *dout, bool value);
-void dio_put_bool32(struct data_out *dout, bool value);
+#define dio_put_sint8(d,k,v) dio_put_uint8(d,k,v)
+#define dio_put_sint16(d,k,v) dio_put_uint16(d,k,v)
+#define dio_put_sint32(d,k,v) dio_put_uint32(d,k,v)
 
-void dio_put_memory(struct data_out *dout, const void *value, size_t size);
-void dio_put_string(struct data_out *dout, const char *value);
-void dio_put_bit_string(struct data_out *dout, const char *value);
-void dio_put_city_map(struct data_out *dout, const char *value);
-void dio_put_tech_list(struct data_out *dout, const int *value);
-void dio_put_worklist(struct data_out *dout, const struct worklist *pwl);
-void dio_put_diplstate(struct data_out *dout,
-		       const struct player_diplstate *pds);
-void dio_put_requirement(struct data_out *dout, const struct requirement *preq);
+void dio_put_bool8(struct data_out *dout, char *key, bool value);
+void dio_put_bool32(struct data_out *dout, char *key, bool value);
+
+void dio_put_memory(struct data_out *dout, char *key, const void *value, size_t size);
+void dio_put_string(struct data_out *dout, char *key, const char *value);
+void dio_put_bit_string(struct data_out *dout, char *key, const char *value);
+void dio_put_city_map(struct data_out *dout, char *key, const char *value);
+void dio_put_tech_list(struct data_out *dout, char *key, const int *value);
+void dio_put_worklist(struct data_out *dout, char *key, const struct worklist *pwl);
+void dio_put_diplstate(struct data_out *dout, char *key,
+		       const struct player_diplstate *pds, int size);
+void dio_put_requirement(struct data_out *dout, char *key, const struct requirement *preq, int size);
+
+void dio_put_uint8_vec8(struct data_out *dout, char *key, int *values, int stop_value);
+void dio_put_uint16_vec8(struct data_out *dout, char *key, int *values, int stop_value);
+void dio_put_string_old(struct data_out *dout, const char *value);
+void dio_put_memory_old(struct data_out *dout, const void *value, size_t size);
+void dio_put_string_array(struct data_out *dout, char *key, const char *value, int size);
 
-void dio_put_uint8_vec8(struct data_out *dout, int *values, int stop_value);
-void dio_put_uint16_vec8(struct data_out *dout, int *values, int stop_value);
 
 /* Should be a function but we need some macro magic. */
-#define DIO_BV_PUT(pdout, bv) \
-  dio_put_memory((pdout), (bv).vec, sizeof((bv).vec))
+#define DIO_BV_PUT(pdout, type, bv) \
+  dio_put_memory((pdout), type, (bv).vec, sizeof((bv).vec))
 
 #endif  /* FC__PACKETS_H */
diff -Nurd -X.diff_ignore freeciv/common/generate_packets.py freeciv/common/generate_packets.py
--- freeciv/common/generate_packets.py	2012-05-16 22:19:49.000000000 +0300
+++ freeciv/common/generate_packets.py	2012-05-16 22:24:13.000000000 +0300
@@ -250,7 +250,7 @@
         if self.is_array==1:
             tmp="real_packet->%(name)s[i] = %(name)s[i]"%self.__dict__
             return '''  {
-    int i;
+    int i; /* dette er for put. */
 
     for (i = 0; i < %(array_size_u) s; i++) {
       %(tmp)s;
@@ -338,40 +338,42 @@
     # Returns code which put this field.
     def get_put(self):
         if self.dataio_type=="bitvector":
-            return "DIO_BV_PUT(&dout, packet->%(name)s);"%self.__dict__
+            return "DIO_BV_PUT(&dout, \"%(name)s\", packet->%(name)s);"%self.__dict__
 
         if self.struct_type=="float" and not self.is_array:
-            return "  dio_put_uint32(&dout, (int)(real_packet->%(name)s * %(float_factor)d));"%self.__dict__
+            return "  dio_put_uint32(&dout, \"%(name)s\", (int)(real_packet->%(name)s * %(float_factor)d));"%self.__dict__
         
         if self.dataio_type in ["worklist"]:
-            return "  dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s);"%self.__dict__
+            return "  dio_put_%(dataio_type)s(&dout, \"%(name)s\", &real_packet->%(name)s);"%self.__dict__
 
         if self.dataio_type in ["memory"]:
-            return "  dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
+            return "  dio_put_%(dataio_type)s(&dout, \"%(name)s\", &real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
         
         arr_types=["string","bit_string","city_map","tech_list"]
         if (self.dataio_type in arr_types and self.is_array==1) or \
            (self.dataio_type not in arr_types and self.is_array==0):
-            return "  dio_put_%(dataio_type)s(&dout, real_packet->%(name)s);"%self.__dict__
-        if self.is_struct:
-            c="dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s[i]);"%self.__dict__
-        elif self.dataio_type=="string":
-            c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i]);"%self.__dict__
+            return "  dio_put_%(dataio_type)s(&dout, \"%(name)s\", real_packet->%(name)s);"%self.__dict__
+        if self.dataio_type=="string":
             array_size_u=self.array_size1_u
+	    self.__dict__["array_size_u"] = array_size_u
+            c=" /*not supported yet... dio_put_%(dataio_type)s_array(&dout, \"%(name)s\", (char *)real_packet->%(name)s, %(array_size_u)s);*/ "%self.__dict__
 
         elif self.struct_type=="float":
-            c="  dio_put_uint32(&dout, (int)(real_packet->%(name)s[i] * %(float_factor)d));"%self.__dict__
+            #c="  dio_put_uint32(&dout, \"%(name)s\", (int)(real_packet->%(name)s[i] * %(float_factor)d));"%self.__dict__
+	    c = " /* %(name)s not supported yet */"%self.__dict__
+        elif self.struct_type=="bool":
+            c="dio_put_array_%(dataio_type)s(&dout, \"%(name)s\", (bool*)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
+        elif self.dataio_type=="diplstate":
+            c="dio_put_%(dataio_type)s(&dout, \"%(name)s\", (struct player_diplstate*)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
+        elif self.dataio_type=="requirement":
+            c="dio_put_%(dataio_type)s(&dout, \"%(name)s\", (struct requirement*)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
         else:
-            c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i]);"%self.__dict__
+            c="dio_put_array_%(dataio_type)s(&dout, \"%(name)s\", (int*)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
 
         if not self.diff:
             return '''
     {
-      int i;
-
-      for (i = 0; i < %(array_size_u)s; i++) {
         %(c)s
-      }
     } '''%self.get_dict(vars())
         else:
             return '''
@@ -413,45 +415,45 @@
             return '''{
   int tmp;
   
-  dio_get_uint32(&din, &tmp);
+  dio_get_uint32(pc->json_packet, "%(name)s", &tmp);
   real_packet->%(name)s = (float)(tmp) / %(float_factor)d.0;
 }'''%self.__dict__
 
         if self.dataio_type=="bitvector":
-            return "DIO_BV_GET(&din, real_packet->%(name)s);"%self.__dict__
+            return " /* not supported yet. DIO_BV_GET(pc->json_packet, real_packet->%(name)s);*/"%self.__dict__
         if self.dataio_type in ["string","bit_string","city_map"] and \
            self.is_array!=2:
-            return "dio_get_%(dataio_type)s(&din, real_packet->%(name)s, sizeof(real_packet->%(name)s));"%self.__dict__
+            return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", real_packet->%(name)s, sizeof(real_packet->%(name)s));"%self.__dict__
         if self.is_struct and self.is_array==0:
-            return "dio_get_%(dataio_type)s(&din, &real_packet->%(name)s);"%self.__dict__
+            return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s);"%self.__dict__
         if self.dataio_type in ["tech_list"]:
-            return "dio_get_%(dataio_type)s(&din, real_packet->%(name)s);"%self.__dict__
+            return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", real_packet->%(name)s);"%self.__dict__
         if not self.is_array:
             if self.struct_type=="bool":
-                return "dio_get_%(dataio_type)s(&din, &real_packet->%(name)s);"%self.__dict__
+                return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s);"%self.__dict__
             return '''{
   int readin;
 
-  dio_get_%(dataio_type)s(&din, &readin);
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", &readin);
   real_packet->%(name)s = readin;
 }'''%self.__dict__
 
         if self.is_struct:
-            c="dio_get_%(dataio_type)s(&din, &real_packet->%(name)s[i]);"%self.__dict__
+            c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s[i]);"%self.__dict__
         elif self.dataio_type=="string":
-            c="dio_get_%(dataio_type)s(&din, real_packet->%(name)s[i], sizeof(real_packet->%(name)s[i]));"%self.__dict__
+            c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", real_packet->%(name)s[i], sizeof(real_packet->%(name)s[i]));"%self.__dict__
         elif self.struct_type=="float":
             c='''int tmp;
 
-    dio_get_uint32(&din, &tmp);
+    dio_get_uint32(pc->json_packet, "%(name)s", &tmp);
     real_packet->%(name)s[i] = (float)(tmp) / %(float_factor)d.0;'''%self.__dict__
         elif self.struct_type=="bool":
-            c="dio_get_%(dataio_type)s(&din, &real_packet->%(name)s[i]);"%self.__dict__
+            c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s[i]);"%self.__dict__
         else:
             c='''{
   int readin;
 
-  dio_get_%(dataio_type)s(&din, &readin);
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", &readin);
   real_packet->%(name)s[i] = readin;
 }'''%self.__dict__
         if self.is_array==2:
@@ -471,11 +473,11 @@
             else:
                 extra=""
             if self.dataio_type=="memory":
-                return '''%(extra)s
-  dio_get_%(dataio_type)s(&din, real_packet->%(name)s, %(array_size_u)s);'''%self.get_dict(vars())
+                return ''' /* not supported yet. %(extra)s
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", real_packet->%(name)s, %(array_size_u)s);*/'''%self.get_dict(vars())
             return '''
 {
-  int i;
+   int i;
 %(extra)s
   for (i = 0; i < %(array_size_u)s; i++) {
     %(c)s
@@ -486,7 +488,7 @@
 for (;;) {
   int i;
 
-  dio_get_uint8(&din, &i);
+  dio_get_uint8(pc->json_packet, "%(name)s", &i);
   if(i == 255) {
     break;
   }
@@ -784,7 +786,7 @@
 %(fl)s%(s)s<pre2>    return 0;
   }
 
-  DIO_BV_PUT(&dout, fields);
+  DIO_BV_PUT(&dout, \"fields\", fields);
 '''%self.get_dict(vars())
 
         for field in self.key_fields:
@@ -824,7 +826,7 @@
   struct hash_table **hash = &pc->phs.received[type];
   struct %(packet_name)s *clone;
 '''
-            delta_body1="\n  DIO_BV_GET(&din, fields);\n"
+            delta_body1="\n  DIO_BV_GET(pc->json_packet, fields);\n"
             body1=""
             for field in self.key_fields:
                 body1=body1+prefix("  ",field.get_get())+"\n"
diff -Nurd -X.diff_ignore freeciv/common/packets.c freeciv/common/packets.c
--- freeciv/common/packets.c	2012-05-16 20:56:43.000000000 +0300
+++ freeciv/common/packets.c	2012-05-16 22:24:13.000000000 +0300
@@ -31,6 +31,8 @@
 #include "mem.h"
 #include "support.h"
 
+#include <jansson.h>
+
 #include "packets.h"
 
 #ifdef USE_COMPRESSION
@@ -330,7 +332,7 @@
   }
 
   dio_input_init(&din, pc->buffer->data, pc->buffer->ndata);
-  dio_get_uint16(&din, &len_read);
+  dio_get_uint16_old(&din, &len_read);
 
   /* The non-compressed case */
   whole_packet_len = len_read;
@@ -434,10 +436,36 @@
     return NULL;
   }
 
-  dio_get_uint8(&din, &utype.itype);
+  /* Parse JSON packet. */
+  json_error_t error;
+  
+  dio_get_uint8_old(&din, &utype.itype);
+
+  dio_get_string_old(&din, (char*)pc->buffer->data, pc->buffer->ndata);
+ 
+  pc->json_packet = json_loads((char*)pc->buffer->data, 0, &error);
+
+  memmove(pc->buffer->data, pc->buffer->data, pc->buffer->ndata);
+  pc->buffer->ndata = 0;
+
+  if (!pc->json_packet) {
+    freelog(LOG_ERROR, "ERROR: Unable to parse packet: %s", pc->buffer->data);
+    return NULL;
+  }
+
+  json_t *pint = json_object_get(pc->json_packet, "type");
+
+  if (!pint) {
+    freelog(LOG_ERROR, "ERROR: Unable to get packet type.");
+    return NULL;
+  } 
+
+  json_int_t packet_type = json_integer_value(pint);
+  utype.type = packet_type;
 
   freelog(BASIC_PACKET_LOG_LEVEL, "got packet type=(%s)%d len=%d",
-	  get_packet_name(utype.type), utype.itype, whole_packet_len);
+	  get_packet_name(utype.type), utype.type, whole_packet_len);
+
 
   *ptype = utype.type;
   *presult = TRUE;
@@ -501,10 +529,11 @@
 void remove_packet_from_buffer(struct socket_packet_buffer *buffer)
 {
   struct data_in din;
-  int len;
-
+  int len, type;
+ 
   dio_input_init(&din, buffer->data, buffer->ndata);
-  dio_get_uint16(&din, &len);
+  dio_get_uint16_old(&din, &len);
+  //dio_get_uint8_old(&din, &type);
   memmove(buffer->data, buffer->data + len, buffer->ndata - len);
   buffer->ndata -= len;
   freelog(LOG_DEBUG, "remove_packet_from_buffer: remove %d; remaining %d",
@@ -512,51 +541,6 @@
 }
 
 /**************************************************************************
-  ...
-**************************************************************************/
-void check_packet(struct data_in *din, struct connection *pc)
-{
-  size_t rem = dio_input_remaining(din);
-
-  if (din->bad_string || din->bad_bit_string || rem != 0) {
-    char from[MAX_LEN_ADDR + MAX_LEN_NAME + 128];
-    int type, len;
-
-    assert(pc != NULL);
-    my_snprintf(from, sizeof(from), " from %s", conn_description(pc));
-
-    dio_input_rewind(din);
-    dio_get_uint16(din, &len);
-    dio_get_uint8(din, &type);
-
-    if (din->bad_string) {
-      freelog(LOG_ERROR,
-	      "received bad string in packet (type %d, len %d)%s",
-	      type, len, from);
-    }
-
-    if (din->bad_bit_string) {
-      freelog(LOG_ERROR,
-	      "received bad bit string in packet (type %d, len %d)%s",
-	      type, len, from);
-    }
-
-    if (din->too_short) {
-      freelog(LOG_ERROR, "received short packet (type %d, len %d)%s",
-	      type, len, from);
-    }
-
-    if (rem > 0) {
-      /* This may be ok, eg a packet from a newer version with extra info
-       * which we should just ignore */
-      freelog(LOG_VERBOSE,
-	      "received long packet (type %d, len %d, rem %lu)%s", type,
-	      len, (unsigned long)rem, from);
-    }
-  }
-}
-
-/**************************************************************************
  Updates pplayer->attribute_block according to the given packet.
 **************************************************************************/
 void generic_handle_player_attribute_chunk(struct player *pplayer,
diff -Nurd -X.diff_ignore freeciv/common/packets.h freeciv/common/packets.h
--- freeciv/common/packets.h	2012-05-16 20:56:43.000000000 +0300
+++ freeciv/common/packets.h	2012-05-16 22:24:13.000000000 +0300
@@ -29,6 +29,7 @@
 #include "team.h"
 #include "unittype.h"
 #include "worklist.h"
+#include <jansson.h>
 
 
 #define MAX_LEN_USERNAME        10        /* see below */
@@ -100,41 +101,38 @@
 
 #define SEND_PACKET_START(type) \
   unsigned char buffer[MAX_LEN_PACKET]; \
+  char* json_buffer = NULL; \
   struct data_out dout; \
+  dout.json = json_object(); \
   \
   dio_output_init(&dout, buffer, sizeof(buffer)); \
-  dio_put_uint16(&dout, 0); \
-  dio_put_uint8(&dout, type);
+  dio_put_uint16_old(&dout, 0); \
+  dio_put_uint8_old(&dout, type); \
+  \
+  dio_put_uint8(&dout, "pid", type);
 
 #define SEND_PACKET_END \
   { \
+    json_buffer = json_dumps(dout.json, JSON_COMPACT | JSON_ENSURE_ASCII); \
+    if (json_buffer) {  \
+      dio_put_string_old(&dout, json_buffer);	  \
+    } \
     size_t size = dio_output_used(&dout); \
-    \
     dio_output_rewind(&dout); \
-    dio_put_uint16(&dout, size); \
+    dio_put_uint16_old(&dout, size); \
+	  \
+    free(json_buffer); \
+    json_decref(dout.json); \
     return send_packet_data(pc, buffer, size); \
   }
 
 #define RECEIVE_PACKET_START(type, result) \
-  struct data_in din; \
-  struct type *result = fc_malloc(sizeof(*result)); \
-  \
-  dio_input_init(&din, pc->buffer->data, 2); \
-  { \
-    int size; \
-  \
-    dio_get_uint16(&din, &size); \
-    dio_input_init(&din, pc->buffer->data, MIN(size, pc->buffer->ndata)); \
-  } \
-  dio_get_uint16(&din, NULL); \
-  dio_get_uint8(&din, NULL);
+  struct type *result = fc_malloc(sizeof(*result));
 
 #define RECEIVE_PACKET_END(result) \
-  check_packet(&din, pc); \
-  remove_packet_from_buffer(pc->buffer); \
+  json_decref(pc->json_packet); \
   return result;
 
 int send_packet_data(struct connection *pc, unsigned char *data, int len);
-void check_packet(struct data_in *din, struct connection *pc);
 
 #endif  /* FC__PACKETS_H */
diff -Nurd -X.diff_ignore freeciv/configure.ac freeciv/configure.ac
--- freeciv/configure.ac	2012-05-16 22:23:36.000000000 +0300
+++ freeciv/configure.ac	2012-05-16 22:24:19.000000000 +0300
@@ -710,7 +710,7 @@
 
     AC_CHECK_FUNC(pow)
     if test $ac_cv_func_pow = no; then
-        AC_CHECK_LIB(m, pow, SERVER_LIBS="$SERVER_LIBS -lm -lssl",
+        AC_CHECK_LIB(m, pow, SERVER_LIBS="$SERVER_LIBS -lm -lssl -ljansson",
 		 AC_MSG_ERROR(Did not find math lib!))
     fi
 fi
diff -Nurd -X.diff_ignore freeciv/server/handchat.c freeciv/server/handchat.c
--- freeciv/server/handchat.c	2012-05-16 20:56:43.000000000 +0300
+++ freeciv/server/handchat.c	2012-05-16 22:25:02.000000000 +0300
@@ -20,6 +20,8 @@
 #include <stdio.h>
 #include <string.h>
 
+#include <glib.h>
+
 /* utility */
 #include "fcintl.h"
 #include "log.h"
@@ -180,7 +182,7 @@
   avoiding sending both original and echo if sender is in destination
   set.
 **************************************************************************/
-void handle_chat_msg_req(struct connection *pconn, char *message)
+void handle_chat_msg_req(struct connection *pconn, char *raw_message)
 {
   char sender_name[MAX_LEN_CHAT_NAME], chat[MAX_LEN_MSG];
   char *cp;
@@ -188,13 +190,26 @@
 
   /* this loop to prevent players from sending multiple lines
    * which can be abused */
-  for (cp = message; *cp != '\0'; cp++) {
-    if (*cp == '\n' || *cp == '\r') {
+  for (cp = raw_message; *cp != '\0'; cp++) {
+    if (*cp == '\n' || *cp == '\r' || *cp == '<' || *cp == '>' || *cp == '"' || *cp == '\'') {
       *cp='\0';
       break;
     }
   }
 
+  char* unesc_message = g_uri_unescape_string(raw_message, NULL);
+  char message[MAX_LEN_MSG];
+
+  if (unesc_message) {
+      char result_buf[MAX_LEN_MSG];
+      convert_string(unesc_message,
+ 	  	       "latin1",
+		       "UTF-8",
+		       (char*)message, sizeof(message));
+  } else {
+    return;
+  }
+
   /* Server commands are prefixed with '/', which is an obvious
      but confusing choice: even before this feature existed,
      novice players were trying /who, /nick etc.
@@ -339,4 +354,5 @@
   con_puts(C_COMMENT, chat);
   send_chat_msg(game.est_connections, pconn, FTC_PUBLIC_MSG, NULL,
                 "%s", chat);
+  g_free(unesc_message);
 }
diff -Nurd -X.diff_ignore freeciv/server/sernet.c freeciv/server/sernet.c
--- freeciv/server/sernet.c	2012-05-16 22:07:34.000000000 +0300
+++ freeciv/server/sernet.c	2012-05-16 22:25:02.000000000 +0300
@@ -1233,7 +1233,7 @@
      * Generally we just want to run select again. */
   }
 
-  if (FD_ISSET(socklan, &readfs)) {
+  /*if (FD_ISSET(socklan, &readfs)) {
     if (0 < recvfrom(socklan, msgbuf, sizeof(msgbuf), 0, NULL, NULL)) {
       dio_input_init(&din, msgbuf, 1);
       dio_get_uint8(&din, &type);
@@ -1245,7 +1245,7 @@
                 "Received invalid request for server LAN announcement.");
       }
     }
-  }
+  }*/
 }
 
 /********************************************************************
@@ -1336,13 +1336,13 @@
               srvarg.port );
 
   dio_output_init(&dout, buffer, sizeof(buffer));
-  dio_put_uint8(&dout, SERVER_LAN_VERSION);
-  dio_put_string(&dout, hostname);
-  dio_put_string(&dout, port);
-  dio_put_string(&dout, version);
-  dio_put_string(&dout, status);
-  dio_put_string(&dout, players);
-  dio_put_string(&dout, get_meta_message_string());
+  dio_put_uint8(&dout, "ver", SERVER_LAN_VERSION);
+  dio_put_string(&dout, "host", hostname);
+  dio_put_string(&dout, "port", port);
+  dio_put_string(&dout, "version", version);
+  dio_put_string(&dout, "status", status);
+  dio_put_string(&dout, "players", players);
+  dio_put_string(&dout, "msg", get_meta_message_string());
   size = dio_output_used(&dout);
 
   /* Sending packet to client with the information gathered above. */
diff -Nurd -X.diff_ignore freeciv/server/srv_main.c freeciv/server/srv_main.c
--- freeciv/server/srv_main.c	2012-05-16 22:23:36.000000000 +0300
+++ freeciv/server/srv_main.c	2012-05-16 22:25:02.000000000 +0300
@@ -1316,21 +1316,21 @@
 	    _("Warning: rejecting old client %s"), conn_description(pconn));
 
     dio_output_init(&dout, buffer, sizeof(buffer));
-    dio_put_uint16(&dout, 0);
+    dio_put_uint16(&dout, "msg", 0);
 
     /* 1 == PACKET_LOGIN_REPLY in the old client */
-    dio_put_uint8(&dout, 1);
+    dio_put_uint8(&dout, "msg", 1);
 
-    dio_put_bool32(&dout, FALSE);
-    dio_put_string(&dout, _("Your client is too old. To use this server, "
+    dio_put_bool32(&dout, "msg", FALSE);
+    dio_put_string(&dout, "msg", _("Your client is too old. To use this server, "
 			    "please upgrade your client to a "
 			    "Freeciv 2.2 or later."));
-    dio_put_string(&dout, "");
+    dio_put_string(&dout, "msg", "");
 
     {
       size_t size = dio_output_used(&dout);
       dio_output_rewind(&dout);
-      dio_put_uint16(&dout, size);
+      dio_put_uint16(&dout, "size",  size);
 
       /* 
        * Use send_connection_data instead of send_packet_data to avoid
@@ -1655,15 +1655,17 @@
 {
   struct nation_type *new_nation;
   struct player *pplayer = player_by_number(player_no);
-
+  freelog(LOG_ERROR, "hepp1");
   if (!pplayer || !can_conn_edit_players_nation(pc, pplayer)) {
     return;
   }
+  freelog(LOG_ERROR, "hepp2");
 
   new_nation = nation_by_number(nation_no);
 
   if (new_nation != NO_NATION_SELECTED) {
     char message[1024];
+    freelog(LOG_ERROR, "hepp3");
 
     /* check sanity of the packet sent by client */
     if (city_style < 0 || city_style >= game.control.styles_count
@@ -1672,6 +1674,7 @@
     }
 
     if (!new_nation->is_available) {
+    freelog(LOG_ERROR, "hepp4");
       notify_conn(pplayer->connections, NULL, E_NATION_SELECTED,
                   FTC_SERVER_INFO, NULL,
 		  _("%s nation is not available in this scenario."),
@@ -1697,6 +1700,7 @@
 
     name[0] = my_toupper(name[0]);
     sz_strlcpy(pplayer->name, name);
+    freelog(LOG_ERROR, "hepp5");
 
     notify_conn(NULL, NULL, E_NATION_SELECTED, FTC_SERVER_INFO, NULL,
 		_("%s is the %s ruler %s."),
@@ -1708,6 +1712,7 @@
     pplayer->city_style = city_style;
   }
 
+  freelog(LOG_ERROR, "hepp6");
   (void) player_set_nation(pplayer, new_nation);
   send_player_info_c(pplayer, game.est_connections);
 }
