diff -Nurd -X.diff_ignore freeciv/common/connection.h freeciv/common/connection.h
--- freeciv/common/connection.h	2012-05-23 04:02:12.000000000 +0300
+++ freeciv/common/connection.h	2012-05-23 04:02:28.000000000 +0300
@@ -34,10 +34,12 @@
 
 #include "fc_types.h"
 
+#include <jansson.h>
+
 struct hash_table;
 struct timer_list;
 
-#define MAX_LEN_PACKET   4096
+#define MAX_LEN_PACKET   65536
 
 #define MAX_LEN_BUFFER   (MAX_LEN_PACKET * 128)
 #define MAX_LEN_CAPSTR    512
@@ -126,6 +128,7 @@
   struct socket_packet_buffer *buffer;
   struct socket_packet_buffer *send_buffer;
   struct timer *last_write;
+  json_t *json_packet;
 
   double ping_time;
   
diff -Nurd -X.diff_ignore freeciv/common/dataio.c freeciv/common/dataio.c
--- freeciv/common/dataio.c	2012-05-23 03:55:12.000000000 +0300
+++ freeciv/common/dataio.c	2012-05-23 04:02:28.000000000 +0300
@@ -198,8 +198,13 @@
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_uint8(struct data_out *dout, int value)
+void dio_put_uint8(struct data_out *dout, char *key, int value)
 {
+  json_object_set_new(dout->json, key, json_integer(value));
+}
+
+void dio_put_uint8_old(struct data_out *dout, int value)
+ {
   if (enough_space(dout, 1)) {
     uint8_t x = value;
 
@@ -212,7 +217,7 @@
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_uint16(struct data_out *dout, int value)
+void dio_put_uint16_old(struct data_out *dout, int value)
 {
   if (enough_space(dout, 2)) {
     uint16_t x = htons(value);
@@ -226,6 +231,15 @@
 /**************************************************************************
 ...
 **************************************************************************/
+void dio_put_uint16(struct data_out *dout, char *key, int value)
+{
+  json_object_set_new(dout->json, key, json_integer(value));
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+#if 0
 void dio_put_uint32(struct data_out *dout, int value)
 {
   if (enough_space(dout, 4)) {
@@ -236,10 +250,20 @@
     dout->current += 4;
   }
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_uint32(struct data_out *dout, char *key, int value)
+{
+  json_object_set_new(dout->json, key, json_integer(value));
+}
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_put_bool8(struct data_out *dout, bool value)
 {
   if (value != TRUE && value != FALSE) {
@@ -249,10 +273,20 @@
 
   dio_put_uint8(dout, value ? 1 : 0);
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_bool8(struct data_out *dout, char *key, bool value)
+{
+  json_object_set_new(dout->json, key, value ? json_true() : json_false());
+}
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_put_bool32(struct data_out *dout, bool value)
 {
   if (value != TRUE && value != FALSE) {
@@ -262,10 +296,20 @@
 
   dio_put_uint32(dout, value ? 1 : 0);
 }
+#endif
 
 /**************************************************************************
 ...
 **************************************************************************/
+void dio_put_bool32(struct data_out *dout, char *key, bool value)
+{
+  json_object_set_new(dout->json, key, value ? json_true() : json_false());
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+#if 0
 void dio_put_uint8_vec8(struct data_out *dout, int *values, int stop_value)
 {
   size_t count;
@@ -284,10 +328,20 @@
     }
   }
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_uint8_vec8(struct data_out *dout, char *key, int *values, int stop_value)
+{
+  /* TODO: implement. */
+}
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_put_uint16_vec8(struct data_out *dout, int *values, int stop_value)
 {
   size_t count;
@@ -306,11 +360,29 @@
     }
   }
 }
+#endif
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_memory(struct data_out *dout, const void *value, size_t size)
+void dio_put_uint16_vec8(struct data_out *dout, char *key, int *values,
+                         int stop_value)
+{
+  /* TODO: implement. */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_memory(struct data_out *dout, char *key, const void *value, size_t size)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_memory_old(struct data_out *dout, const void *value, size_t size)
 {
   if (enough_space(dout, size)) {
     memcpy(ADD_TO_POINTER(dout->dest, dout->current), value, size);
@@ -321,24 +393,59 @@
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_put_string(struct data_out *dout, const char *value)
+void dio_put_string(struct data_out *dout, char *key, const char *value)
+{
+  json_object_set_new(dout->json, key, json_string(value));
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_string_array(struct data_out *dout, char *key, 
+		          const char *value, int size)
+{
+  int i;
+
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    if (value != NULL) {
+      json_array_append_new(array, json_string(value + i));
+    }
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_string_old(struct data_out *dout, const char *value)
 {
   if (put_conv_callback) {
     size_t length;
     char *buffer;
 
     if ((buffer = (*put_conv_callback) (value, &length))) {
-      dio_put_memory(dout, buffer, length + 1);
+      dio_put_memory_old(dout, buffer, length + 1);
       free(buffer);
     }
   } else {
-    dio_put_memory(dout, value, strlen(value) + 1);
+    dio_put_memory_old(dout, value, strlen(value) + 1);
   }
 }
 
 /**************************************************************************
 ...
 **************************************************************************/
+void dio_put_bit_string(struct data_out *dout, char *key, const char *value)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+#if 0
 void dio_put_bit_string(struct data_out *dout, const char *value)
 {
   /* Note that size_t is often an unsigned type, so we must be careful
@@ -370,10 +477,12 @@
     }
   }
 }
+#endif
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_put_tech_list(struct data_out *dout, const int *value)
 {
   int i;
@@ -385,10 +494,20 @@
     }
   }
 }
+#endif
 
 /**************************************************************************
 ...
 **************************************************************************/
+void dio_put_tech_list(struct data_out *dout, char *key, const int *value)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+#if 0
 void dio_put_worklist(struct data_out *dout, const struct worklist *pwl)
 {
   int i, length = worklist_length(pwl);
@@ -401,12 +520,106 @@
     dio_put_uint8(dout, universal_number(pcp));
   }
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_worklist(struct data_out *dout, char *key, const struct worklist *pwl)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_uint8(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_uint32(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_sint8(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_sint16(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_sint32(struct data_out *dout, char *key, int *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, json_integer(values[i]));
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_put_array_bool8(struct data_out *dout, char *key, bool *values, int size)
+{
+  int i;
+  json_t *array = json_array();
+  for (i = 0; i < size; i++) {
+    json_array_append_new(array, values[i] ? json_true() : json_false());
+  }
+  
+  json_object_set_new(dout->json, key, array);
+}
 
 /**************************************************************************
  Receive uint8 value to dest. In case of failure, value stored to dest
  will be zero. Note that zero is legal value even when there is no failure.
 **************************************************************************/
-void dio_get_uint8(struct data_in *din, int *dest)
+void dio_get_uint8_old(struct data_in *din, int *dest)
 {
   if (enough_data(din, 1)) {
     if (dest) {
@@ -422,11 +635,88 @@
   }
 }
 
+void dio_get_uint8(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get uint8 with key: %s", key);
+    return;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get unit8 with key: %s", key);
+  }
+}
+
 /**************************************************************************
  Receive uint16 value to dest. In case of failure, value stored to dest
  will be zero. Note that zero is legal value even when there is no failure.
 **************************************************************************/
-void dio_get_uint16(struct data_in *din, int *dest)
+void dio_get_uint16(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get uint16 with key: %s", key);
+    return;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get unit16 with key: %s", key);
+  }
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+void dio_get_uint32(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get uint32 with key: %s", key);
+    return;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get unit32 with key: %s", key);
+  }
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+void dio_get_bit_string(json_t *json_packet, char *key, char *dest,
+ 			size_t max_dest_size)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+void dio_get_tech_list(json_t *json_packet, char *key, int *dest)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+ ..
+**************************************************************************/
+void dio_get_worklist(json_t *json_packet, char *key, struct worklist *pwl)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+ Receive uint16 value to dest. In case of failure, value stored to dest
+ will be zero. Note that zero is legal value even when there is no failure.
+**************************************************************************/
+void dio_get_uint16_old(struct data_in *din, int *dest)
 {
   if (enough_data(din, 2)) {
     if (dest) {
@@ -446,6 +736,7 @@
  Receive uint32 value to dest. In case of failure, value stored to dest
  will be zero. Note that zero is legal value even when there is no failure.
 **************************************************************************/
+#if 0
 void dio_get_uint32(struct data_in *din, int *dest)
 {
   if (enough_data(din, 4)) {
@@ -461,10 +752,12 @@
     *dest = 0;
   }
 }
+#endif
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_get_bool8(struct data_in *din, bool * dest)
 {
   int ival;
@@ -478,10 +771,30 @@
 
   *dest = (ival != 0);
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_get_bool8(json_t *json_packet, char *key, bool * dest)
+{
+  json_t *pbool = json_object_get(json_packet, key);
+
+  if (!pbool) {
+    log_error("ERROR: Unable to get bool8 with key: %s", key);
+    return;
+  } 
+  *dest = json_is_true(pbool);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get bool with key: %s", key);
+  }
+}
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_get_bool32(struct data_in *din, bool * dest)
 {
   int ival = 0;
@@ -495,10 +808,27 @@
 
   *dest = (ival != 0);
 }
+#endif
+
+void dio_get_bool32(json_t *json_packet, char *key, bool * dest)
+{
+  json_t *pbool = json_object_get(json_packet, key);
+
+  if (!pbool) {
+    log_error("ERROR: Unable to get bool32 with key: %s", key);
+    return;
+  } 
+  *dest = json_is_true(pbool);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get bool32 with key: %s", key);
+   }
+}
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_get_sint8(struct data_in *din, int *dest)
 {
   int tmp;
@@ -511,10 +841,30 @@
     *dest = tmp;
   }
 }
+#endif
 
 /**************************************************************************
 ...
 **************************************************************************/
+void dio_get_sint8(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get sint8 with key: %s", key);
+    return;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get sint8 with key: %s", key);
+  }
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+#if 0
 void dio_get_sint16(struct data_in *din, int *dest)
 {
   int tmp = 0;
@@ -527,10 +877,31 @@
     *dest = tmp;
   }
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_get_sint16(json_t *json_packet, char *key, int *dest)
+{
+  json_t *pint = json_object_get(json_packet, key);
+
+  if (!pint) {
+    log_error("ERROR: Unable to get sint16 with key: %s", key);
+    return;
+  } 
+  *dest = json_integer_value(pint);
+
+  if (!dest) {
+    log_error("ERROR: Unable to get sint16 with key: %s", key);
+  }
+
+}
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_get_memory(struct data_in *din, void *dest, size_t dest_size)
 {
   if (enough_data(din, dest_size)) {
@@ -540,11 +911,39 @@
     din->current += dest_size;
   }
 }
+#endif
 
 /**************************************************************************
 ...
 **************************************************************************/
-void dio_get_string(struct data_in *din, char *dest, size_t max_dest_size)
+void dio_get_memory(json_t *json_packet, char *key, void *dest, size_t dest_size)
+{
+  /* TODO: implement */ 
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_get_string(json_t *json_packet, char *key, char *dest, size_t max_dest_size)
+{
+  json_t *pstring = json_object_get(json_packet, key);
+
+  if (!pstring) {
+    log_error("ERROR: Unable to get string with key: %s", key);
+    return;
+  } 
+  const char *result_str = json_string_value(pstring);
+
+  if (dest && !(*get_conv_callback) (dest, max_dest_size, result_str, strlen(result_str))) {
+    log_error("ERROR: Unable to get string with key: %s", key);
+  }
+
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_get_string_old(struct data_in *din, char *dest, size_t max_dest_size)
 {
   char *c;
   size_t ps_len;		/* length in packet, not including null */
@@ -585,6 +984,7 @@
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_get_bit_string(struct data_in *din, char *dest,
 			size_t max_dest_size)
 {
@@ -626,10 +1026,12 @@
     din->bad_bit_string = TRUE;
   }
 }
+#endif
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_get_tech_list(struct data_in *din, int *dest)
 {
   int i;
@@ -645,10 +1047,12 @@
     dest[i] = A_LAST;
   }
 }
+#endif
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_get_worklist(struct data_in *din, struct worklist *pwl)
 {
   int i, length;
@@ -666,10 +1070,12 @@
     worklist_append(pwl, universal_by_number(kind, identifier));
   }
 }
+#endif
 
 /**************************************************************************
 ...
 **************************************************************************/
+#if 0
 void dio_get_uint8_vec8(struct data_in *din, int **values, int stop_value)
 {
   int count, inx;
@@ -685,10 +1091,29 @@
     (*values)[inx] = stop_value;
   }
 }
+#endif
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_get_uint8_vec8(json_t *json_packet, char *key, int **values, int stop_value)
+{
+  /* TODO: implement */
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+void dio_get_uint16_vec8(json_t *json_packet, char *key, int **values,
+                         int stop_value)
+{
+  /* TODO: implement */
+}
 
 /**************************************************************************
  Receive vector of uint6 values.
 **************************************************************************/
+#if 0
 void dio_get_uint16_vec8(struct data_in *din, int **values, int stop_value)
 {
   int count, inx;
@@ -704,10 +1129,12 @@
     (*values)[inx] = stop_value;
   }
 }
+#endif
 
 /**************************************************************************
   De-serialize a requirement.
 **************************************************************************/
+#if 0
 void dio_get_requirement(struct data_in *din, struct requirement *preq)
 {
   int type, range, value;
@@ -721,10 +1148,20 @@
 
   *preq = req_from_values(type, range, survives, negated, value);
 }
+#endif
+
+/**************************************************************************
+  ..
+**************************************************************************/
+void dio_get_requirement(json_t *json_packet, char *key, struct requirement *preq)
+{
+  /* TODO: implement */
+}
 
 /**************************************************************************
   Serialize a requirement.
 **************************************************************************/
+#if 0
 void dio_put_requirement(struct data_out *dout, const struct requirement *preq)
 {
   int type, range, value;
@@ -738,4 +1175,12 @@
   dio_put_bool8(dout, survives);
   dio_put_bool8(dout, negated);
 }
+#endif
 
+/**************************************************************************
+  ..
+**************************************************************************/
+void dio_put_requirement(struct data_out *dout, char *key, const struct requirement *preq, int size)
+{
+  /* TODO: implement */
+}
diff -Nurd -X.diff_ignore freeciv/common/dataio.h freeciv/common/dataio.h
--- freeciv/common/dataio.h	2012-05-23 03:55:12.000000000 +0300
+++ freeciv/common/dataio.h	2012-05-23 04:02:28.000000000 +0300
@@ -16,6 +16,8 @@
 #include "bitvector.h"
 #include "shared.h" /* bool type */
 
+#include <jansson.h>
+
 struct worklist;
 struct requirement;
 
@@ -29,6 +31,7 @@
 
 struct data_out {
   void *dest;
+  json_t *json;
   size_t dest_size, used, current;
   bool too_short;		/* set to 1 if try to read past end */
 };
@@ -53,6 +56,8 @@
 
 /* gets */
 
+#if 0
+
 void dio_get_uint8(struct data_in *din, int *dest);
 void dio_get_uint16(struct data_in *din, int *dest);
 void dio_get_uint32(struct data_in *din, int *dest);
@@ -75,11 +80,41 @@
 void dio_get_uint8_vec8(struct data_in *din, int **values, int stop_value);
 void dio_get_uint16_vec8(struct data_in *din, int **values, int stop_value);
 
+#else
+
+void dio_get_uint8(json_t *json_packet, char *key, int *dest);
+void dio_get_uint16(json_t *json_packet, char *key, int *dest);
+void dio_get_uint32(json_t *json_packet, char *key, int *dest);
+
+void dio_get_uint16_old(struct data_in *din, int *dest);
+void dio_get_uint8_old(struct data_in *din, int *dest);
+void dio_get_sint8(json_t *json_packet, char *key, int *dest);
+void dio_get_sint16(json_t *json_packet, char *key, int *dest);
+#define dio_get_sint32(d,v,x) dio_get_uint32(d,v,x)
+
+
+void dio_get_bool8(json_t *json_packet, char *key, bool *dest);
+void dio_get_bool32(json_t *json_packet, char *key, bool *dest);
+void dio_get_memory(json_t *json_packet, char *key, void *dest, size_t dest_size);
+void dio_get_string(json_t *json_packet, char *key, char *dest, size_t max_dest_size);
+void dio_get_string_old(struct data_in *din, char *dest, size_t max_dest_size);
+void dio_get_bit_string(json_t *json_packet, char *key, char *dest,
+ 			size_t max_dest_size);
+void dio_get_tech_list(json_t *json_packet, char *key, int *dest);
+void dio_get_worklist(json_t *json_packet, char *key, struct worklist *pwl);
+void dio_get_requirement(json_t *json_packet, char *key, struct requirement *preq);
+
+void dio_get_uint8_vec8(json_t *json_packet, char *key, int **values, int stop_value);
+void dio_get_uint16_vec8(json_t *json_packet, char *key, int **values, int stop_value);
+#endif
+
 /* Should be a function but we need some macro magic. */
 #define DIO_BV_GET(pdin, bv) \
   dio_get_memory((pdin), (bv).vec, sizeof((bv).vec))
 
 /* puts */
+
+#if 0
 void dio_put_uint8(struct data_out *dout, int value);
 void dio_put_uint16(struct data_out *dout, int value);
 void dio_put_uint32(struct data_out *dout, int value);
@@ -106,4 +141,46 @@
 #define DIO_BV_PUT(pdout, bv) \
   dio_put_memory((pdout), (bv).vec, sizeof((bv).vec))
 
+#else
+
+void dio_put_uint8(struct data_out *dout, char *key, int value);
+void dio_put_uint8_old(struct data_out *dout, int value);
+void dio_put_uint16(struct data_out *dout, char *key, int value);
+void dio_put_uint32(struct data_out *dout, char *key, int value);
+void dio_put_uint16_old(struct data_out *dout, int value);
+
+void dio_put_array_uint8(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_uint32(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint8(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint16(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_sint32(struct data_out *dout, char *key, int *values, int size);
+void dio_put_array_bool8(struct data_out *dout, char *key, bool *values, int size);
+
+#define dio_put_sint8(d,k,v) dio_put_uint8(d,k,v)
+#define dio_put_sint16(d,k,v) dio_put_uint16(d,k,v)
+#define dio_put_sint32(d,k,v) dio_put_uint32(d,k,v)
+
+void dio_put_bool8(struct data_out *dout, char *key, bool value);
+void dio_put_bool32(struct data_out *dout, char *key, bool value);
+
+void dio_put_memory(struct data_out *dout, char *key, const void *value, size_t size);
+void dio_put_string(struct data_out *dout, char *key, const char *value);
+void dio_put_bit_string(struct data_out *dout, char *key, const char *value);
+void dio_put_city_map(struct data_out *dout, char *key, const char *value);
+void dio_put_tech_list(struct data_out *dout, char *key, const int *value);
+void dio_put_worklist(struct data_out *dout, char *key, const struct worklist *pwl);
+void dio_put_requirement(struct data_out *dout, char *key, const struct requirement *preq, int size);
+
+void dio_put_uint8_vec8(struct data_out *dout, char *key, int *values, int stop_value);
+void dio_put_uint16_vec8(struct data_out *dout, char *key, int *values, int stop_value);
+void dio_put_string_old(struct data_out *dout, const char *value);
+void dio_put_memory_old(struct data_out *dout, const void *value, size_t size);
+void dio_put_string_array(struct data_out *dout, char *key, const char *value, int size);
+
+/* Should be a function but we need some macro magic. */
+#define DIO_BV_PUT(pdout, type, bv) \
+  dio_put_memory((pdout), type, (bv).vec, sizeof((bv).vec))
+
+#endif
+
 #endif  /* FC__PACKETS_H */
diff -Nurd -X.diff_ignore freeciv/common/generate_packets.py freeciv/common/generate_packets.py
--- freeciv/common/generate_packets.py	2012-05-23 04:02:12.000000000 +0300
+++ freeciv/common/generate_packets.py	2012-05-23 04:02:28.000000000 +0300
@@ -250,7 +250,7 @@
         if self.is_array==1:
             tmp="real_packet->%(name)s[i] = %(name)s[i]"%self.__dict__
             return '''  {
-    int i;
+    int i; /* dette er for put. */
 
     for (i = 0; i < %(array_size_u) s; i++) {
       %(tmp)s;
@@ -348,40 +348,37 @@
     # Returns code which put this field.
     def get_put(self):
         if self.dataio_type=="bitvector":
-            return "DIO_BV_PUT(&dout, packet->%(name)s);"%self.__dict__
+            return "DIO_BV_PUT(&dout, \"%(name)s\", packet->%(name)s);"%self.__dict__
 
         if self.struct_type=="float" and not self.is_array:
-            return "  dio_put_uint32(&dout, (int)(real_packet->%(name)s * %(float_factor)d));"%self.__dict__
+            return "  dio_put_uint32(&dout, \"%(name)s\", (int)(real_packet->%(name)s * %(float_factor)d));"%self.__dict__
         
         if self.dataio_type in ["worklist"]:
-            return "  dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s);"%self.__dict__
+            return "  dio_put_%(dataio_type)s(&dout, \"%(name)s\", &real_packet->%(name)s);"%self.__dict__
 
         if self.dataio_type in ["memory"]:
-            return "  dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
+            return "  dio_put_%(dataio_type)s(&dout, \"%(name)s\", &real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
         
         arr_types=["string","bit_string","city_map","tech_list"]
         if (self.dataio_type in arr_types and self.is_array==1) or \
            (self.dataio_type not in arr_types and self.is_array==0):
-            return "  dio_put_%(dataio_type)s(&dout, real_packet->%(name)s);"%self.__dict__
-        if self.is_struct:
-            if self.is_array==2:
-                c="dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s[i][j]);"%self.__dict__
-            else:
-                c="dio_put_%(dataio_type)s(&dout, &real_packet->%(name)s[i]);"%self.__dict__
-        elif self.dataio_type=="string":
-            c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i]);"%self.__dict__
+            return "  dio_put_%(dataio_type)s(&dout, \"%(name)s\", real_packet->%(name)s);"%self.__dict__
+        if self.dataio_type=="string":
             array_size_u=self.array_size1_u
+            self.__dict__["array_size_u"] = array_size_u
+            c=" /*not supported yet... dio_put_%(dataio_type)s_array(&dout, \"%(name)s\", (char *)real_packet->%(name)s, %(array_size_u)s);*/ "%self.__dict__
 
         elif self.struct_type=="float":
-            if self.is_array==2:
-                c="  dio_put_uint32(&dout, (int)(real_packet->%(name)s[i][j] * %(float_factor)d));"%self.__dict__
-            else:
-                c="  dio_put_uint32(&dout, (int)(real_packet->%(name)s[i] * %(float_factor)d));"%self.__dict__
+             c = " /* %(name)s not supported yet */"%self.__dict__
+        elif self.struct_type=="bool":
+            c="dio_put_array_%(dataio_type)s(&dout, \"%(name)s\", (bool*)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
+        elif self.dataio_type=="requirement":
+            c="dio_put_%(dataio_type)s(&dout, \"%(name)s\", (struct requirement*)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
         else:
             if self.is_array==2:
-                c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i][j]);"%self.__dict__
+                c="dio_put_array_%(dataio_type)s(&dout, \"%(name)s\", (int*)real_packet->%(name)s, j);"%self.__dict__
             else:
-                c="dio_put_%(dataio_type)s(&dout, real_packet->%(name)s[i]);"%self.__dict__
+                c="dio_put_array_%(dataio_type)s(&dout, \"%(name)s\", (int*)real_packet->%(name)s, %(array_size_u)s);"%self.__dict__
 
         if not self.diff:
             if self.is_array==2 and self.dataio_type!="string":
@@ -398,11 +395,7 @@
             else:
                 return '''
     {
-      int i;
-
-      for (i = 0; i < %(array_size_u)s; i++) {
         %(c)s
-      }
     } '''%self.get_dict(vars())
         else:
             return '''
@@ -444,64 +437,64 @@
             return '''{
   int tmp;
   
-  dio_get_uint32(&din, &tmp);
+  dio_get_uint32(pc->json_packet, "%(name)s", &tmp);
   real_packet->%(name)s = (float)(tmp) / %(float_factor)d.0;
 }'''%self.__dict__
 
         if self.dataio_type=="bitvector":
-            return "DIO_BV_GET(&din, real_packet->%(name)s);"%self.__dict__
+            return " /* not supported yet. DIO_BV_GET(pc->json_packet, real_packet->%(name)s);*/"%self.__dict__
         if self.dataio_type in ["string","bit_string","city_map"] and \
            self.is_array!=2:
-            return "dio_get_%(dataio_type)s(&din, real_packet->%(name)s, sizeof(real_packet->%(name)s));"%self.__dict__
+            return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", real_packet->%(name)s, sizeof(real_packet->%(name)s));"%self.__dict__
         if self.is_struct and self.is_array==0:
-            return "dio_get_%(dataio_type)s(&din, &real_packet->%(name)s);"%self.__dict__
+            return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s);"%self.__dict__
         if self.dataio_type in ["tech_list"]:
-            return "dio_get_%(dataio_type)s(&din, real_packet->%(name)s);"%self.__dict__
+            return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", real_packet->%(name)s);"%self.__dict__
         if not self.is_array:
             if self.struct_type=="bool":
-                return "dio_get_%(dataio_type)s(&din, &real_packet->%(name)s);"%self.__dict__
+                return "dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s);"%self.__dict__
             return '''{
   int readin;
 
-  dio_get_%(dataio_type)s(&din, &readin);
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", &readin);
   real_packet->%(name)s = readin;
 }'''%self.__dict__
 
         if self.is_struct:
             if self.is_array==2:
-                c="dio_get_%(dataio_type)s(&din, &real_packet->%(name)s[i][j]);"%self.__dict__
+                c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s[i][j]);"%self.__dict__
             else:
-                c="dio_get_%(dataio_type)s(&din, &real_packet->%(name)s[i]);"%self.__dict__
+                c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s[i]);"%self.__dict__
         elif self.dataio_type=="string":
-            c="dio_get_%(dataio_type)s(&din, real_packet->%(name)s[i], sizeof(real_packet->%(name)s[i]));"%self.__dict__
+            c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", real_packet->%(name)s[i], sizeof(real_packet->%(name)s[i]));"%self.__dict__
         elif self.struct_type=="float":
             if self.is_array==2:
                 c='''int tmp;
 
-    dio_get_uint32(&din, &tmp);
+    dio_get_uint32(pc->json_packet, "%(name)s", &tmp);
     real_packet->%(name)s[i][j] = (float)(tmp) / %(float_factor)d.0;'''%self.__dict__
             else:
                 c='''int tmp;
 
-    dio_get_uint32(&din, &tmp);
+    dio_get_uint32(pc->json_packet, "%(name)s", &tmp);
     real_packet->%(name)s[i] = (float)(tmp) / %(float_factor)d.0;'''%self.__dict__
         elif self.struct_type=="bool":
             if self.is_array==2:
-                c="dio_get_%(dataio_type)s(&din, &real_packet->%(name)s[i][j]);"%self.__dict__
+                c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s[i][j]);"%self.__dict__
             else:
-                c="dio_get_%(dataio_type)s(&din, &real_packet->%(name)s[i]);"%self.__dict__
+                c="dio_get_%(dataio_type)s(pc->json_packet, \"%(name)s\", &real_packet->%(name)s[i]);"%self.__dict__
         elif self.is_array==2:
             c='''{
   int readin;
 
-  dio_get_%(dataio_type)s(&din, &readin);
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", &readin);
   real_packet->%(name)s[i][j] = readin;
 }'''%self.__dict__
         else:
             c='''{
   int readin;
 
-  dio_get_%(dataio_type)s(&din, &readin);
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", &readin);
   real_packet->%(name)s[i] = readin;
 }'''%self.__dict__
         if self.is_array==2:
@@ -521,8 +514,8 @@
             else:
                 extra=""
             if self.dataio_type=="memory":
-                return '''%(extra)s
-  dio_get_%(dataio_type)s(&din, real_packet->%(name)s, %(array_size_u)s);'''%self.get_dict(vars())
+                return ''' /* not supported yet. %(extra)s
+  dio_get_%(dataio_type)s(pc->json_packet, "%(name)s", real_packet->%(name)s, %(array_size_u)s);*/'''%self.get_dict(vars())
             elif self.is_array==2 and self.dataio_type!="string":
                 return '''
 {
@@ -548,7 +541,7 @@
 for (;;) {
   int i;
 
-  dio_get_uint8(&din, &i);
+  dio_get_uint8(pc->json_packet, "%(name)s", &i);
   if(i == 255) {
     break;
   }
@@ -847,7 +840,7 @@
 '''%self.get_dict(vars())
 
         body=body+'''
-  DIO_BV_PUT(&dout, fields);
+  DIO_BV_PUT(&dout, \"fields\", fields);
 '''
 
         for field in self.key_fields:
@@ -888,7 +881,7 @@
   struct %(packet_name)s *old;
   struct hash_table **hash = &pc->phs.received[type];
 '''
-            delta_body1="\n  DIO_BV_GET(&din, fields);\n"
+            delta_body1="\n  DIO_BV_GET(pc->json_packet, fields);\n"
             body1=""
             for field in self.key_fields:
                 body1=body1+prefix("  ",field.get_get())+"\n"
diff -Nurd -X.diff_ignore freeciv/common/packets.c freeciv/common/packets.c
--- freeciv/common/packets.c	2012-05-23 03:55:12.000000000 +0300
+++ freeciv/common/packets.c	2012-05-23 04:02:28.000000000 +0300
@@ -34,6 +34,8 @@
 #include "events.h"
 #include "map.h"
 
+#include <jansson.h>
+
 #include "packets.h"
 
 #ifdef USE_COMPRESSION
@@ -342,7 +344,7 @@
   }
 
   dio_input_init(&din, pc->buffer->data, pc->buffer->ndata);
-  dio_get_uint16(&din, &len_read);
+  dio_get_uint16_old(&din, &len_read);
 
   /* The non-compressed case */
   whole_packet_len = len_read;
@@ -448,10 +450,35 @@
     return NULL;
   }
 
-  dio_get_uint8(&din, &utype.itype);
+  /* Parse JSON packet. */
+  json_error_t error;
+  
+  dio_get_uint8_old(&din, &utype.itype);
+
+  dio_get_string_old(&din, (char*)pc->buffer->data, pc->buffer->ndata);
+ 
+  pc->json_packet = json_loadb((char*)pc->buffer->data, whole_packet_len, 0, &error);
+
+  memmove(pc->buffer->data, pc->buffer->data, pc->buffer->ndata);
+  pc->buffer->ndata = 0;
+
+  if (!pc->json_packet) {
+    log_error("ERROR: Unable to parse packet: %s", pc->buffer->data);
+    return NULL;
+  }
+
+  json_t *pint = json_object_get(pc->json_packet, "type");
+
+  if (!pint) {
+    log_error("ERROR: Unable to get packet type.");
+    return NULL;
+  } 
+
+  json_int_t packet_type = json_integer_value(pint);
+  utype.type = packet_type;
 
   log_packet("got packet type=(%s)%d len=%d",
-             packet_name(utype.type), utype.itype, whole_packet_len);
+             packet_name(utype.type), utype.type, whole_packet_len);
 
   *ptype = utype.type;
   *presult = TRUE;
@@ -513,10 +540,11 @@
 void remove_packet_from_buffer(struct socket_packet_buffer *buffer)
 {
   struct data_in din;
-  int len;
-
+  int len, type;
+ 
   dio_input_init(&din, buffer->data, buffer->ndata);
-  dio_get_uint16(&din, &len);
+  dio_get_uint16_old(&din, &len);
+  //dio_get_uint8_old(&din, &type);
   memmove(buffer->data, buffer->data + len, buffer->ndata - len);
   buffer->ndata -= len;
   log_debug("remove_packet_from_buffer: remove %d; remaining %d",
@@ -524,48 +552,6 @@
 }
 
 /**************************************************************************
-  ...
-**************************************************************************/
-void check_packet(struct data_in *din, struct connection *pc)
-{
-  size_t rem = dio_input_remaining(din);
-
-  if (din->bad_string || din->bad_bit_string || rem != 0) {
-    char from[MAX_LEN_ADDR + MAX_LEN_NAME + 128];
-    int type, len;
-
-    fc_assert_ret(pc != NULL);
-    fc_snprintf(from, sizeof(from), " from %s", conn_description(pc));
-
-    dio_input_rewind(din);
-    dio_get_uint16(din, &len);
-    dio_get_uint8(din, &type);
-
-    if (din->bad_string) {
-      log_error("received bad string in packet (type %d, len %d)%s",
-                type, len, from);
-    }
-
-    if (din->bad_bit_string) {
-      log_error("received bad bit string in packet (type %d, len %d)%s",
-                type, len, from);
-    }
-
-    if (din->too_short) {
-      log_error("received short packet (type %d, len %d)%s",
-                type, len, from);
-    }
-
-    if (rem > 0) {
-      /* This may be ok, eg a packet from a newer version with extra info
-       * which we should just ignore */
-      log_verbose("received long packet (type %d, len %d, rem %lu)%s", type,
-                  len, (unsigned long)rem, from);
-    }
-  }
-}
-
-/**************************************************************************
  Updates pplayer->attribute_block according to the given packet.
 **************************************************************************/
 void generic_handle_player_attribute_chunk(struct player *pplayer,
diff -Nurd -X.diff_ignore freeciv/common/packets.def freeciv/common/packets.def
--- freeciv/common/packets.def	2012-05-23 04:02:12.000000000 +0300
+++ freeciv/common/packets.def	2012-05-23 04:03:17.000000000 +0300
@@ -713,7 +713,7 @@
   UINT32 diplstate_id; key
   PLAYER plr1;
   PLAYER plr2;
-  UINT8 type;
+  UINT32 ds_type;
   UINT16 turns_left;
   UINT8 has_reason_to_cancel;
   UINT16 contact_turns_left;
diff -Nurd -X.diff_ignore freeciv/common/packets.h freeciv/common/packets.h
--- freeciv/common/packets.h	2012-05-23 03:55:12.000000000 +0300
+++ freeciv/common/packets.h	2012-05-23 04:02:28.000000000 +0300
@@ -29,6 +29,7 @@
 #include "team.h"
 #include "unittype.h"
 #include "worklist.h"
+#include <jansson.h>
 
 
 #define MAX_LEN_USERNAME        10        /* see below */
@@ -92,41 +93,38 @@
 
 #define SEND_PACKET_START(type) \
   unsigned char buffer[MAX_LEN_PACKET]; \
+  char* json_buffer = NULL; \
   struct data_out dout; \
+  dout.json = json_object(); \
   \
   dio_output_init(&dout, buffer, sizeof(buffer)); \
-  dio_put_uint16(&dout, 0); \
-  dio_put_uint8(&dout, type);
+  dio_put_uint16_old(&dout, 0); \
+  dio_put_uint8_old(&dout, type); \
+  \
+  dio_put_uint8(&dout, "pid", type);
 
 #define SEND_PACKET_END \
   { \
+    json_buffer = json_dumps(dout.json, JSON_COMPACT | JSON_ENSURE_ASCII); \
+    if (json_buffer) {  \
+      dio_put_string_old(&dout, json_buffer);	  \
+    } \
     size_t size = dio_output_used(&dout); \
-    \
     dio_output_rewind(&dout); \
-    dio_put_uint16(&dout, size); \
+    dio_put_uint16_old(&dout, size); \
+	  \
+    free(json_buffer); \
+    json_decref(dout.json); \
     return send_packet_data(pc, buffer, size); \
   }
 
 #define RECEIVE_PACKET_START(type, result) \
-  struct data_in din; \
-  struct type *result = fc_malloc(sizeof(*result)); \
-  \
-  dio_input_init(&din, pc->buffer->data, 2); \
-  { \
-    int size; \
-  \
-    dio_get_uint16(&din, &size); \
-    dio_input_init(&din, pc->buffer->data, MIN(size, pc->buffer->ndata)); \
-  } \
-  dio_get_uint16(&din, NULL); \
-  dio_get_uint8(&din, NULL);
+  struct type *result = fc_malloc(sizeof(*result));
 
 #define RECEIVE_PACKET_END(result) \
-  check_packet(&din, pc); \
-  remove_packet_from_buffer(pc->buffer); \
+  json_decref(pc->json_packet); \
   return result;
 
 int send_packet_data(struct connection *pc, unsigned char *data, int len);
-void check_packet(struct data_in *din, struct connection *pc);
 
 #endif  /* FC__PACKETS_H */
diff -Nurd -X.diff_ignore freeciv/configure.ac freeciv/configure.ac
--- freeciv/configure.ac	2012-05-23 04:01:36.000000000 +0300
+++ freeciv/configure.ac	2012-05-23 04:02:28.000000000 +0300
@@ -732,7 +732,7 @@
 
 dnl Checks for additional server libraries:
 if test "x$server" = "xyes"; then
-    SERVER_LIBS=" -lm -lssl "
+    SERVER_LIBS=" -lm -lssl -ljansson "
 
     dnl Some systems (e.g., BeOS) need this lib
     AC_CHECK_LIB(bind, gethostbyaddr, SERVER_LIBS="-lbind $SERVER_LIBS")
diff -Nurd -X.diff_ignore freeciv/server/handchat.c freeciv/server/handchat.c
--- freeciv/server/handchat.c	2012-05-23 03:55:12.000000000 +0300
+++ freeciv/server/handchat.c	2012-05-23 04:02:28.000000000 +0300
@@ -19,6 +19,8 @@
 #include <stdio.h>
 #include <string.h>
 
+#include <glib.h>
+
 /* utility */
 #include "fcintl.h"
 #include "log.h"
@@ -281,20 +283,34 @@
   avoiding sending both original and echo if sender is in destination
   set.
 **************************************************************************/
-void handle_chat_msg_req(struct connection *pconn, char *message)
+void handle_chat_msg_req(struct connection *pconn, char *raw_message)
 {
   char *cp;
   bool double_colon;
 
   /* this loop to prevent players from sending multiple lines
    * which can be abused */
-  for (cp = message; *cp != '\0'; cp++) {
-    if (*cp == '\n' || *cp == '\r') {
+  for (cp = raw_message; *cp != '\0'; cp++) {
+    if (*cp == '\n' || *cp == '\r' || *cp == '<' || *cp == '>' || *cp == '"' || *cp == '\'') {
       *cp='\0';
       break;
     }
   }
 
+  char* unesc_message = g_uri_unescape_string(raw_message, NULL);
+  char message[MAX_LEN_MSG];
+
+  if (unesc_message) {
+      char result_buf[MAX_LEN_MSG];
+      convert_string(unesc_message,
+ 	  	       "latin1",
+		       "UTF-8",
+		       (char*)message, sizeof(message));
+      g_free(unesc_message);
+  } else {
+    return;
+  }
+
   /* Server commands are prefixed with '/', which is an obvious
      but confusing choice: even before this feature existed,
      novice players were trying /who, /nick etc.
diff -Nurd -X.diff_ignore freeciv/server/plrhand.c freeciv/server/plrhand.c
--- freeciv/server/plrhand.c	2012-05-23 04:02:04.000000000 +0300
+++ freeciv/server/plrhand.c	2012-05-23 04:06:57.000000000 +0300
@@ -1040,12 +1040,12 @@
       || (receiver
           && player_diplstate_get(receiver, plr1)->contact_turns_left > 0)
       || (receiver && receiver == plr2)) {
-    packet_ds->type                 = ds->type;
+    packet_ds->ds_type              = ds->type;
     packet_ds->turns_left           = ds->turns_left;
     packet_ds->has_reason_to_cancel = ds->has_reason_to_cancel;
     packet_ds->contact_turns_left   = ds->contact_turns_left;
   } else {
-    packet_ds->type                 = DS_WAR;
+    packet_ds->ds_type              = DS_WAR;
     packet_ds->turns_left           = 0;
     packet_ds->has_reason_to_cancel = 0;
     packet_ds->contact_turns_left   = 0;
diff -Nurd -X.diff_ignore freeciv/server/sernet.c freeciv/server/sernet.c
--- freeciv/server/sernet.c	2012-05-23 04:01:25.000000000 +0300
+++ freeciv/server/sernet.c	2012-05-23 04:02:28.000000000 +0300
@@ -1256,7 +1256,7 @@
      * Generally we just want to run select again. */
   }
 
-  if (FD_ISSET(socklan, &readfs)) {
+  /*if (FD_ISSET(socklan, &readfs)) {
     if (0 < recvfrom(socklan, msgbuf, sizeof(msgbuf), 0, NULL, NULL)) {
       dio_input_init(&din, msgbuf, 1);
       dio_get_uint8(&din, &type);
@@ -1267,7 +1267,7 @@
         log_debug("Received invalid request for server LAN announcement.");
       }
     }
-  }
+  }*/
 }
 
 /********************************************************************
@@ -1355,13 +1355,13 @@
               srvarg.port );
 
   dio_output_init(&dout, buffer, sizeof(buffer));
-  dio_put_uint8(&dout, SERVER_LAN_VERSION);
-  dio_put_string(&dout, hostname);
-  dio_put_string(&dout, port);
-  dio_put_string(&dout, version);
-  dio_put_string(&dout, status);
-  dio_put_string(&dout, players);
-  dio_put_string(&dout, get_meta_message_string());
+  dio_put_uint8(&dout, "ver", SERVER_LAN_VERSION);
+  dio_put_string(&dout, "host", hostname);
+  dio_put_string(&dout, "port", port);
+  dio_put_string(&dout, "version", version);
+  dio_put_string(&dout, "status", status);
+  dio_put_string(&dout, "players", players);
+  dio_put_string(&dout, "msg", get_meta_message_string());
   size = dio_output_used(&dout);
 
   /* Sending packet to client with the information gathered above. */
diff -Nurd -X.diff_ignore freeciv/server/srv_main.c freeciv/server/srv_main.c
--- freeciv/server/srv_main.c	2012-05-23 04:01:41.000000000 +0300
+++ freeciv/server/srv_main.c	2012-05-23 04:02:28.000000000 +0300
@@ -1320,21 +1320,21 @@
                conn_description(pconn));
 
     dio_output_init(&dout, buffer, sizeof(buffer));
-    dio_put_uint16(&dout, 0);
+    dio_put_uint16(&dout, "msg", 0);
 
     /* 1 == PACKET_LOGIN_REPLY in the old client */
-    dio_put_uint8(&dout, 1);
+    dio_put_uint8(&dout, "msg", 1);
 
-    dio_put_bool32(&dout, FALSE);
-    dio_put_string(&dout, _("Your client is too old. To use this server, "
+    dio_put_bool32(&dout, "msg", FALSE);
+    dio_put_string(&dout, "msg", _("Your client is too old. To use this server, "
 			    "please upgrade your client to a "
 			    "Freeciv 2.2 or later."));
-    dio_put_string(&dout, "");
+    dio_put_string(&dout, "msg", "");
 
     {
       size_t size = dio_output_used(&dout);
       dio_output_rewind(&dout);
-      dio_put_uint16(&dout, size);
+      dio_put_uint16(&dout, "size",  size);
 
       /* 
        * Use send_connection_data instead of send_packet_data to avoid
