diff -Nurd -X.diff_ignore freeciv/client/client_main.c freeciv/client/client_main.c
--- freeciv/client/client_main.c	2015-07-05 12:56:45.700839098 +0300
+++ freeciv/client/client_main.c	2015-07-28 23:58:53.704907236 +0300
@@ -1038,7 +1038,7 @@
 **************************************************************************/
 void set_seconds_to_turndone(double seconds)
 {
-  if (game.info.timeout > 0) {
+  if (current_turn_timeout() > 0) {
     seconds_to_turndone = seconds;
     turndone_timer = timer_renew(turndone_timer, TIMER_USER, TIMER_ACTIVE);
     timer_start(turndone_timer);
@@ -1050,12 +1050,12 @@
 }
 
 /**************************************************************************
-  Return the number of seconds until turn-done.  Don't call this unless
-  game.info.timeout != 0.
+  Return the number of seconds until turn-done. Don't call this unless
+  current_turn_timeout() != 0.
 **************************************************************************/
 int get_seconds_to_turndone(void)
 {
-  if (game.info.timeout > 0) {
+  if (current_turn_timeout() > 0) {
     return seconds_shown_to_turndone;
   } else {
     /* This shouldn't happen. */
@@ -1095,9 +1095,9 @@
     time_until_next_call = MIN(time_until_next_call, blink_time);
   }
 
-  /* It is possible to have game.info.timeout > 0 but !turndone_timer, in the
-   * first moments after the timeout is set. */
-  if (game.info.timeout > 0 && turndone_timer) {
+  /* It is possible to have current_turn_timeout() > 0 but !turndone_timer,
+   * in the first moments after the timeout is set. */
+  if (current_turn_timeout() > 0 && turndone_timer) {
     double seconds = seconds_to_turndone - timer_read_seconds(turndone_timer);
     int iseconds = ceil(seconds) + 0.1; /* Turn should end right on 0. */
 
diff -Nurd -X.diff_ignore freeciv/client/gui-gtk-2.0/mapview.c freeciv/client/gui-gtk-2.0/mapview.c
--- freeciv/client/gui-gtk-2.0/mapview.c	2015-05-17 14:57:48.497565979 +0300
+++ freeciv/client/gui-gtk-2.0/mapview.c	2015-07-28 23:59:54.512429411 +0300
@@ -99,7 +99,7 @@
 {
   gtk_label_set_text(GTK_LABEL(timeout_label), get_timeout_label_text());
 
-  if (game.info.timeout > 0) {
+  if (current_turn_timeout() > 0) {
     gtk_widget_set_tooltip_text(timeout_label, _("Time to forced turn change"));
   } else {
     gtk_widget_set_tooltip_text(timeout_label, _("Turn timeout disabled"));
diff -Nurd -X.diff_ignore freeciv/client/gui-gtk-3.0/mapview.c freeciv/client/gui-gtk-3.0/mapview.c
--- freeciv/client/gui-gtk-3.0/mapview.c	2015-05-17 14:57:45.369566047 +0300
+++ freeciv/client/gui-gtk-3.0/mapview.c	2015-07-28 23:59:33.576594932 +0300
@@ -101,7 +101,7 @@
 {
   gtk_label_set_text(GTK_LABEL(timeout_label), get_timeout_label_text());
 
-  if (game.info.timeout > 0) {
+  if (current_turn_timeout() > 0) {
     gtk_widget_set_tooltip_text(timeout_label, _("Time to forced turn change"));
   } else {
     gtk_widget_set_tooltip_text(timeout_label, _("Turn timeout disabled"));
diff -Nurd -X.diff_ignore freeciv/client/packhand.c freeciv/client/packhand.c
--- freeciv/client/packhand.c	2015-05-22 01:06:23.521182281 +0300
+++ freeciv/client/packhand.c	2015-07-28 23:56:52.125832813 +0300
@@ -1198,7 +1198,7 @@
   update_unit_info_label(get_units_in_focus());
   menus_update();
 
-  set_seconds_to_turndone(game.info.timeout);
+  set_seconds_to_turndone(current_turn_timeout());
 
 #if 0
   /* This information shouldn't be needed, but if it is this is the only
@@ -1960,7 +1960,7 @@
 **************************************************************************/
 void handle_timeout_info(float seconds_to_phasedone)
 {
-  if (game.info.timeout != 0 && seconds_to_phasedone >= 0) {
+  if (current_turn_timeout() != 0 && seconds_to_phasedone >= 0) {
     /* If this packet is received in the middle of a turn, this value
      * represents the number of seconds from now to the end of the turn
      * (not from the start of the turn). So we need to restart our
diff -Nurd -X.diff_ignore freeciv/client/text.c freeciv/client/text.c
--- freeciv/client/text.c	2015-05-17 14:57:48.777565973 +0300
+++ freeciv/client/text.c	2015-07-28 23:57:11.357689340 +0300
@@ -1463,7 +1463,7 @@
 
   astr_clear(&str);
 
-  if (game.info.timeout <= 0) {
+  if (current_turn_timeout() <= 0) {
     astr_add(&str, "%s", Q_("?timeout:off"));
   } else {
     astr_add(&str, "%s", format_duration(get_seconds_to_turndone()));
diff -Nurd -X.diff_ignore freeciv/common/game.c freeciv/common/game.c
--- freeciv/common/game.c	2015-05-17 14:57:59.965565727 +0300
+++ freeciv/common/game.c	2015-07-28 23:52:32.651629336 +0300
@@ -766,3 +766,15 @@
     flag->helptxt = NULL;
   }
 }
+
+/****************************************************************************
+  Return timeout value for the current turn.
+****************************************************************************/
+int current_turn_timeout(void)
+{
+  if (game.info.turn == 0 && game.info.first_timeout != -1) {
+    return game.info.first_timeout;
+  } else {
+    return game.info.timeout;
+  }
+}
diff -Nurd -X.diff_ignore freeciv/common/game.h freeciv/common/game.h
--- freeciv/common/game.h	2015-05-20 04:12:47.180728183 +0300
+++ freeciv/common/game.h	2015-07-28 23:55:09.570576335 +0300
@@ -246,8 +246,6 @@
         fc_mutex city_list;
       } mutexes;
 
-      int first_timeout;
-
       struct trait_limits default_traits[TRAIT_COUNT];
       struct government *default_government;
 
@@ -297,6 +295,8 @@
 void user_flag_init(struct user_flag *flag);
 void user_flag_free(struct user_flag *flag);
 
+int current_turn_timeout(void);
+
 extern struct civ_game game;
 
 #define GAME_DEFAULT_SEED        0
diff -Nurd -X.diff_ignore freeciv/common/packets.def freeciv/common/packets.def
--- freeciv/common/packets.def	2015-07-25 12:05:18.816391695 +0300
+++ freeciv/common/packets.def	2015-07-28 23:54:39.510786667 +0300
@@ -519,6 +519,7 @@
   FTM free_tech_method;
   GLS gameloss_style;
   UINT32 timeout;
+  UINT32 first_timeout;
   BOOL tired_attack;
   UINT16 trademindist;
   BOOL force_trade_route;
diff -Nurd -X.diff_ignore freeciv/server/gamehand.c freeciv/server/gamehand.c
--- freeciv/server/gamehand.c	2015-05-17 14:58:03.469565650 +0300
+++ freeciv/server/gamehand.c	2015-07-28 23:46:15.773512947 +0300
@@ -868,7 +868,7 @@
 
   /* Sometimes this function is called before the phase_timer is
    * initialized.  In that case we want to send the dummy value. */
-  if (game.info.timeout > 0 && game.server.phase_timer) {
+  if (current_turn_timeout() > 0 && game.server.phase_timer) {
     /* Whenever the client sees this packet, it starts a new timer at 0;
      * but the server's timer is only ever reset at the start of a phase
      * (and game.tinfo.seconds_to_phasedone is relative to this).
@@ -970,7 +970,7 @@
 **************************************************************************/
 void increase_timeout_because_unit_moved(void)
 {
-  if (game.info.timeout > 0 && game.server.timeoutaddenemymove > 0) {
+  if (current_turn_timeout() > 0 && game.server.timeoutaddenemymove > 0) {
     double maxsec = (timer_read_seconds(game.server.phase_timer)
 		     + (double) game.server.timeoutaddenemymove);
 
diff -Nurd -X.diff_ignore freeciv/server/sernet.c freeciv/server/sernet.c
--- freeciv/server/sernet.c	2015-06-23 19:04:41.527102396 +0300
+++ freeciv/server/sernet.c	2015-07-28 23:46:15.777512935 +0300
@@ -687,7 +687,7 @@
       /* timeout */
       call_ai_refresh();
       (void) send_server_info_to_metaserver(META_REFRESH);
-      if (game.info.timeout > 0
+      if (current_turn_timeout() > 0
 	  && S_S_RUNNING == server_state()
 	  && game.server.phase_timer
 	  && (timer_read_seconds(game.server.phase_timer)
@@ -875,7 +875,7 @@
 
   call_ai_refresh();
 
-  if (game.info.timeout > 0
+  if (current_turn_timeout() > 0
       && S_S_RUNNING == server_state()
       && game.server.phase_timer
       && (timer_read_seconds(game.server.phase_timer)
diff -Nurd -X.diff_ignore freeciv/server/settings.c freeciv/server/settings.c
--- freeciv/server/settings.c	2015-06-03 01:05:26.762435878 +0300
+++ freeciv/server/settings.c	2015-07-28 23:55:19.634505100 +0300
@@ -2363,7 +2363,7 @@
           timeout_callback, timeout_action,
           GAME_MIN_TIMEOUT, GAME_MAX_TIMEOUT, GAME_DEFAULT_TIMEOUT)
 
-  GEN_INT("first_timeout", game.server.first_timeout,
+  GEN_INT("first_timeout", game.info.first_timeout,
           SSET_META, SSET_INTERNAL, SSET_VITAL, SSET_TO_CLIENT,
           N_("First turn timeout"),
           /* TRANS: The strings between single quotes are setting names and
diff -Nurd -X.diff_ignore freeciv/server/srv_main.c freeciv/server/srv_main.c
--- freeciv/server/srv_main.c	2015-06-23 19:04:41.527102396 +0300
+++ freeciv/server/srv_main.c	2015-07-28 23:52:37.699597337 +0300
@@ -1049,11 +1049,7 @@
 
   sanity_check();
 
-  if (game.info.turn == 0 && game.server.first_timeout != -1) {
-    game.tinfo.seconds_to_phasedone = (double)game.server.first_timeout;
-  } else {
-    game.tinfo.seconds_to_phasedone = (double)game.info.timeout;
-  }
+  game.tinfo.seconds_to_phasedone = (double)current_turn_timeout();
   game.server.phase_timer = timer_renew(game.server.phase_timer,
                                         TIMER_USER, TIMER_ACTIVE);
   timer_start(game.server.phase_timer);
@@ -1884,7 +1880,7 @@
   }
 
   /* fixedlength is only applicable if we have a timeout set */
-  if (game.server.fixedlength && game.info.timeout != 0) {
+  if (game.server.fixedlength && current_turn_timeout() != 0) {
     return;
   }
 
@@ -3259,4 +3255,3 @@
 {
   return playercolor_get(i);
 }
-
diff -Nurd -X.diff_ignore freeciv/server/srv_main.h freeciv/server/srv_main.h
--- freeciv/server/srv_main.h	2015-05-17 14:58:03.365565652 +0300
+++ freeciv/server/srv_main.h	2015-07-28 23:53:17.067343197 +0300
@@ -118,4 +118,5 @@
 extern bool force_end_of_sniff;
 
 void update_nations_with_startpos(void);
+
 #endif /* FC__SRV_MAIN_H */
diff -Nurd -X.diff_ignore freeciv/server/unittools.c freeciv/server/unittools.c
--- freeciv/server/unittools.c	2015-07-28 19:36:46.114222194 +0300
+++ freeciv/server/unittools.c	2015-07-28 23:46:15.777512935 +0300
@@ -3485,7 +3485,7 @@
   } unit_move_data_list_iterate_end;
 
   /* Check timeout settings. */
-  if (game.info.timeout != 0 && game.server.timeoutaddenemymove > 0) {
+  if (current_turn_timeout() != 0 && game.server.timeoutaddenemymove > 0) {
     bool new_information_for_enemy = FALSE;
 
     phase_players_iterate(penemy) {
