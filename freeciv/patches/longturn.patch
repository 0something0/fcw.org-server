 server/connecthand.c | 23 +++++++++++++++++++++--
 server/settings.c    |  4 ++++
 server/srv_main.c    | 12 ++++++++++--
 server/srv_main.h    |  1 +
 4 files changed, 36 insertions(+), 4 deletions(-)

diff --git a/server/connecthand.c b/server/connecthand.c
index d74f178..5b55712 100644
--- a/server/connecthand.c
+++ b/server/connecthand.c
@@ -251,6 +251,16 @@ void establish_new_connection(struct connection *pconn)
     notify_conn(dest, NULL, E_CONNECTION, ftc_server,
 		_("You are logged in as '%s' connected to no player."),
                 pconn->username);
+
+    if (is_longturn()) {
+      pplayer = find_uncontrolled_player();
+      if (pplayer) {
+        /* Make it human! */
+        set_as_human(pplayer);
+        connection_attach(pconn, pplayer, FALSE);
+      }
+    }
+
   } else {
     notify_conn(dest, NULL, E_CONNECTION, ftc_server,
 		_("You are logged in as '%s' connected to %s."),
@@ -540,8 +550,14 @@ void send_conn_info_remove(struct conn_list *src, struct conn_list *dest)
 struct player *find_uncontrolled_player(void)
 {
   players_iterate(played) {
-    if (!played->is_connected && !played->was_created) {
-      return played;
+    if (!is_longturn()) {
+      if (!played->is_connected && !played->was_created) {
+        return played;
+      }
+    } else {
+      if (!played->is_connected && !played->was_created && is_ai(played)) {
+        return played;
+      }
     }
   } players_iterate_end;
 
@@ -615,6 +631,9 @@ static bool connection_attach_real(struct connection *pconn,
       }
       (void) aifill(game.info.aifill);
     }
+    if (is_longturn()) {
+      server_player_set_name(pplayer, pconn->username);
+    }
 
     if (game.server.auto_ai_toggle && !is_human(pplayer)) {
       toggle_ai_player_direct(NULL, pplayer);
diff --git a/server/settings.c b/server/settings.c
index db41c41..e1378a6 100644
--- a/server/settings.c
+++ b/server/settings.c
@@ -1051,6 +1051,10 @@ static bool timeout_callback(int value, struct connection *caller,
     return FALSE;
   }
 
+  if (is_longturn() && S_S_RUNNING == server_state()) {
+    return FALSE;  // can't change timeout on LongTurn game.
+  }
+
   if (value == -1 && game.server.unitwaittime != 0) {
     /* autogame only with 'unitwaittime' = 0 */
     settings_snprintf(reject_msg, reject_msg_len,
diff --git a/server/srv_main.c b/server/srv_main.c
index a4b0c03..e5f37ca 100644
--- a/server/srv_main.c
+++ b/server/srv_main.c
@@ -1119,7 +1119,7 @@ static void begin_phase(bool is_new_phase)
     } phase_players_iterate_end;
 
     log_debug("Aistartturn");
-    ai_start_phase();
+    if (!is_longturn()) ai_start_phase();
   } else {
     phase_players_iterate(pplayer) {
       if (is_ai(pplayer)) {
@@ -1204,7 +1204,7 @@ static void end_phase(void)
   } players_iterate_end;
   phase_players_iterate(pplayer) {
     auto_settlers_player(pplayer);
-    if (is_ai(pplayer)) {
+    if (is_ai(pplayer) && !is_longturn()) {
       CALL_PLR_AI_FUNC(last_activities, pplayer, pplayer);
     }
   } phase_players_iterate_end;
@@ -3395,3 +3395,11 @@ static struct rgbcolor *mapimg_server_plrcolor_get(int i)
 {
   return playercolor_get(i);
 }
+
+/**************************************************************************
+ Is this a LongTurn game? 
+**************************************************************************/
+bool is_longturn(void)
+{
+  return (srvarg.port == 6003);
+}
diff --git a/server/srv_main.h b/server/srv_main.h
index 559bc8d..d2701e2 100644
--- a/server/srv_main.h
+++ b/server/srv_main.h
@@ -93,6 +93,7 @@ void srv_init(void);
 void srv_main(void);
 void server_quit(void);
 void save_game_auto(const char *save_reason, enum autosave_type type);
+bool is_longturn(void);
 
 enum server_states server_state(void);
 void set_server_state(enum server_states newstate);
