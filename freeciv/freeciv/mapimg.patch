 client/Makefile.am                       |   18 +
 client/colors_common.c                   |   27 +-
 client/gui-gtk-2.0-mapimg/Makefile.am    |   84 +
 client/gui-gtk-2.0-mapimg/canvas.c       |  157 ++
 client/gui-gtk-2.0-mapimg/canvas.h       |   20 +
 client/gui-gtk-2.0-mapimg/chatline.c     |   52 +
 client/gui-gtk-2.0-mapimg/chatline.h     |   20 +
 client/gui-gtk-2.0-mapimg/citydlg.c      |   86 +
 client/gui-gtk-2.0-mapimg/citydlg.h      |   20 +
 client/gui-gtk-2.0-mapimg/cityrep.c      |   62 +
 client/gui-gtk-2.0-mapimg/cityrep.h      |   20 +
 client/gui-gtk-2.0-mapimg/colors.c       |   70 +
 client/gui-gtk-2.0-mapimg/colors.h       |   26 +
 client/gui-gtk-2.0-mapimg/connectdlg.c   |  104 ++
 client/gui-gtk-2.0-mapimg/connectdlg.h   |   20 +
 client/gui-gtk-2.0-mapimg/dialogs.c      |  214 +++
 client/gui-gtk-2.0-mapimg/dialogs.h      |   21 +
 client/gui-gtk-2.0-mapimg/diplodlg.c     |   74 +
 client/gui-gtk-2.0-mapimg/diplodlg.h     |   20 +
 client/gui-gtk-2.0-mapimg/finddlg.c      |   26 +
 client/gui-gtk-2.0-mapimg/finddlg.h      |   20 +
 client/gui-gtk-2.0-mapimg/gotodlg.c      |   39 +
 client/gui-gtk-2.0-mapimg/gotodlg.h      |   20 +
 client/gui-gtk-2.0-mapimg/graphics.c     |   65 +
 client/gui-gtk-2.0-mapimg/graphics.h     |   20 +
 client/gui-gtk-2.0-mapimg/gui_main.c     |  730 +++++++++
 client/gui-gtk-2.0-mapimg/gui_main.h     |   20 +
 client/gui-gtk-2.0-mapimg/helpdlg.c      |   51 +
 client/gui-gtk-2.0-mapimg/helpdlg.h      |   20 +
 client/gui-gtk-2.0-mapimg/inteldlg.c     |   35 +
 client/gui-gtk-2.0-mapimg/inteldlg.h     |   20 +
 client/gui-gtk-2.0-mapimg/mapctrl.c      |   55 +
 client/gui-gtk-2.0-mapimg/mapctrl.h      |   20 +
 client/gui-gtk-2.0-mapimg/mapimg.c       | 2634 ++++++++++++++++++++++++++++++
 client/gui-gtk-2.0-mapimg/mapimg.h       |   68 +
 client/gui-gtk-2.0-mapimg/mapview.c      |  241 +++
 client/gui-gtk-2.0-mapimg/mapview.h      |   20 +
 client/gui-gtk-2.0-mapimg/menu.c         |   38 +
 client/gui-gtk-2.0-mapimg/menu.h         |   20 +
 client/gui-gtk-2.0-mapimg/messagedlg.c   |   28 +
 client/gui-gtk-2.0-mapimg/messagedlg.h   |   20 +
 client/gui-gtk-2.0-mapimg/messagewin.c   |   44 +
 client/gui-gtk-2.0-mapimg/messagewin.h   |   20 +
 client/gui-gtk-2.0-mapimg/pages.c        |   55 +
 client/gui-gtk-2.0-mapimg/pages.h        |   18 +
 client/gui-gtk-2.0-mapimg/plrdlg.c       |   34 +
 client/gui-gtk-2.0-mapimg/plrdlg.h       |   20 +
 client/gui-gtk-2.0-mapimg/ratesdlg.c     |   26 +
 client/gui-gtk-2.0-mapimg/ratesdlg.h     |   20 +
 client/gui-gtk-2.0-mapimg/rc2c           |   41 +
 client/gui-gtk-2.0-mapimg/repodlgs.c     |  104 ++
 client/gui-gtk-2.0-mapimg/repodlgs.h     |   20 +
 client/gui-gtk-2.0-mapimg/resources.c    |   26 +
 client/gui-gtk-2.0-mapimg/resources.h    |   20 +
 client/gui-gtk-2.0-mapimg/spaceshipdlg.c |   43 +
 client/gui-gtk-2.0-mapimg/spaceshipdlg.h |   20 +
 client/gui-gtk-2.0-mapimg/sprite.c       |  405 +++++
 client/gui-gtk-2.0-mapimg/sprite.h       |   47 +
 client/gui-gtk-2.0-mapimg/themes.c       |   59 +
 client/gui-gtk-2.0-mapimg/voteinfo_bar.c |   30 +
 client/gui-gtk-2.0-mapimg/voteinfo_bar.h |   19 +
 client/gui-gtk-2.0-mapimg/wldlg.c        |   26 +
 client/gui-gtk-2.0-mapimg/wldlg.h        |   19 +
 client/tilespec.c                        |    1 +
 common/Makefile.am                       |    2 +
 common/console.c                         |  227 +++
 common/console.h                         |   89 +
 common/fc_types.h                        |    1 +
 configure.ac                             |   18 +-
 data/amplio.tilespec                     |    8 +-
 data/amplio/Makefile.am                  |    1 +
 data/amplio/terraincolors.tilespec       |   24 +
 data/hex2t.tilespec                      |    8 +-
 data/isophex.tilespec                    |    8 +-
 data/isotrident.tilespec                 |    8 +-
 data/misc/Makefile.am                    |    8 +-
 data/misc/colors.png                     |  Bin 2401 -> 0 bytes
 data/misc/colors.spec                    |   66 -
 data/misc/colors.tilespec                |  180 --
 data/misc/gamecolors.tilespec            |  115 ++
 data/misc/playercolors.png               |  Bin 0 -> 2401 bytes
 data/misc/playercolors.spec              |   66 +
 data/misc/playercolors.tilespec          |   37 +
 data/misc/terraincolors.tilespec         |   24 +
 data/trident.tilespec                    |    8 +-
 m4/magickwand.m4                         |   47 +
 m4/mapimg-client.m4                      |   26 +
 manual/civmanual.c                       |    2 +-
 server/Makefile.am                       |    2 -
 server/civserver.c                       |    2 +-
 server/console.c                         |  258 ---
 server/console.h                         |   89 -
 server/handchat.c                        |    2 +-
 server/meta.c                            |    2 +-
 server/sernet.c                          |    2 +-
 server/srv_main.c                        |   42 +-
 server/stdinhand.c                       |    2 +-
 server/voting.c                          |    2 +-
 98 files changed, 7179 insertions(+), 639 deletions(-)

diff --git a/client/Makefile.am b/client/Makefile.am
index e649b44..7976328 100644
--- a/client/Makefile.am
+++ b/client/Makefile.am
@@ -13,6 +13,9 @@ GUI_SUBDIRS += gui-gtk-2.0
 desktopfile_DATA = \
 	freeciv.desktop
 endif
+if CLIENT_GUI_GTK_2_0_MAPIMG
+GUI_SUBDIRS += gui-gtk-2.0-mapimg
+endif
 if CLIENT_GUI_XAW
 GUI_SUBDIRS += gui-xaw
 endif
@@ -130,6 +133,21 @@ freeciv_client_src = $(AUDIO_SDL_FILES) \
 bin_PROGRAMS =
 noinst_LTLIBRARIES =
 
+if CLIENT_GUI_GTK_2_0_MAPIMG
+bin_PROGRAMS += freeciv-mapimg
+noinst_LTLIBRARIES += libfcgui-mapimg.la
+libfcgui_mapimg_la_SOURCES = $(freeciv_client_src)
+libfcgui_mapimg_la_LIBADD = gui-gtk-2.0-mapimg/libgui-mapimg.la agents/libagents.la
+freeciv_mapimg_SOURCES = dummy.c
+freeciv_mapimg_LDFLAGS = $(GUI_mapimg_LDFLAGS) $(GGZMOD_LDFLAGS)
+freeciv_mapimg_LDADD = \
+ $(SOUND_LIBS) \
+ libfcgui-mapimg.la \
+ $(top_builddir)/common/libfreeciv.la \
+ $(INTLLIBS) $(CLIENT_LIBS) $(SOUND_LIBS) $(LIB_GGZMOD) $(CLIENTICON) \
+ $(GUI_mapimg_LIBS) $(WAND_LIBS) -lreadline
+endif
+
 if CLIENT_GUI_GTK_2_0
 bin_PROGRAMS += freeciv-gtk2
 noinst_LTLIBRARIES += libfcgui-gtk2.la
diff --git a/client/colors_common.c b/client/colors_common.c
index 7a11b18..cb97a7a 100644
--- a/client/colors_common.c
+++ b/client/colors_common.c
@@ -107,14 +107,15 @@ struct color_system *color_system_read(struct section_file *file)
   int i;
   struct color_system *colors = fc_malloc(sizeof(*colors));
 
+  /* game colors */
   assert(ARRAY_SIZE(color_names) == COLOR_LAST);
   for (i = 0; i < COLOR_LAST; i++) {
     if (!secfile_lookup_int(file, &colors->colors[i].r,
-                            "colors.%s0.r", color_names[i])
+                            "gamecolors.%s0.r", color_names[i])
         || !secfile_lookup_int(file, &colors->colors[i].g,
-                               "colors.%s0.g", color_names[i])
+                               "gamecolors.%s0.g", color_names[i])
         || !secfile_lookup_int(file, &colors->colors[i].b,
-                               "colors.%s0.b", color_names[i])) {
+                               "gamecolors.%s0.b", color_names[i])) {
       log_error("Color %s: %s", color_names[i], secfile_error());
       colors->colors[i].r = 0;
       colors->colors[i].g = 0;
@@ -123,8 +124,9 @@ struct color_system *color_system_read(struct section_file *file)
     colors->colors[i].color = NULL;
   }
 
+  /* player colors */
   for (i = 0; i < MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS; i++) {
-    if (NULL == secfile_entry_lookup(file, "colors.player%d.r", i)) {
+    if (NULL == secfile_entry_lookup(file, "playercolors.player%d.r", i)) {
       break;
     }
   }
@@ -133,7 +135,7 @@ struct color_system *color_system_read(struct section_file *file)
 				    * sizeof(*colors->player_colors));
   if (i == 0) {
     /* Use a simple fallback. */
-    log_error("Missing colors.player. See misc/colors.tilespec.");
+    log_error("Missing playercolors.player. See misc/playercolors.tilespec.");
     colors->player_colors[0].r = 128;
     colors->player_colors[0].g = 0;
     colors->player_colors[0].b = 0;
@@ -142,9 +144,9 @@ struct color_system *color_system_read(struct section_file *file)
     for (i = 0; i < colors->num_player_colors; i++) {
       struct rgbcolor *rgb = &colors->player_colors[i];
 
-      if (!secfile_lookup_int(file, &rgb->r, "colors.player%d.r", i)
-          || !secfile_lookup_int(file, &rgb->g, "colors.player%d.g", i)
-          || !secfile_lookup_int(file, &rgb->b, "colors.player%d.b", i)) {
+      if (!secfile_lookup_int(file, &rgb->r, "playercolors.player%d.r", i)
+          || !secfile_lookup_int(file, &rgb->g, "playercolors.player%d.g", i)
+          || !secfile_lookup_int(file, &rgb->b, "playercolors.player%d.b", i)) {
         log_error("Player color %d: %s", i, secfile_error());
         rgb->r = 0;
         rgb->g = 0;
@@ -154,6 +156,7 @@ struct color_system *color_system_read(struct section_file *file)
     }
   }
 
+  /* terrain colors */
   for (i = 0; i < ARRAY_SIZE(colors->terrain_colors); i++) {
     struct rgbcolor *rgb = &colors->terrain_colors[i];
 
@@ -166,16 +169,16 @@ struct color_system *color_system_read(struct section_file *file)
     struct rgbcolor *prgb;
     const char *key;
 
-    if (!secfile_lookup_int(file, &rgb.r, "colors.tiles%d.r", i)
-        || !secfile_lookup_int(file, &rgb.g, "colors.tiles%d.g", i)
-        || !secfile_lookup_int(file, &rgb.b, "colors.tiles%d.b", i)) {
+    if (!secfile_lookup_int(file, &rgb.r, "terraincolors.tiles%d.r", i)
+        || !secfile_lookup_int(file, &rgb.g, "terraincolors.tiles%d.g", i)
+        || !secfile_lookup_int(file, &rgb.b, "terraincolors.tiles%d.b", i)) {
       break;
     }
 
     prgb = fc_malloc(sizeof(*prgb));
     rgb.color = NULL;
     *prgb = rgb;
-    key = secfile_lookup_str(file, "colors.tiles%d.tag", i);
+    key = secfile_lookup_str(file, "terraincolors.tiles%d.tag", i);
 
     if (NULL == key) {
       log_error("warning: tag for tiles %d: %s", i, secfile_error());
diff --git a/client/gui-gtk-2.0-mapimg/Makefile.am b/client/gui-gtk-2.0-mapimg/Makefile.am
new file mode 100644
index 0000000..7503280
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/Makefile.am
@@ -0,0 +1,84 @@
+## Process this file with automake to produce Makefile.in
+
+noinst_LTLIBRARIES = libgui-mapimg.la
+AM_CPPFLAGS = -I. -I$(srcdir)/.. -I$(srcdir)/../include -I$(top_srcdir)/utility \
+	-I$(top_srcdir)/common -I$(top_srcdir)/common/aicore -I$(srcdir)/../agents \
+	$(GUI_mapimg_CFLAGS) $(SOUND_CFLAGS) $(GGZ_GTK_INCLUDES) $(WAND_CFLAGS)
+
+# The AM_CPPFLAGS "-I." is so resources.c includes the locally generated 
+# Freeciv.h in the builddir, in preference to the one 
+# in the source dir (when compiling from another dir). --dwp
+
+BUILT_SOURCES = Freeciv.h
+CLEANFILES = Freeciv.h
+
+Freeciv.h: $(top_srcdir)/data/freeciv.rc-2.0
+	echo '/*********************************************************/' > Freeciv.h
+	echo '/* DO NOT EDIT THIS FILE, EDIT ../../data/freeciv.rc-2.0 */' >> Freeciv.h
+	echo '/*********************************************************/' >> Freeciv.h
+	$(srcdir)/rc2c $(top_srcdir)/data/freeciv.rc-2.0 >> Freeciv.h
+
+libgui_mapimg_la_DEPENDENCIES = rc2c
+
+libgui_mapimg_la_SOURCES = \
+	rc2c		\
+	Freeciv.h	\
+	canvas.c	\
+	canvas.h	\
+	chatline.c	\
+	chatline.h	\
+	citydlg.c	\
+	citydlg.h	\
+	cityrep.c	\
+	cityrep.h	\
+	colors.c	\
+	colors.h	\
+	connectdlg.c	\
+	connectdlg.h	\
+	dialogs.c	\
+	dialogs.h	\
+	diplodlg.c	\
+	diplodlg.h	\
+	finddlg.c	\
+	finddlg.h	\
+	gotodlg.c	\
+	gotodlg.h	\
+	graphics.c	\
+	graphics.h	\
+	gui_main.c	\
+	gui_main.h	\
+	helpdlg.c	\
+	helpdlg.h	\
+	inteldlg.c	\
+	inteldlg.h	\
+	mapctrl.c	\
+	mapctrl.h	\
+	mapimg.c	\
+	mapimg.h	\
+	mapview.c	\
+	mapview.h	\
+	menu.c		\
+	menu.h		\
+	messagedlg.c	\
+	messagedlg.h	\
+	messagewin.c	\
+	messagewin.h	\
+	pages.c		\
+	pages.h		\
+	plrdlg.c	\
+	plrdlg.h	\
+	ratesdlg.c	\
+	ratesdlg.h	\
+	repodlgs.c	\
+	repodlgs.h	\
+	resources.c	\
+	resources.h	\
+	spaceshipdlg.c	\
+	spaceshipdlg.h	\
+	sprite.c	\
+	sprite.h	\
+	themes.c	\
+	voteinfo_bar.c	\
+	voteinfo_bar.h	\
+	wldlg.c		\
+	wldlg.h
diff --git a/client/gui-gtk-2.0-mapimg/canvas.c b/client/gui-gtk-2.0-mapimg/canvas.c
new file mode 100644
index 0000000..be09402
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/canvas.c
@@ -0,0 +1,157 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996-2005 - Freeciv Development Team
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "canvas.h"
+
+/****************************************************************************
+  Create a canvas of the given size.
+****************************************************************************/
+struct canvas *canvas_create(int width, int height)
+{
+  /* PORTME */
+  return NULL;
+}
+
+/****************************************************************************
+  Free any resources associated with this canvas and the canvas struct
+  itself.
+****************************************************************************/
+void canvas_free(struct canvas *store)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Copies an area from the source canvas to the destination canvas.
+****************************************************************************/
+void canvas_copy(struct canvas *dest, struct canvas *src,
+		     int src_x, int src_y, int dest_x, int dest_y, int width,
+		     int height)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Draw some or all of a sprite onto the canvas.
+****************************************************************************/
+void canvas_put_sprite(struct canvas *pcanvas,
+		    int canvas_x, int canvas_y,
+		    struct sprite *sprite,
+		    int offset_x, int offset_y, int width, int height)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Draw a full sprite onto the canvas.
+****************************************************************************/
+void canvas_put_sprite_full(struct canvas *pcanvas,
+			 int canvas_x, int canvas_y,
+			 struct sprite *sprite)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Draw a full sprite onto the canvas.  If "fog" is specified draw it with
+  fog.
+****************************************************************************/
+void canvas_put_sprite_fogged(struct canvas *pcanvas,
+			      int canvas_x, int canvas_y,
+			      struct sprite *psprite,
+			      bool fog, int fog_x, int fog_y)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Draw a filled-in colored rectangle onto canvas.
+****************************************************************************/
+void canvas_put_rectangle(struct canvas *pcanvas,
+		       struct color *pcolor,
+		       int canvas_x, int canvas_y, int width, int height)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Fill the area covered by the sprite with the given color.
+****************************************************************************/
+void canvas_fill_sprite_area(struct canvas *pcanvas,
+			     struct sprite *psprite, struct color *pcolor,
+			     int canvas_x, int canvas_y)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Fill the area covered by the sprite with the given color.
+****************************************************************************/
+void canvas_fog_sprite_area(struct canvas *pcanvas, struct sprite *psprite,
+			    int canvas_x, int canvas_y)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Draw a 1-pixel-width colored line onto the canvas.
+****************************************************************************/
+void canvas_put_line(struct canvas *pcanvas, struct color *pcolor,
+		  enum line_type ltype, int start_x, int start_y,
+		  int dx, int dy)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Draw a 1-pixel-width colored curved line onto the canvas.
+****************************************************************************/
+void canvas_put_curved_line(struct canvas *pcanvas, struct color *pcolor,
+                            enum line_type ltype, int start_x, int start_y,
+                            int dx, int dy)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Return the size of the given text in the given font.  This size should
+  include the ascent and descent of the text.  Either of width or height
+  may be NULL in which case those values simply shouldn't be filled out.
+****************************************************************************/
+void get_text_size(int *width, int *height,
+		   enum client_font font, const char *text)
+{
+  /* PORTME */
+  if (width) {
+    *width = 0;
+  }
+  if (height) {
+    *height = 0;
+  }
+}
+
+/****************************************************************************
+  Draw the text onto the canvas in the given color and font.  The canvas
+  position does not account for the ascent of the text; this function must
+  take care of this manually.  The text will not be NULL but may be empty.
+****************************************************************************/
+void canvas_put_text(struct canvas *pcanvas, int canvas_x, int canvas_y,
+		     enum client_font font, struct color *pcolor,
+		     const char *text)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/canvas.h b/client/gui-gtk-2.0-mapimg/canvas.h
new file mode 100644
index 0000000..575d61a
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/canvas.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__CANVAS_H
+#define FC__CANVAS_H
+
+#include "canvas_g.h"
+
+
+#endif				/* FC__CANVAS_H */
diff --git a/client/gui-gtk-2.0-mapimg/chatline.c b/client/gui-gtk-2.0-mapimg/chatline.c
new file mode 100644
index 0000000..97913b4
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/chatline.c
@@ -0,0 +1,52 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "console.h"
+
+#include "climisc.h"      /* for write_chatline_content */
+
+#include "chatline.h"
+
+/**************************************************************************
+  Appends the string to the chat output window. The string should be
+  inserted on its own line, although it will have no newline.
+**************************************************************************/
+void real_output_window_append(const char *astring,
+                               const struct text_tag_list *tags,
+                               int conn_id)
+{
+  /* PORTME */
+  con_puts(C_OK, astring);
+}
+
+/**************************************************************************
+  Get the text of the output window, and call write_chatline_content() to
+  log it.
+**************************************************************************/
+void log_output_window(void)
+{
+  /* PORTME */
+  write_chatline_content(NULL);
+}
+
+/**************************************************************************
+  Clear all text from the output window.
+**************************************************************************/
+void clear_output_window(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/chatline.h b/client/gui-gtk-2.0-mapimg/chatline.h
new file mode 100644
index 0000000..9e021ba
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/chatline.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__CHATLINE_H
+#define FC__CHATLINE_H
+
+#include "chatline_g.h"
+
+
+#endif				/* FC__CHATLINE_H */
diff --git a/client/gui-gtk-2.0-mapimg/citydlg.c b/client/gui-gtk-2.0-mapimg/citydlg.c
new file mode 100644
index 0000000..3e39a5b
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/citydlg.c
@@ -0,0 +1,86 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "citydlg.h"
+
+/**************************************************************************
+  Pop up (or bring to the front) a dialog for the given city.  It may or
+  may not be modal.
+**************************************************************************/
+void popup_city_dialog(struct city *pcity)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Close the dialog for the given city.
+**************************************************************************/
+void popdown_city_dialog(struct city *pcity)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Close the dialogs for all cities.
+**************************************************************************/
+void popdown_all_city_dialogs(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Refresh (update) all data for the given city's dialog.
+**************************************************************************/
+void refresh_city_dialog(struct city *pcity)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Update city dialogs when the given unit's status changes.  This
+  typically means updating both the unit's home city (if any) and the
+  city in which it is present (if any).
+**************************************************************************/
+void refresh_unit_city_dialogs(struct unit *punit)
+{
+  /* PORTME */
+#if 0
+  /* Demo code */
+  struct city *pcity_sup, *pcity_pre;
+  struct city_dialog *pdialog;
+
+  pcity_sup = game_find_city_by_number(punit->homecity);
+  pcity_pre = tile_city(punit->tile);
+
+  if (pcity_sup && (pdialog = get_city_dialog(pcity_sup))) {
+    city_dialog_update_supported_units(pdialog);
+  }
+
+  if (pcity_pre && (pdialog = get_city_dialog(pcity_pre))) {
+    city_dialog_update_present_units(pdialog);
+  }
+#endif
+}
+
+/**************************************************************************
+  Return whether the dialog for the given city is open.
+**************************************************************************/
+bool city_dialog_is_open(struct city *pcity)
+{
+  /* PORTME */
+  return FALSE;
+}
diff --git a/client/gui-gtk-2.0-mapimg/citydlg.h b/client/gui-gtk-2.0-mapimg/citydlg.h
new file mode 100644
index 0000000..2004121
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/citydlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__CITYDLG_H
+#define FC__CITYDLG_H
+
+#include "citydlg_g.h"
+
+
+#endif				/* FC__CITYDLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/cityrep.c b/client/gui-gtk-2.0-mapimg/cityrep.c
new file mode 100644
index 0000000..99e51ec
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/cityrep.c
@@ -0,0 +1,62 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+
+#include "cityrep.h"
+
+/**************************************************************************
+  Display the city report dialog.  Optionally raise it.
+**************************************************************************/
+void popup_city_report_dialog(bool raise)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Update (refresh) the entire city report dialog.
+**************************************************************************/
+void city_report_dialog_update(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Update the information for a single city in the city report.
+**************************************************************************/
+void city_report_dialog_update_city(struct city *pcity)
+{
+  /* PORTME */
+}
+
+/****************************************************************
+ After a selection rectangle is defined, make the cities that
+ are hilited on the canvas exclusively hilited in the
+ City List window.
+*****************************************************************/
+void hilite_cities_from_canvas(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************
+ Toggle a city's hilited status.
+*****************************************************************/
+void toggle_city_hilite(struct city *pcity, bool on_off)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/cityrep.h b/client/gui-gtk-2.0-mapimg/cityrep.h
new file mode 100644
index 0000000..ed7ceed
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/cityrep.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__CITYREP_H
+#define FC__CITYREP_H
+
+#include "cityrep_g.h"
+
+
+#endif				/* FC__CITYREP_H */
diff --git a/client/gui-gtk-2.0-mapimg/colors.c b/client/gui-gtk-2.0-mapimg/colors.c
new file mode 100644
index 0000000..8c0bf4e
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/colors.c
@@ -0,0 +1,70 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+
+#include <gtk/gtk.h>
+
+#include "log.h"
+#include "mem.h"
+
+#include "gui_main.h"
+
+#include "colors.h"
+
+/****************************************************************************
+  Allocate a color (adjusting it for our colormap if necessary on paletted
+  systems) and return a pointer to it.
+****************************************************************************/
+struct color *color_alloc(int r, int g, int b)
+{
+  struct color *color = fc_malloc(sizeof(*color));
+  GdkColormap *cmap = gtk_widget_get_default_colormap();
+
+  color->color.red = r << 8;
+  color->color.green = g << 8;
+  color->color.blue = b << 8;
+  gdk_rgb_find_color(cmap, &color->color);
+
+  return color;
+}
+
+/****************************************************************************
+  Free a previously allocated color.  See color_alloc.
+****************************************************************************/
+void color_free(struct color *color)
+{
+  free(color);
+}
+
+/****************************************************************************
+  Fill the string with the color in "#rrggbb" mode.  Use it instead of
+  gdk_color() which have been included in gtk2.12 version only.
+****************************************************************************/
+size_t color_to_string(GdkColor *color, char *string, size_t length)
+{
+  log_assert_ret_val(NULL != string, 0);
+  log_assert_ret_val(0 < length, 0);
+
+  if (NULL == color) {
+    string[0] = '\0';
+    return 0;
+  } else {
+    return my_snprintf(string, length, "#%02x%02x%02x",
+                       color->red >> 8, color->green >> 8, color->blue >> 8);
+  }
+}
diff --git a/client/gui-gtk-2.0-mapimg/colors.h b/client/gui-gtk-2.0-mapimg/colors.h
new file mode 100644
index 0000000..8cbd8eb
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/colors.h
@@ -0,0 +1,26 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__COLORS_H
+#define FC__COLORS_H
+
+#include <gtk/gtk.h>
+
+#include "colors_g.h"
+
+struct color {
+  GdkColor color;
+};
+
+size_t color_to_string(GdkColor *color, char *string, size_t length);
+
+#endif  /* FC__COLORS_H */
diff --git a/client/gui-gtk-2.0-mapimg/connectdlg.c b/client/gui-gtk-2.0-mapimg/connectdlg.c
new file mode 100644
index 0000000..8bb457c
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/connectdlg.c
@@ -0,0 +1,104 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <errno.h>
+
+/* utility */
+#include "fcintl.h"
+#include "log.h"
+#include "support.h"
+
+#include "connectdlg_g.h"
+
+/* client */
+#include "chatline_common.h"	/* for append_output_window */
+#include "client_main.h"
+#include "connectdlg.h"
+#include "packhand_gen.h"
+
+/**************************************************************************
+ Really close and destroy the dialog.
+**************************************************************************/
+void really_close_connection_dialog(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+ Close and destroy the dialog. But only if we don't have a local
+ server running (that we started).
+**************************************************************************/
+void close_connection_dialog()
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+ Configure the dialog depending on what type of authentication request the
+ server is making.
+**************************************************************************/
+void handle_authentication_req(enum authentication_type type, char *message)
+{
+  switch (type) {
+  case AUTH_NEWUSER_FIRST:
+     /* PORTME: switch configs if need be */
+    break;
+  case AUTH_NEWUSER_RETRY:
+     /* PORTME: switch configs if need be */
+    break;
+  case AUTH_LOGIN_FIRST:
+    /* if we magically have a password already present in 'password'
+     * then, use that and skip the password entry dialog */
+    if (password[0] != '\0') {
+      struct packet_authentication_reply reply;
+
+      sz_strlcpy(reply.password, password);
+      send_packet_authentication_reply(&client.conn, &reply);
+      return;
+    } else {
+     /* PORTME: switch configs if need be */
+    }
+    break;
+  case AUTH_LOGIN_RETRY:
+     /* PORTME: switch configs if need be */
+    break;
+  default:
+    assert(0);
+  }
+
+  /* PORTME etc. */
+}
+
+/**************************************************************************
+ Provide a packet handler for packet_game_load.
+
+ This regenerates the player information from a loaded game on the
+ server.
+**************************************************************************/
+void handle_game_load(bool load_successful, char *filename)
+{ 
+  /* PORTME */
+}
+
+
+/**************************************************************************
+  Provide an interface for connecting to a FreeCiv server.
+**************************************************************************/
+void gui_server_connect(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/connectdlg.h b/client/gui-gtk-2.0-mapimg/connectdlg.h
new file mode 100644
index 0000000..819a7cd
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/connectdlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__CONNECTDLG_H
+#define FC__CONNECTDLG_H
+
+#include "connectdlg_g.h"
+
+
+#endif				/* FC__CONNECTDLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/dialogs.c b/client/gui-gtk-2.0-mapimg/dialogs.c
new file mode 100644
index 0000000..0264d68
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/dialogs.c
@@ -0,0 +1,214 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "game.h"
+#include "government.h"
+
+#include "dialogs.h"
+
+/**************************************************************************
+  Popup a dialog to display information about an event that has a
+  specific location.  The user should be given the option to goto that
+  location.
+**************************************************************************/
+void popup_notify_goto_dialog(const char *headline, const char *lines,
+                              const struct text_tag_list *tags,
+                              struct tile *ptile)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Popup a dialog to display connection message from server.
+**************************************************************************/
+void popup_connect_msg(const char *headline, const char *message)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Popup a generic dialog to display some generic information.
+**************************************************************************/
+void popup_notify_dialog(const char *caption, const char *headline,
+			 const char *lines)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Popup the nation selection dialog.
+**************************************************************************/
+void popup_races_dialog(struct player *pplayer)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Close the nation selection dialog.  This should allow the user to
+  (at least) select a unit to activate.
+**************************************************************************/
+void popdown_races_dialog(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Popup a dialog window to select units on a particular tile.
+**************************************************************************/
+void popup_unit_select_dialog(struct tile *ptile)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  In the nation selection dialog, make already-taken nations unavailable.
+  This information is contained in the packet_nations_used packet.
+**************************************************************************/
+void races_toggles_set_sensitive(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Popup a dialog asking if the player wants to start a revolution.
+**************************************************************************/
+void popup_revolution_dialog(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Popup a dialog giving a player choices when their caravan arrives at
+  a city (other than its home city).  Example:
+    - Establish trade route.
+    - Help build wonder.
+    - Keep moving.
+**************************************************************************/
+void popup_caravan_dialog(struct unit *punit,
+			  struct city *phomecity, struct city *pdestcity)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Is there currently a caravan dialog open?  This is important if there
+  can be only one such dialog at a time; otherwise return FALSE.
+**************************************************************************/
+bool caravan_dialog_is_open(int *unit_id, int *city_id)
+{
+  /* PORTME */
+  return FALSE;
+}
+
+/**************************************************************************
+  Popup a dialog giving a diplomatic unit some options when moving into
+  the target tile.
+**************************************************************************/
+void popup_diplomat_dialog(struct unit *punit, struct tile *ptile)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Popup a window asking a diplomatic unit if it wishes to incite the
+  given enemy city.
+**************************************************************************/
+void popup_incite_dialog(struct city *pcity, int cost)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Popup a dialog asking a diplomatic unit if it wishes to bribe the
+  given enemy unit.
+**************************************************************************/
+void popup_bribe_dialog(struct unit *punit, int cost)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Popup a dialog asking a diplomatic unit if it wishes to sabotage the
+  given enemy city.
+**************************************************************************/
+void popup_sabotage_dialog(struct city *pcity)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Popup a dialog asking the unit which improvement they would like to
+  pillage.
+**************************************************************************/
+void popup_pillage_dialog(struct unit *punit, bv_special may_pillage,
+                          bv_bases bases)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Ruleset (modpack) has suggested loading certain tileset. Confirm from
+  user and load.
+**************************************************************************/
+void popup_tileset_suggestion_dialog(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Tileset (modpack) has suggested loading certain theme. Confirm from
+  user and load.
+**************************************************************************/
+bool popup_theme_suggestion_dialog(const char *theme_name)
+{
+  /* PORTME */
+  return FALSE;
+}
+
+/**************************************************************************
+  This function is called when the client disconnects or the game is
+  over.  It should close all dialog windows for that game.
+**************************************************************************/
+void popdown_all_game_dialogs(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************
+  Returns id of a diplomat currently handled in diplomat dialog
+*****************************************************************/
+int diplomat_handled_in_diplomat_dialog(void)
+{
+  /* PORTME */    
+  return -1;  
+}
+
+/****************************************************************
+  Closes the diplomat dialog
+****************************************************************/
+void close_diplomat_dialog(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************
+  Updates caravan dialog
+****************************************************************/
+void caravan_dialog_update(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/dialogs.h b/client/gui-gtk-2.0-mapimg/dialogs.h
new file mode 100644
index 0000000..a08bad6
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/dialogs.h
@@ -0,0 +1,21 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__DIALOGS_H
+#define FC__DIALOGS_H
+
+#include "dialogs_g.h"
+
+void popup_revolution_dialog(void);
+
+#endif				/* FC__DIALOGS_H */
diff --git a/client/gui-gtk-2.0-mapimg/diplodlg.c b/client/gui-gtk-2.0-mapimg/diplodlg.c
new file mode 100644
index 0000000..4aed262
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/diplodlg.c
@@ -0,0 +1,74 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "diplodlg.h"
+
+/**************************************************************************
+  Update a player's acceptance status of a treaty (traditionally shown
+  with the thumbs-up/thumbs-down sprite).
+**************************************************************************/
+void handle_diplomacy_accept_treaty(int counterpart, bool I_accepted,
+				    bool other_accepted)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Handle the start of a diplomacy meeting - usually by poping up a
+  diplomacy dialog.
+**************************************************************************/
+void handle_diplomacy_init_meeting(int counterpart, int initiated_from)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Update the diplomacy dialog by adding a clause.
+**************************************************************************/
+void handle_diplomacy_create_clause(int counterpart, int giver,
+				    enum clause_type type, int value)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Update the diplomacy dialog when the meeting is canceled (the dialog
+  should be closed).
+**************************************************************************/
+void handle_diplomacy_cancel_meeting(int counterpart, int initiated_from)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Update the diplomacy dialog by removing a clause.
+**************************************************************************/
+void handle_diplomacy_remove_clause(int counterpart, int giver,
+				    enum clause_type type, int value)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Close all open diplomacy dialogs.
+
+  Called when the client disconnects from game.
+**************************************************************************/
+void close_all_diplomacy_dialogs(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/diplodlg.h b/client/gui-gtk-2.0-mapimg/diplodlg.h
new file mode 100644
index 0000000..d32ec3e
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/diplodlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__DIPLODLG_H
+#define FC__DIPLODLG_H
+
+#include "diplodlg_g.h"
+
+
+#endif				/* FC__DIPLODLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/finddlg.c b/client/gui-gtk-2.0-mapimg/finddlg.c
new file mode 100644
index 0000000..a790f91
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/finddlg.c
@@ -0,0 +1,26 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "finddlg.h"
+
+/**************************************************************************
+  Popup a dialog to ask for a city to find.
+**************************************************************************/
+void popup_find_dialog(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/finddlg.h b/client/gui-gtk-2.0-mapimg/finddlg.h
new file mode 100644
index 0000000..24ade7d
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/finddlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 2003 - The Freeciv Project
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__FINDDLG_H
+#define FC__FINDDLG_H
+
+#include "finddlg_g.h"
+
+/* nothing to add */
+
+#endif  /* FC__FINDDLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/gotodlg.c b/client/gui-gtk-2.0-mapimg/gotodlg.c
new file mode 100644
index 0000000..1a5dd0a
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/gotodlg.c
@@ -0,0 +1,39 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+/* common */
+#include "game.h"
+
+/* client */
+#include "client_main.h"
+#include "control.h"
+
+#include "gotodlg.h"
+
+/**************************************************************************
+  Popup a dialog to have the focus unit goto to a city.
+**************************************************************************/
+void popup_goto_dialog(void)
+{
+  if (C_S_RUNNING != client_state()) {
+    return;
+  }
+  if (get_num_units_in_focus() == 0) {
+    return;
+  }
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/gotodlg.h b/client/gui-gtk-2.0-mapimg/gotodlg.h
new file mode 100644
index 0000000..5f76872
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/gotodlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__GOTODLG_H
+#define FC__GOTODLG_H
+
+#include "gotodlg_g.h"
+
+
+#endif				/* FC__GOTODLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/graphics.c b/client/gui-gtk-2.0-mapimg/graphics.c
new file mode 100644
index 0000000..92459aa
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/graphics.c
@@ -0,0 +1,65 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+
+#include "tilespec.h"
+
+#include "graphics.h"
+
+/****************************************************************************
+  Return whether the client supports isometric view (isometric tilesets).
+****************************************************************************/
+bool isometric_view_supported(void)
+{
+  /* PORTME */
+  return TRUE;
+}
+
+/****************************************************************************
+  Return whether the client supports "overhead" (non-isometric) view.
+****************************************************************************/
+bool overhead_view_supported(void)
+{
+  /* PORTME */
+  return TRUE;
+}
+
+/****************************************************************************
+  Load the introductory graphics.
+****************************************************************************/
+void load_intro_gfx(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Load the cursors (mouse substitute sprites), including a goto cursor,
+  an airdrop cursor, a nuke cursor, and a patrol cursor.
+****************************************************************************/
+void load_cursors(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Frees the introductory sprites.
+****************************************************************************/
+void free_intro_radar_sprites(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/graphics.h b/client/gui-gtk-2.0-mapimg/graphics.h
new file mode 100644
index 0000000..165403f
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/graphics.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__GRAPHICS_H
+#define FC__GRAPHICS_H
+
+#include "graphics_g.h"
+
+
+#endif				/* FC__GRAPHICS_H */
diff --git a/client/gui-gtk-2.0-mapimg/gui_main.c b/client/gui-gtk-2.0-mapimg/gui_main.c
new file mode 100644
index 0000000..ce9a56c
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/gui_main.c
@@ -0,0 +1,730 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef AUDIO_SDL
+#include "SDL.h"
+#endif
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef HAVE_LIBREADLINE
+#include <readline/history.h>
+#include <readline/readline.h>
+#endif
+
+#include <gtk/gtk.h>
+#include <gdk/gdkkeysyms.h>
+
+/* utility */
+#include "fciconv.h"
+#include "log.h"
+#include "netintf.h"
+#include "rand.h"
+#include "shared.h"
+#include "support.h"
+
+/* common */
+#include "console.h"
+#include "game.h"
+
+/* client */
+#include "chatline_common.h"
+#include "client_main.h"
+#include "clinet.h"
+#include "editgui_g.h"
+#include "ggz_g.h"
+#include "options.h"
+#include "tilespec.h"
+
+/* client/mapimg */
+#include "mapimg.h"  /* MaPfa */
+#include "resources.h"
+
+#include "gui_main.h"
+
+const char *client_string = "gui-mapimg";
+
+const char * const gui_character_encoding = "UTF-8";
+const bool gui_use_transliteration = FALSE;
+
+static gint timer_id; /* main timer */
+static guint input_id;
+
+static gboolean timer_callback(gpointer data);
+static void get_net_input(gpointer data, gint fid, GdkInputCondition condition);
+static void set_wait_for_writable_socket(struct connection *pc,
+                                         bool socket_writable);
+static gint idle_callback_wrapper(gpointer data);
+
+static void log_callback_utf8(enum log_level level, const char *message,
+                              bool file_too);
+static void parse_options(int argc, char **argv);
+static void print_usage(const char *argv0);
+static void mapimg_main(void);
+
+static bool handle_client_stdin_input(char *str);
+static enum client_events client_sniff_all_input(void);
+
+enum client_events {
+  C_E_END_OF_TURN_TIMEOUT,
+  C_E_OTHERWISE,
+  C_E_FORCE_END_OF_SNIFF,
+};
+
+#define BUF_SIZE 512
+static bool force_end_of_sniff;
+static int lastturn = -1;
+static bool no_input = FALSE;
+static bool readline_initialized = FALSE;
+static bool readline_handled_input = FALSE;
+static int sock;
+
+/****************************************************************************
+  Called by the tileset code to set the font size that should be used to
+  draw the city names and productions.
+****************************************************************************/
+void set_city_names_font_sizes(int my_city_names_font_size,
+			       int my_city_productions_font_size)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Do any necessary pre-initialization of the UI, if necessary.
+**************************************************************************/
+void ui_init(void)
+{
+  log_set_callback(log_callback_utf8);
+}
+
+/**************************************************************************
+  Entry point for whole freeciv client program.
+**************************************************************************/
+int main(int argc, char **argv)
+{
+  return client_main(argc, argv);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+static void log_callback_utf8(enum log_level level, const char *message,
+                              bool file_too)
+{
+  if (!file_too || level <= LOG_FATAL) {
+    fc_fprintf(stderr, "%d: %s\n", level, message);
+  }
+}
+
+/**************************************************************************
+ Called while in gtk_main() (which is all of the time)
+ TIMER_INTERVAL is now set by real_timer_callback()
+**************************************************************************/
+static gboolean timer_callback(gpointer data)
+{
+  double seconds = real_timer_callback();
+  static int count = 0;
+
+  log_error("timer_callback(): run %4d", count);
+  count++;
+
+  mapimg_main();
+
+  timer_id = g_timeout_add(seconds * 1000, timer_callback, NULL);
+
+  return FALSE;
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+static void get_net_input(gpointer data, gint fid, GdkInputCondition condition)
+{
+  input_from_server(fid);
+}
+
+/**************************************************************************
+...
+**************************************************************************/
+static void set_wait_for_writable_socket(struct connection *pc,
+					 bool socket_writable)
+{
+  static bool previous_state = FALSE;
+
+  assert(pc == &client.conn);
+
+  if (previous_state == socket_writable)
+    return;
+
+  log_debug("set_wait_for_writable_socket(%d)", socket_writable);
+  gtk_input_remove(input_id);
+  input_id = gtk_input_add_full(client.conn.sock, GDK_INPUT_READ
+				| (socket_writable ? GDK_INPUT_WRITE : 0)
+				| GDK_INPUT_EXCEPTION,
+				get_net_input, NULL, NULL, NULL);
+  previous_state = socket_writable;
+}
+
+/**************************************************************************
+  Main function for mapimg.
+**************************************************************************/
+static void mapimg_main(void)
+{
+  /* MaPfa */
+  /* use this as starting point for mapimg */
+  char mapdef[128];
+  char basename[128];
+  static int saveturn = -1;
+  static bool colortest = TRUE;
+  static bool observer = FALSE;
+  static int rand;
+  int i;
+
+  if (client.conn.used && !client.conn.observer&& ! observer) {
+    log_error("update_info_label(): send '/observe'");
+    send_chat_printf("/detach");
+    send_chat_printf("/observe");
+    observer = TRUE;
+  }
+
+  if (C_S_RUNNING != client_state()) {
+    return;
+  }
+
+  if (C_S_OVER == client_state()) {
+    client_exit();
+  }
+
+log_error("mapimg_main()");
+
+  if (saveturn == -1) {
+    rand = myrand(1000);
+  }
+
+  if ((client_is_observer() || client_is_global_observer())
+      && client_state() == C_S_RUNNING && mapimg_count() == 0) {
+    if (!client_is_global_observer()) {
+      my_snprintf(mapdef, sizeof(mapdef),
+                  "show=plrbv:plrbv=100:zoom=2:map=bcfktu");
+    } else {
+      my_snprintf(mapdef, sizeof(mapdef),
+                  "show=all:zoom=2:map=bcfktu");
+    }
+
+    log_error("map definition: %s", mapdef);
+    if (!mapimg_define(mapdef, FALSE)) {
+      log_error("ERROR: %s\n(map definition: %s)", mapimg_error(), mapdef);
+    }
+  }
+
+  for (i = 0; i < mapimg_count(); i++) {
+    if (!mapimg_isvalid(i)) {
+      log_error("map %d: %s", i, mapimg_error());
+    } else if (colortest) {
+      colortest = FALSE;
+      my_snprintf(basename, sizeof(basename), "test");
+      if (!mapimg_colortest(basename)) {
+        log_error("%s", mapimg_error());
+      }
+    }
+  }
+
+  /* create map images */
+  for (i = 0; i < mapimg_count(); i++) {
+    if (mapimg_isvalid(i)) {
+      if (saveturn != game.info.turn) {
+        saveturn = game.info.turn;
+        my_snprintf(basename, sizeof(basename), "test%03d-T%03d", rand, game.info.turn);
+        if (!mapimg_create(i, basename, TRUE)) {
+          log_error("%s", mapimg_error());
+        }
+      }
+    }
+  }
+
+  client_sniff_all_input();
+}
+
+/*****************************************************************************
+...
+*****************************************************************************/
+static void handle_readline_input_callback(char *line)
+{
+  char *line_internal;
+
+  if (no_input) {
+    return;
+  }
+
+  if (line[0] != '\0')
+    add_history(line);
+
+  con_prompt_enter();		/* just got an 'Enter' hit */
+  line_internal = local_to_internal_string_malloc(line);
+  (void) handle_client_stdin_input(line_internal);
+  free(line_internal);
+  free(line);
+
+  readline_handled_input = TRUE;
+}
+
+/*****************************************************************************
+  copy of sernet.c:server_sniff_all_input()
+*****************************************************************************/
+static enum client_events client_sniff_all_input(void)
+{
+  int max_desc;
+  fd_set readfs, writefs, exceptfs;
+  struct timeval tv;
+#ifdef SOCKET_ZERO_ISNT_STDIN
+  char *bufptr;
+#endif
+
+  con_prompt_init();
+
+#ifdef HAVE_LIBREADLINE
+  {
+    if (!no_input && !readline_initialized) {
+      rl_initialize();
+      rl_callback_handler_install((char *) "> ",
+                                  handle_readline_input_callback);
+
+      readline_initialized = TRUE;
+      atexit(rl_callback_handler_remove);
+    }
+  }
+#endif /* HAVE_LIBREADLINE */
+
+  while (TRUE) {
+    con_prompt_on();                /* accepting new input */
+
+    if (force_end_of_sniff) {
+      force_end_of_sniff = FALSE;
+      con_prompt_off();
+      return C_E_FORCE_END_OF_SNIFF;
+    }
+
+    /* Don't wait if timeout == -1 (i.e. on auto games) */
+    if (C_S_RUNNING == client_state() && game.info.timeout == -1) {
+      return C_E_END_OF_TURN_TIMEOUT;
+    }
+
+    tv.tv_sec = 1;
+    tv.tv_usec = 0;
+
+    MY_FD_ZERO(&readfs);
+    MY_FD_ZERO(&writefs);
+    MY_FD_ZERO(&exceptfs);
+
+    if (!no_input) {
+#ifdef SOCKET_ZERO_ISNT_STDIN
+      my_init_console();
+#else /* SOCKET_ZERO_ISNT_STDIN */
+#   if !defined(__VMS)
+      FD_SET(0, &readfs);
+#   endif /* VMS */
+#endif /* SOCKET_ZERO_ISNT_STDIN */
+    }
+
+    FD_SET(sock, &readfs);
+    FD_SET(sock, &exceptfs);
+    max_desc = sock;
+
+    con_prompt_off(); /* output doesn't generate a new prompt */
+
+    if (fc_select(max_desc + 1, &readfs, &writefs, &exceptfs, &tv) == 0) {
+      if (lastturn != game.info.turn) {
+        con_prompt_off();
+log_error("lastturn");
+        lastturn = game.info.turn;
+        return C_E_END_OF_TURN_TIMEOUT;
+      }
+    }
+
+#ifdef SOCKET_ZERO_ISNT_STDIN
+    if (!no_input && (bufptr = my_read_console())) {
+      char *bufptr_internal = local_to_internal_string_malloc(bufptr);
+
+      con_prompt_enter();	/* will need a new prompt, regardless */
+      handle_client_stdin_input(bufptr_internal);
+      free(bufptr_internal);
+    }
+#else  /* !SOCKET_ZERO_ISNT_STDIN */
+    if(!no_input && FD_ISSET(0, &readfs)) {    /* input from server operator */
+#ifdef HAVE_LIBREADLINE
+      rl_callback_read_char();
+      if (readline_handled_input) {
+        readline_handled_input = FALSE;
+        con_prompt_enter_clear();
+      }
+      continue;
+#else  /* !HAVE_LIBREADLINE */
+      ssize_t didget;
+      char *buffer = NULL; /* Must be NULL when calling getline() */
+      char *buf_internal;
+
+#ifdef HAVE_GETLINE
+      size_t len = 0;
+
+      didget = getline(&buffer, &len, stdin);
+      if (didget >= 1) {
+        buffer[didget-1] = '\0'; /* overwrite newline character */
+        didget--;
+        log_debug("Got line: \"%s\" (%ld, %ld)", buffer,
+                  (long int) didget, (long int) len);
+      }
+#else  /* HAVE_GETLINE */
+      buffer = malloc(BUF_SIZE + 1);
+
+      didget = read(0, buffer, BUF_SIZE);
+      if (didget < 0) {
+        didget = 0; /* Avoid buffer underrun below. */
+      }
+      *(buffer+didget)='\0';
+#endif /* HAVE_GETLINE */
+      if (didget <= 0) {
+        handle_stdin_close();
+      }
+
+      con_prompt_enter();        /* will need a new prompt, regardless */
+
+      if (didget >= 0) {
+        buf_internal = local_to_internal_string_malloc(buffer);
+        handle_client_stdin_input(buf_internal);
+        free(buf_internal);
+      }
+      free(buffer);
+#endif /* !HAVE_LIBREADLINE */
+    }
+#endif /* !SOCKET_ZERO_ISNT_STDIN */
+
+/* TODO: input from server */
+
+    break;
+  }
+  con_prompt_off();
+
+  if (game.info.timeout > 0
+      && C_S_RUNNING == client_state()
+      && game.server.phase_timer) {
+    return C_E_END_OF_TURN_TIMEOUT;
+  }
+
+  return C_E_OTHERWISE;
+}
+
+/**************************************************************************
+  Print extra usage information, including one line help on each option,
+  to stderr. 
+**************************************************************************/
+static bool handle_client_stdin_input(char *str)
+{
+  con_puts(C_OK, str);
+
+  return TRUE;
+}
+
+/**************************************************************************
+  Print extra usage information, including one line help on each option,
+  to stderr. 
+**************************************************************************/
+static void print_usage(const char *argv0)
+{
+  /* add client-specific usage information here */
+  fc_fprintf(stderr, _("This client has no special command line options\n\n"));
+
+  /* TRANS: No full stop after the URL, could cause confusion. */
+  fc_fprintf(stderr, _("Report bugs at %s\n"), BUG_URL);
+}
+
+/**************************************************************************
+ search for command line options. right now, it's just help
+ semi-useless until we have options that aren't the same across all clients.
+**************************************************************************/
+static void parse_options(int argc, char **argv)
+{
+  int i = 1;
+
+  while (i < argc) {
+    if (is_option("--help", argv[i])) {
+      print_usage(argv[0]);
+      exit(EXIT_SUCCESS);
+    }
+    i++;
+  }
+}
+
+/**************************************************************************
+  The main loop for the UI.  This is called from main(), and when it
+  exits the client will exit.
+**************************************************************************/
+void ui_main(int argc, char *argv[])
+{
+  /* PORTME */
+  fc_fprintf(stderr, "Freeciv rules!\n");
+
+  const gchar *home;
+
+  parse_options(argc, argv);
+
+  /* the locale has already been set in init_nls() and the Win32-specific
+   * locale logic in gtk_init() causes problems with zh_CN (see PR#39475) */
+  gtk_disable_setlocale();
+
+  /* GTK withdraw gtk options. Process GTK arguments */
+  gtk_init(&argc, &argv);
+
+  /* Load resources */
+  gtk_rc_parse_string(fallback_resources);
+
+  home = g_get_home_dir();
+  if (home) {
+    gchar *str;
+
+    str = g_build_filename(home, ".freeciv.rc-2.0", NULL);
+    gtk_rc_parse(str);
+    g_free(str);
+  }
+
+  client_options_iterate(poption) {
+    if (COT_FONT == option_type(poption)) {
+      /* Force to call the appropriated callback. */
+      option_changed(poption);
+    }
+  } client_options_iterate_end;
+
+  tileset_init(tileset);
+  tileset_load_tiles(tileset);
+  tileset_use_prefered_theme(tileset);
+  mapimg_init(); /* MaPfa */
+
+log_error("try autoconnect: %s@%s:%d", user_name, server_host, server_port);
+  /* assumes toplevel showing */
+  set_client_state(C_S_DISCONNECTED);
+
+  /* assumes client_state is set */
+  timer_id = g_timeout_add(TIMER_INTERVAL, timer_callback, NULL);
+
+log_error("main_loop:start")
+log_error("tilespec: %s", tileset_get_name(tileset));
+  gtk_main();
+log_error("main_loop:end")
+
+  mapimg_free(); /* MaPfa */
+  tileset_free_tiles(tileset);
+}
+
+/****************************************************************************
+  Extra initializers for client options.
+****************************************************************************/
+void gui_options_extra_init(void)
+{
+  /* Nothing to do. */
+}
+
+/**************************************************************************
+  Do any necessary UI-specific cleanup
+**************************************************************************/
+void ui_exit()
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Return our GUI type
+**************************************************************************/
+enum gui_type get_gui_type(void)
+{
+  return GUI_MAPIMG;
+}
+
+/**************************************************************************
+ Update the connected users list at pregame state.
+**************************************************************************/
+void update_conn_list_dialog(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Make a bell noise (beep).  This provides low-level sound alerts even
+  if there is no real sound support.
+**************************************************************************/
+void sound_bell(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Wait for data on the given socket.  Call input_from_server() when data
+  is ready to be read.
+
+  This function is called after the client succesfully has connected
+  to the server.
+**************************************************************************/
+void add_net_input(int sock)
+{
+  input_id = gtk_input_add_full(sock, GDK_INPUT_READ | GDK_INPUT_EXCEPTION,
+                                get_net_input, NULL, NULL, NULL);
+  client.conn.notify_of_writable_data = set_wait_for_writable_socket;
+}
+
+/**************************************************************************
+  Stop waiting for any server network data.  See add_net_input().
+
+  This function is called if the client disconnects from the server.
+**************************************************************************/
+void remove_net_input(void)
+{
+  gtk_input_remove(input_id);
+}
+
+/**************************************************************************
+  Called to monitor a GGZ socket.
+**************************************************************************/
+void add_ggz_input(int sock)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Called on disconnection to remove monitoring on the GGZ socket.  Only
+  call this if we're actually in GGZ mode.
+**************************************************************************/
+void remove_ggz_input(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Set one of the unit icons (specified by idx) in the information area
+  based on punit.
+
+  punit is the unit the information should be taken from. Use NULL to
+  clear the icon.
+
+  idx specified which icon should be modified. Use idx==-1 to indicate
+  the icon for the active unit. Or idx in [0..num_units_below-1] for
+  secondary (inactive) units on the same tile.
+**************************************************************************/
+void set_unit_icon(int idx, struct unit *punit)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Most clients use an arrow (e.g., sprites.right_arrow) to indicate when
+  the units_below will not fit. This function is called to activate or
+  deactivate the arrow.
+
+  Is disabled by default.
+**************************************************************************/
+void set_unit_icons_more_arrow(bool onoff)
+{
+  /* PORTME */
+}
+
+struct callback {
+  void (*callback)(void *data);
+  void *data;
+};
+
+/****************************************************************************
+  A wrapper for the callback called through add_idle_callback.
+****************************************************************************/
+static gint idle_callback_wrapper(gpointer data)
+{
+  struct callback *cb = data;
+
+  (cb->callback)(cb->data);
+  free(cb);
+  return 0;
+}
+
+/****************************************************************************
+  Enqueue a callback to be called during an idle moment.  The 'callback'
+  function should be called sometimes soon, and passed the 'data' pointer
+  as its data.
+****************************************************************************/
+void add_idle_callback(void (callback)(void *), void *data)
+{
+  struct callback *cb = fc_malloc(sizeof(*cb));
+
+  cb->callback = callback;
+  cb->data = data;
+  gtk_idle_add(idle_callback_wrapper, cb);
+}
+
+/****************************************************************************
+  Stub for editor function
+****************************************************************************/
+void editgui_tileset_changed(void)
+{}
+
+/****************************************************************************
+  Stub for editor function
+****************************************************************************/
+void editgui_refresh(void)
+{}
+
+/****************************************************************************
+  Stub for editor function
+****************************************************************************/
+void editgui_popup_properties(const struct tile_list *tiles, int objtype)
+{}
+
+/****************************************************************************
+  Stub for editor function
+****************************************************************************/
+void editgui_popdown_all(void)
+{}
+
+/****************************************************************************
+  Stub for editor function
+****************************************************************************/
+void editgui_notify_object_changed(int objtype, int object_id, bool remove)
+{}
+
+/****************************************************************************
+  Stub for editor function
+****************************************************************************/
+void editgui_notify_object_created(int tag, int id)
+{}
+
+/****************************************************************************
+  Stub for ggz function
+****************************************************************************/
+void gui_ggz_embed_leave_table(void)
+{}
+
+/****************************************************************************
+  Stub for ggz function
+****************************************************************************/
+void gui_ggz_embed_ensure_server(void)
+{}
+
+
+/**************************************************************************
+  Updates a gui font style.
+**************************************************************************/
+void gui_update_font(const char *font_name, const char *font_value)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/gui_main.h b/client/gui-gtk-2.0-mapimg/gui_main.h
new file mode 100644
index 0000000..266f4a9
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/gui_main.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__GUI_MAIN_H
+#define FC__GUI_MAIN_H
+
+#include "gui_main_g.h"
+
+
+#endif				/* FC__GUI_MAIN_H */
diff --git a/client/gui-gtk-2.0-mapimg/helpdlg.c b/client/gui-gtk-2.0-mapimg/helpdlg.c
new file mode 100644
index 0000000..20ed8e4
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/helpdlg.c
@@ -0,0 +1,51 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "fcintl.h"
+
+#include "helpdlg.h"
+
+/**************************************************************************
+  Popup the help dialog to get help on the given string topic.  Note
+  that the topic may appear in multiple sections of the help (it may
+  be both an improvement and a unit, for example).
+
+  The given string should be untranslated.
+**************************************************************************/
+void popup_help_dialog_string(const char *item)
+{
+  popup_help_dialog_typed(_(item), HELP_ANY);
+}
+
+/**************************************************************************
+  Popup the help dialog to display help on the given string topic from
+  the given section.
+
+  The string will be translated.
+**************************************************************************/
+void popup_help_dialog_typed(const char *item, enum help_page_type htype)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Close the help dialog.
+**************************************************************************/
+void popdown_help_dialog(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/helpdlg.h b/client/gui-gtk-2.0-mapimg/helpdlg.h
new file mode 100644
index 0000000..da0e904
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/helpdlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__HELPDLG_H
+#define FC__HELPDLG_H
+
+#include "helpdlg_g.h"
+
+
+#endif				/* FC__HELPDLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/inteldlg.c b/client/gui-gtk-2.0-mapimg/inteldlg.c
new file mode 100644
index 0000000..7ecd2b8
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/inteldlg.c
@@ -0,0 +1,35 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "inteldlg.h"
+
+/**************************************************************************
+  Popup an intelligence dialog for the given player.
+**************************************************************************/
+void popup_intel_dialog(struct player *p)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Update the intelligence dialog for the given player.  This is called by
+  the core client code when that player's information changes.
+****************************************************************************/
+void update_intel_dialog(struct player *p)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/inteldlg.h b/client/gui-gtk-2.0-mapimg/inteldlg.h
new file mode 100644
index 0000000..6213554
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/inteldlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 2003 - The Freeciv Project
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__INTELDLG_H
+#define FC__INTELDLG_H
+
+#include "inteldlg_g.h"
+
+/* nothing to add */
+
+#endif				/* FC__INTELDLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/mapctrl.c b/client/gui-gtk-2.0-mapimg/mapctrl.c
new file mode 100644
index 0000000..6c4c793
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/mapctrl.c
@@ -0,0 +1,55 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+
+#include "mapctrl.h"
+
+/**************************************************************************
+  Popup a dialog to ask for the name of a new city.  The given string
+  should be used as a suggestion.
+**************************************************************************/
+void popup_newcity_dialog(struct unit *punit, char *suggestname)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  A turn done button should be provided for the player.  This function
+  is called to toggle it between active/inactive.
+**************************************************************************/
+void set_turn_done_button_state(bool state)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Draw a goto or patrol line at the current mouse position.
+**************************************************************************/
+void create_line_at_mouse_pos(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+ The Area Selection rectangle. Called by center_tile_mapcanvas() and
+ when the mouse pointer moves.
+**************************************************************************/
+void update_rect_at_mouse_pos(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/mapctrl.h b/client/gui-gtk-2.0-mapimg/mapctrl.h
new file mode 100644
index 0000000..07efb43
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/mapctrl.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__MAPCTRL_H
+#define FC__MAPCTRL_H
+
+#include "mapctrl_g.h"
+
+
+#endif				/* FC__MAPCTRL_H */
diff --git a/client/gui-gtk-2.0-mapimg/mapimg.c b/client/gui-gtk-2.0-mapimg/mapimg.c
new file mode 100644
index 0000000..054e826
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/mapimg.c
@@ -0,0 +1,2634 @@
+/****************************************************************************
+ Freeciv - Copyright (C) 2010 - The Freeciv Team
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+****************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <assert.h>
+#ifdef HAVE_WAND
+  #include <wand/MagickWand.h>
+#endif /* HAVE_WAND */
+
+#include <gtk/gtk.h>
+
+/* utility */
+#include "astring.h"
+#include "fcintl.h"
+#include "log.h"
+#include "mem.h"
+#include "shared.h"
+#include "timing.h"
+
+/* common */
+#include "fc_types.h"
+#include "game.h"
+#include "map.h"
+#include "terrain.h"
+#include "tile.h"
+#include "version.h"
+
+/* client */
+#include "colors.h"
+#include "colors_common.h"
+#include "tilespec.h"
+
+#include "mapimg.h"
+
+/* definitions for the different topologies */
+#define TILE_SIZE 6
+#define NUM_PIXEL TILE_SIZE * TILE_SIZE
+
+BV_DEFINE(bv_pixel, NUM_PIXEL);
+
+struct tile_shape {
+  int x[NUM_PIXEL];
+  int y[NUM_PIXEL];
+};
+
+typedef bv_pixel (*plot_func_t)(const int x, const int y);
+typedef void (*base_coor_func_t)(int *base_x, int *base_y, int x, int y);
+
+/* (isometric) rectangular topology */
+static struct tile_shape tile_rect = {
+  .x = {
+    0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3, 4, 5
+  },
+  .y = {
+    0, 0, 0, 0, 0, 0,
+    1, 1, 1, 1, 1, 1,
+    2, 2, 2, 2, 2, 2,
+    3, 3, 3, 3, 3, 3,
+    4, 4, 4, 4, 4, 4,
+    5, 5, 5, 5, 5, 5
+  }
+};
+
+static bv_pixel pixel_tile_rect(const int x, const int y);
+static bv_pixel pixel_city_rect(const int x, const int y);
+static bv_pixel pixel_unit_rect(const int x, const int y);
+static bv_pixel pixel_fogofwar_rect(const int x, const int y);
+static bv_pixel pixel_border_rect(const int x, const int y);
+static void base_coor_rect(int *base_x, int *base_y, int x, int y);
+
+/* hexa topology */
+static struct tile_shape tile_hexa = {
+  .x = {
+          2, 3,
+       1, 2, 3, 4,
+    0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3, 4, 5,
+       1, 2, 3, 4,
+          2, 3,
+  },
+  .y = {
+          0, 0,
+       1, 1, 1, 1,
+    2, 2, 2, 2, 2, 2,
+    3, 3, 3, 3, 3, 3,
+    4, 4, 4, 4, 4, 4,
+    5, 5, 5, 5, 5, 5,
+       6, 6, 6, 6,
+          7, 7,
+  }
+};
+
+static bv_pixel pixel_tile_hexa(const int x, const int y);
+static bv_pixel pixel_city_hexa(const int x, const int y);
+static bv_pixel pixel_unit_hexa(const int x, const int y);
+static bv_pixel pixel_fogofwar_hexa(const int x, const int y);
+static bv_pixel pixel_border_hexa(const int x, const int y);
+static void base_coor_hexa(int *base_x, int *base_y, int x, int y);
+
+/* isomeric hexa topology */
+static struct tile_shape tile_isohexa = {
+  .x = {
+          2, 3, 4, 5,
+       1, 2, 3, 4, 5, 6,
+    0, 1, 2, 3, 4, 5, 6, 7,
+    0, 1, 2, 3, 4, 5, 6, 7,
+       1, 2, 3, 4, 5, 6,
+          2, 3, 4, 5
+  },
+  .y = {
+          0, 0, 0, 0,
+       1, 1, 1, 1, 1, 1,
+    2, 2, 2, 2, 2, 2, 2, 2,
+    3, 3, 3, 3, 3, 3, 3, 3,
+       4, 4, 4, 4, 4, 4,
+          5, 5, 5, 5
+  }
+};
+
+static bv_pixel pixel_tile_isohexa(const int x, const int y);
+static bv_pixel pixel_city_isohexa(const int x, const int y);
+static bv_pixel pixel_unit_isohexa(const int x, const int y);
+static bv_pixel pixel_fogofwar_isohexa(const int x, const int y);
+static bv_pixel pixel_border_isohexa(const int x, const int y);
+static void base_coor_isohexa(int *base_x, int *base_y, int x, int y);
+
+/* image definition */
+#define SPECENUM_NAME imageformat
+#define SPECENUM_VALUE0 IMG_GIF
+#define SPECENUM_VALUE1 IMG_PNG
+#define SPECENUM_VALUE2 IMG_PPM
+#define SPECENUM_VALUE3 IMG_JPG
+#include "specenum_gen.h"
+
+/* imageformat extensions */
+static const char *image_extension[] = {
+  "gif", "png", "ppm", "jpg", NULL
+};
+
+/* background color; used by MagickWand */
+#define SPECENUM_NAME background
+#define SPECENUM_VALUE0 BG_WHITE
+#define SPECENUM_VALUE1 BG_BLACK
+#define SPECENUM_VALUE2 BG_NONE
+#include "specenum_gen.h"
+
+/* background color string; used by MagickWand */
+static const char *img_bg_color[] = {
+  "white", "black", "none", NULL
+};
+
+/* foreground color string; used by MagickWand */
+static const char *img_fg_color[] = {
+  "black", "white", "black", NULL
+};
+
+/* player definitions */
+#define SPECENUM_NAME show_player
+#define SPECENUM_VALUE0 SHOW_NONE
+#define SPECENUM_VALUE1 SHOW_PLRNAME
+#define SPECENUM_VALUE2 SHOW_PLRID
+#define SPECENUM_VALUE3 SHOW_PLRBV
+#define SPECENUM_VALUE4 SHOW_EACH
+#define SPECENUM_VALUE5 SHOW_ALL
+#include "specenum_gen.h"
+
+/* player definition strings */
+static const char *str_showplr[] = {
+  "none", "plrname", "plrid", "plrbv", "each", "all", NULL
+};
+
+/* map definition status */
+#define SPECENUM_NAME mapimg_status
+#define SPECENUM_VALUE0 MAPIMG_CHECK
+#define SPECENUM_VALUE1 MAPIMG_OK
+#define SPECENUM_VALUE2 MAPIMG_ERROR
+#include "specenum_gen.h"
+
+/* map definition status strings */
+static const char *str_status[] = {
+  "not checked", "OK", "error", NULL
+};
+
+#define MAX_LEN_STR 128
+#define MAX_LEN_MAPARG MAX_LEN_STR
+
+/* map definition */
+struct mapdef {
+  char maparg[MAX_LEN_MAPARG];
+  char error[MAX_LEN_STR];
+  enum mapimg_status status;
+  enum imageformat imgformat;
+  enum background bg;
+  int zoom;
+  int turns;
+  bool terrain;
+  bool cities;
+  bool units;
+  bool borders;
+  bool known;
+  bool fogofwar;
+  bool area;
+  struct {
+    enum show_player show;
+    union {
+      char name[MAX_LEN_NAME];
+      int id;
+    } plr;
+    bv_player plrbv;
+  } player;
+};
+
+static struct mapdef *mapdef_default(void);
+static void mapdef_destroy(struct mapdef *pmapdef);
+
+#define SPECLIST_TAG mapdef
+#define SPECLIST_TYPE struct mapdef
+#include "speclist.h"
+
+#define mapdef_list_iterate(mapdef_list, pmapdef) \
+  TYPED_LIST_ITERATE(struct mapdef, mapdef_list, pmapdef)
+#define mapdef_list_iterate_end \
+  LIST_ITERATE_END
+
+/* image definitions */
+struct img {
+  struct mapdef *def; /* map definition */
+  int turn; /* save turn */
+  char title[MAX_LEN_STR];
+
+  /* topology definition */
+  struct tile_shape *tileshape;
+  plot_func_t pixel_tile;
+  plot_func_t pixel_city;
+  plot_func_t pixel_unit;
+  plot_func_t pixel_fogofwar;
+  plot_func_t pixel_border;
+  base_coor_func_t base_coor;
+
+  struct {
+    int x;
+    int y;
+  } size; /* image size */
+  struct color **map;
+};
+
+static struct img *img_new(struct mapdef *mapdef);
+static void img_destroy(struct img *pimg);
+static inline void img_set_pixel(struct img *pimg, const int index,
+                                 struct color *pcolor);
+static inline int img_index(const int x, const int y,
+                            const struct img *pimg);
+static void img_plot(struct img *pimg, const int x, const int y,
+                     struct color *pcolor, const bv_pixel pixel);
+static bool img_save(const struct img *pimg, const char *filename);
+static void img_createmap(struct img *pimg);
+
+/* mapimg data */
+static struct {
+  bool init;
+  struct mapdef_list *mapdef;
+} mapimg = { .init = FALSE };
+
+static inline bool mapimg_initialised(void);
+static bool mapimg_def2str(const char **str_def, struct mapdef *pmapdef);
+static bool mapimg_checkplayers(struct mapdef *pmapdef);
+
+#define MAX_NUM_MAPIMG 10
+
+/* logging */
+#define MAX_LEN_ERRORBUF 1024
+
+static char error_buffer[MAX_LEN_ERRORBUF] = "\0";
+static void mapimg_log(const char *file, const char *function, int line,
+                       const char *format, ...)
+                       fc__attribute((__format__(__printf__, 4, 5)));
+#define MAPIMG_LOG(format, ...)                                             \
+  mapimg_log(__FILE__, __FUNCTION__, __LINE__, format, ## __VA_ARGS__)
+#define MAPIMG_RETURN_IF_FAIL(condition)                                    \
+  if (!(condition)) {                                                       \
+    MAPIMG_LOG("Assertion '%s' failed.", #condition);                       \
+    return;                                                                 \
+  }
+#define MAPIMG_RETURN_VAL_IF_FAIL(condition, value)                         \
+  if (!(condition)) {                                                       \
+    MAPIMG_LOG("Assertion '%s' failed.", #condition);                       \
+    return value;                                                           \
+  }
+
+static int generate_img_name(char *buf, int buflen,
+                             const struct mapdef *pmapdef,
+                             const char *basename);
+static char *bvplayers_str(const struct mapdef *pmapdef);
+static int bvplayers_count(const struct mapdef *pmapdef);
+
+static bool game_was_started_todo(void);
+
+/*
+ * ==============================================
+ * mapimg - external functions
+ * ==============================================
+ */
+
+/**************************************************************************
+  Initialisation of the map image subsystem.
+**************************************************************************/
+void mapimg_init(void)
+{
+  if (mapimg_initialised()) {
+    return;
+  }
+
+#ifndef HAVE_WAND
+  log_normal("no MagickWand available - falling back to ppm images");
+#endif
+
+  mapimg.mapdef = mapdef_list_new();
+
+  mapimg.init = TRUE;
+}
+
+/**************************************************************************
+  Reset the map image subsystem.
+**************************************************************************/
+void mapimg_reset(void)
+{
+  if (!mapimg_initialised()) {
+    return;
+  }
+
+  if (mapdef_list_size(mapimg.mapdef) > 0) {
+    mapdef_list_iterate(mapimg.mapdef, pmapdef) {
+      mapdef_list_unlink(mapimg.mapdef, pmapdef);
+      mapdef_destroy(pmapdef);
+    } mapdef_list_iterate_end;
+  }
+}
+
+/**************************************************************************
+  Free all memory allocated by the map image subsystem.
+**************************************************************************/
+void mapimg_free(void)
+{
+  if (!mapimg_initialised()) {
+    return;
+  }
+
+  mapimg_reset();
+  mapdef_list_free(mapimg.mapdef);
+
+  mapimg.init = FALSE;
+}
+
+/**************************************************************************
+  Return the number of map image definitions.
+**************************************************************************/
+int mapimg_count(void)
+{
+  if (!mapimg_initialised()) {
+    return 0;
+  }
+
+  return mapdef_list_size(mapimg.mapdef);
+}
+
+/**************************************************************************
+  Return a help for the map definition
+**************************************************************************/
+const char *mapimg_help(void)
+{
+  enum imageformat format;
+  enum background bg;
+  enum show_player showplr;
+  char tmp[128], tmp_bg[128], tmp_ext[128], tmp_showplr[128];
+  static char help[2048];
+
+  /* background color settings */
+  tmp_bg[0] = '\0';
+  for (bg = background_begin(); bg != background_end();
+       bg = background_next(bg)) {
+    if (bg != background_max()) {
+      my_snprintf(tmp, sizeof(tmp), "'%s', ", img_bg_color[bg]);
+      sz_strlcat(tmp_bg, tmp);
+    } else {
+      my_snprintf(tmp, sizeof(tmp), "'%s'", img_bg_color[bg]);
+      sz_strlcat(tmp_bg, tmp);
+    }
+  }
+
+  /* image extension settings */
+  tmp_ext[0] = '\0';
+  for (format = imageformat_begin(); format != imageformat_end();
+       format = imageformat_next(format)) {
+    if (format != imageformat_max()) {
+      my_snprintf(tmp, sizeof(tmp), "'%s', ", image_extension[format]);
+      sz_strlcat(tmp_ext, tmp);
+    } else {
+      my_snprintf(tmp, sizeof(tmp), "'%s'", image_extension[format]);
+      sz_strlcat(tmp_ext, tmp);
+    }
+  }
+
+  /* show player settings */
+  tmp_showplr[0] = '\0';
+  for (showplr = show_player_begin(); showplr != show_player_end();
+       showplr = show_player_next(showplr)) {
+    if (showplr != show_player_max()) {
+      my_snprintf(tmp, sizeof(tmp), "'%s', ", str_showplr[showplr]);
+      sz_strlcat(tmp_showplr, tmp);
+    } else {
+      my_snprintf(tmp, sizeof(tmp), "'%s'", str_showplr[showplr]);
+      sz_strlcat(tmp_showplr, tmp);
+    }
+  }
+
+  /* help text */
+  my_snprintf(help, sizeof(help),
+    _("Available map image options <mapdef>:\n"
+      " * bg              background color (%s)\n"
+      " * format          image format (%s)\n"
+      " * show <value>    show players:\n"
+      "                   (%s) \n"
+      " * plrname <value> player name (if show=plrname)\n"
+      " * plrid <value>   player id (if show=plrid)\n"
+      " * plrbv <value>   player bitvector (if show=plrbv)\n"
+      " * turns <value>   save each <value> turns (0 = no autosave)\n"
+      " * zoom <value>    zoom factor (1 <= zoom <= 5)\n"
+      " * map <mapdef>    definition of the map\n"
+      "\n"
+      "The map image definition <mapdef> string can contain: \n"
+      " - 'a' show area within borders\n"
+      " - 'b' show borders\n"
+      " - 'c' show cities\n"
+      " - 'f' show fogofwar\n"
+      " - 'k' show only known terrain\n"
+      " - 't' full terrain\n"
+      " - 'u' show units\n"
+      "\n"
+      "'k' and 'f' are only available if the map is drawn for one player\n"
+      "\n"
+      "Examples:\n"
+      " 'zoom=1:map=tcub:show=all:bg=none:format=gif'\n"
+      " 'zoom=2:map=tcub:show=each:bg=black:format=png'\n"
+      " 'zoom=1:map=tcub:show=player:player=Otto:bg=none:format=gif'\n"
+      " 'zoom=3:map=cu:show=plrbv:plrbv=010011:bg=white:format=jpg'\n"
+      " 'zoom=1:map=t:show=none:bg=white:format=jpg'"),
+    tmp_bg, tmp_ext, tmp_showplr);
+
+  return help;
+}
+
+/**************************************************************************
+  Returns the last error.
+**************************************************************************/
+const char *mapimg_error(void)
+{
+  return error_buffer;
+}
+
+/**************************************************************************
+  Define on map image.
+**************************************************************************/
+#define NUM_MAPARGS 10
+#define NUM_MAPOPTS 2
+bool mapimg_define(char *maparg, bool check)
+{
+  struct mapdef *pmapdef = NULL;
+  char *mapargs[NUM_MAPARGS], *mapopts[NUM_MAPOPTS];
+  char plrname[MAX_LEN_STR];
+  int plrid;
+  bv_player plrbv;
+  int nmapargs, nmapopts, i;
+  bool set_plrname = FALSE, set_plrid = FALSE, set_plrbv = FALSE;
+  bool ret = TRUE;
+
+  if (!mapimg_initialised()) {
+    MAPIMG_LOG("Map images not initialised!");
+    return FALSE;
+  }
+
+  if (maparg == NULL) {
+    MAPIMG_LOG("No map definition");
+    return FALSE;
+  }
+
+  if (strlen(maparg) > MAX_LEN_MAPARG) {
+    /* to long map definition string */
+    MAPIMG_LOG("Map definition string to long (max %d characters)",
+               MAX_LEN_MAPARG);
+    return FALSE;
+  }
+
+  if (mapimg_count() == MAX_NUM_MAPIMG) {
+    MAPIMG_LOG("Maximal number of map definitions reached (%d)",
+               MAX_NUM_MAPIMG);
+    return FALSE;
+  }
+
+  pmapdef = mapdef_default();
+
+  /* get map options */
+  nmapargs = get_tokens(maparg, mapargs, NUM_MAPARGS, ":");
+
+  for (i = 0; i < nmapargs; i++) {
+    /* split map options into variable and value */
+    nmapopts = get_tokens(mapargs[i], mapopts, NUM_MAPOPTS, "=");
+
+    if (nmapopts == 2) {
+      if (0 == strcmp(mapopts[0], "bg")) {
+        /* background */
+        enum background bg;
+        bool found = FALSE;
+
+        for (bg = background_begin(); bg != background_end();
+             bg = background_next(bg)) {
+          if (0 == strcmp(mapopts[1], img_bg_color[bg])) {
+            pmapdef->bg = bg;
+            found = TRUE;
+            break;
+          }
+        }
+
+        if (!found) {
+          MAPIMG_LOG("invalid value for option %s: '%s'",
+                     mapopts[0], mapopts[1]);
+          ret = FALSE;
+        }
+      } else if (0 == strcmp(mapopts[0], "format")) {
+        /* file format */
+        enum imageformat format;
+        bool found = FALSE;
+
+        for (format = imageformat_begin(); format != imageformat_end();
+             format = imageformat_next(format)) {
+          if (0 == strcmp(mapopts[1], image_extension[format])) {
+            pmapdef->imgformat = format;
+            found = TRUE;
+            break;
+          }
+        }
+
+        if (!found) {
+          MAPIMG_LOG("invalid value for option %s: '%s'",
+                     mapopts[0], mapopts[1]);
+          ret = FALSE;
+        }
+      } else if (0 == strcmp(mapopts[0], "map")) {
+        /* map definition */
+        int len = strlen(mapopts[1]), l;
+
+        pmapdef->terrain = FALSE;
+        pmapdef->cities = FALSE;
+        pmapdef->units = FALSE;
+        pmapdef->borders = FALSE;
+        pmapdef->known = FALSE;
+        pmapdef->fogofwar = FALSE;
+        pmapdef->area = FALSE;
+
+        for (l = 0; l < len; l++) {
+          if (mapopts[1][l] == 't') {
+            pmapdef->terrain = TRUE;
+          } else if (mapopts[1][l] == 'c') {
+            pmapdef->cities = TRUE;
+          } else if (mapopts[1][l] == 'u') {
+            pmapdef->units = TRUE;
+          } else if (mapopts[1][l] == 'b') {
+            pmapdef->borders = TRUE;
+          } else if (mapopts[1][l] == 'k') {
+            pmapdef->known = TRUE;
+          } else if (mapopts[1][l] == 'f') {
+            pmapdef->fogofwar = TRUE;
+          } else if (mapopts[1][l] == 'a') {
+            pmapdef->area = TRUE;
+          } else {
+            MAPIMG_LOG("Map definition string contains invalid "
+                       "characters ('%c').", mapopts[1][l]);
+            ret = FALSE;
+          }
+        }
+      } else if (0 == strcmp(mapopts[0], str_showplr[SHOW_PLRNAME])) {
+        /* player definition - player name; will be check by mapimg_isvalid()
+         * which calls mapimg_checkplayers() */
+        if (strlen(mapopts[1]) > sizeof(plrname)) {
+          MAPIMG_LOG("Player name to long");
+          ret = FALSE;
+        } else {
+          sz_strlcpy(plrname, mapopts[1]);
+          set_plrname = TRUE;
+        }
+      } else if (0 == strcmp(mapopts[0], str_showplr[SHOW_PLRID])) {
+        /* player definition - player id; will be check by mapimg_isvalid()
+         * which calls mapimg_checkplayers() */
+        if (sscanf(mapopts[1], "%d", &plrid) != 0) {
+          if (plrid < 0 || plrid >= MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS) {
+            MAPIMG_LOG("plrid must be in the intervall [0, %d)",
+                       MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS);
+            ret = FALSE;
+          }
+          set_plrid = TRUE;
+        } else {
+          MAPIMG_LOG("invalid value for option %s: '%s'",
+                     mapopts[0], mapopts[1]);
+          ret = FALSE;
+        }
+      } else if (0 == strcmp(mapopts[0], str_showplr[SHOW_PLRBV])) {
+        /* player definition - bitvector */
+        int i;
+
+        if (strlen(mapopts[1]) < MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS + 1) {
+          BV_CLR_ALL(plrbv);
+          for (i = 0; i < strlen(mapopts[1]); i++) {
+            if (!strchr("01", mapopts[1][i])) {
+              MAPIMG_LOG("Invalid character in bitvector: '%s'", mapopts[1]);
+              ret = FALSE;
+              break;
+            } else if (mapopts[1][i] == '1') {
+              BV_SET(plrbv, i);
+            }
+          }
+        } else {
+          MAPIMG_LOG("invalid value for option %s: '%s'",
+                     mapopts[0], mapopts[1]);
+          ret = FALSE;
+        }
+        set_plrbv = TRUE;
+      } else if (0 == strcmp(mapopts[0], "show")) {
+        /* player definition - basic definition */
+        bool found = FALSE;
+        enum show_player showplr;
+
+        for (showplr = show_player_begin(); showplr != show_player_end();
+             showplr = show_player_next(showplr)) {
+          if (0 == strcmp(mapopts[1], str_showplr[showplr])) {
+            pmapdef->player.show = showplr;
+            found = TRUE;
+            break;
+          }
+        }
+
+        if (!found) {
+          MAPIMG_LOG("invalid value for option %s: '%s'",
+                     mapopts[0], mapopts[1]);
+          ret = FALSE;
+        }
+      } else if (0 == strcmp(mapopts[0], "turns")) {
+        /* save each <x> turns */
+        int turns;
+
+        if (sscanf(mapopts[1], "%d", &turns) != 0) {
+          if (turns < 0 || turns > 99) {
+            MAPIMG_LOG("turns should be between 0 and 99");
+            ret = FALSE;
+          } else {
+            pmapdef->turns = turns;
+          }
+        } else {
+          MAPIMG_LOG("invalid value for option %s: '%s'",
+                     mapopts[0], mapopts[1]);
+          ret = FALSE;
+        }
+      } else if (0 == strcmp(mapopts[0], "zoom")) {
+        /* zoom factor */
+        int zoom;
+
+        if (sscanf(mapopts[1], "%d", &zoom) != 0) {
+          if (zoom < 1 || zoom > 5) {
+            MAPIMG_LOG("zoom factor should be between 1 and 5");
+            ret = FALSE;
+          } else {
+            pmapdef->zoom = zoom;
+          }
+        } else {
+        }
+      } else {
+        /* unknown option */
+        MAPIMG_LOG("unknown map option: '%s'", mapargs[i]);
+        ret = FALSE;
+      }
+    } else {
+      MAPIMG_LOG("unknown map option: '%s'", mapargs[i]);
+      ret = FALSE;
+    }
+
+    free_tokens(mapopts, nmapopts);
+
+    if (!ret) {
+      break;
+    }
+  }
+  free_tokens(mapargs, nmapargs);
+
+  /* sanity check */
+  switch (pmapdef->player.show) {
+  case SHOW_PLRNAME: /* display player given by name */
+    if (!set_plrname) {
+      MAPIMG_LOG("show=%s but no player name", str_showplr[SHOW_PLRNAME]);
+      ret = FALSE;
+    } else {
+      sz_strlcpy(pmapdef->player.plr.name, plrname);
+    }
+    break;
+  case SHOW_PLRID:   /* display player given by id */
+    if (!set_plrid) {
+      MAPIMG_LOG("show=%s but no player id", str_showplr[SHOW_PLRID]);
+      ret = FALSE;
+    } else {
+      pmapdef->player.plr.id = plrid;
+    }
+    break;
+  case SHOW_PLRBV:   /* display players given by bitvector */
+    if (!set_plrbv) {
+      MAPIMG_LOG("show=%s but no player bitvector", str_showplr[SHOW_PLRBV]);
+      ret = FALSE;
+    } else {
+      BV_CLR_ALL(pmapdef->player.plrbv);
+      for (i = 0; i < MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS; i++) {
+        if (BV_ISSET(plrbv, i)) {
+          BV_SET(pmapdef->player.plrbv, i);
+        }
+      }
+    }
+    break;
+  case SHOW_NONE:    /* no player one the map */
+    BV_CLR_ALL(pmapdef->player.plrbv);
+    break;
+  case SHOW_ALL:     /* show all players in one map */
+    BV_SET_ALL(pmapdef->player.plrbv);
+    break;
+  case SHOW_EACH:    /* one map for each player */
+    BV_CLR_ALL(pmapdef->player.plrbv);
+    break;
+  }
+
+  if ((pmapdef->cities == FALSE && pmapdef->units == FALSE
+        && pmapdef->borders == FALSE && pmapdef->known == FALSE
+        && pmapdef->fogofwar == FALSE && pmapdef->area == FALSE)) {
+    pmapdef->player.show = SHOW_NONE;
+    BV_CLR_ALL(pmapdef->player.plrbv);
+  }
+
+  if (ret && !check) {
+    /* save map string */
+    mystrlcpy(pmapdef->maparg, maparg, MAX_LEN_MAPARG);
+
+    /* add map definiton */
+    mapdef_list_append(mapimg.mapdef, pmapdef);
+  } else {
+    mapdef_destroy(pmapdef);
+  }
+
+  return ret;
+}
+#undef NUM_MAPARGS
+#undef NUM_MAPOPTS
+
+/**************************************************************************
+  Check if a map image definition is valid. This function is a wrapper for
+  mapimg_checkplayers().
+**************************************************************************/
+bool mapimg_isvalid(int id)
+{
+  struct mapdef *pmapdef = NULL;
+
+  if (!mapimg_initialised()) {
+    MAPIMG_LOG("Map images not initialised!");
+    return FALSE;
+  }
+
+  if (id < 0 || id >= mapimg_count()) {
+    MAPIMG_LOG("no map definition with id %d", id);
+    return FALSE;
+  }
+
+  pmapdef = mapdef_list_get(mapimg.mapdef, id);
+
+  if (!mapimg_checkplayers(pmapdef)) {
+    return FALSE;
+  }
+
+  switch (pmapdef->status) {
+  case MAPIMG_CHECK:
+    MAPIMG_LOG("Map definition not checked (game not started).");
+    return FALSE;
+    break;
+  case MAPIMG_ERROR:
+    MAPIMG_LOG("Map definition deactivated: %s.", pmapdef->error);
+    return FALSE;
+    break;
+  case MAPIMG_OK:
+    /* nothing */
+    break;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+  Delete a map image definition.
+**************************************************************************/
+bool mapimg_delete(int id)
+{
+  struct mapdef *pmapdef = NULL;
+
+  if (!mapimg_initialised()) {
+    MAPIMG_LOG("Map images not initialised!");
+    return FALSE;
+  }
+
+  if (id < 0 || id >= mapimg_count()) {
+    MAPIMG_LOG("no map definition with id %d", id);
+    return FALSE;
+  }
+
+  /* delete map definition */
+  pmapdef = mapdef_list_get(mapimg.mapdef, id);
+  mapdef_list_unlink(mapimg.mapdef, pmapdef);
+
+  return TRUE;
+}
+
+/**************************************************************************
+  Show a map image definition.
+**************************************************************************/
+bool mapimg_show(int id, const char **str_show, bool detail)
+{
+  static struct astring str = ASTRING_INIT;
+  struct mapdef *pmapdef = NULL;
+
+  if (!mapimg_initialised()) {
+    MAPIMG_LOG("Map images not initialised!");
+    return FALSE;
+  }
+
+  if (id < 0 || id >= mapimg_count()) {
+    MAPIMG_LOG("no map definition with id %d", id);
+    return FALSE;
+  }
+
+  /* set str to an empty string */
+  astr_clear(&str);
+
+  pmapdef = mapdef_list_get(mapimg.mapdef, id);
+
+  if (detail) {
+    astr_add_line(&str, "detailed information for map definition %d:", id);
+    if (pmapdef->status == MAPIMG_ERROR) {
+      astr_add_line(&str, "  - status:                   %s (%s)",
+                    str_status[pmapdef->status], pmapdef->error);
+    } else {
+      astr_add_line(&str, "  - status:                   %s",
+                    str_status[pmapdef->status]);
+    }
+    astr_add_line(&str, "  - imageformat:              %s",
+                  image_extension[pmapdef->imgformat]);
+    astr_add_line(&str, "  - background color:         %s",
+                  img_bg_color[pmapdef->bg]);
+    astr_add_line(&str, "  - text color:               %s",
+                  img_fg_color[pmapdef->bg]);
+    astr_add_line(&str, "  - zoom factor:              %d", pmapdef->zoom);
+    astr_add_line(&str, "  - plot terrain:             %s",
+                  pmapdef->terrain ? "full" : "basic");
+    astr_add_line(&str, "  - plot cities:              %s",
+                  pmapdef->cities ? "yes" : "no");
+    astr_add_line(&str, "  - plot units:               %s",
+                  pmapdef->units ? "yes" : "no");
+    astr_add_line(&str, "  - plot borders:             %s",
+                  pmapdef->borders ? "yes" : "no");
+    astr_add_line(&str, "  - plot known tiles:         %s",
+                  pmapdef->known ? "yes" : "no");
+    astr_add_line(&str, "  - plot fogofwar:            %s",
+                  pmapdef->fogofwar ? "yes" : "no");
+    astr_add_line(&str, "  - plot area within borders: %s",
+                  pmapdef->known ? "yes" : "no");
+    astr_add_line(&str, "  - show players:             %s",
+                  str_showplr[pmapdef->player.show]);
+    switch (pmapdef->player.show) {
+    case SHOW_NONE:
+    case SHOW_EACH:
+    case SHOW_ALL:
+      /* nothing */
+      break;
+    case SHOW_PLRNAME:
+      astr_add_line(&str, "  - player name:              %s",
+                    pmapdef->player.plr.name);
+      break;
+    case SHOW_PLRID:
+      astr_add_line(&str, "  - player id:                %d",
+                    pmapdef->player.plr.id);
+      break;
+    case SHOW_PLRBV:
+      astr_add_line(&str, "  - players:                  %s",
+                    bvplayers_str(pmapdef));
+      break;
+    }
+
+    astr_cut_lines(&str, 80);
+  } else {
+    const char *str_def;
+    mapimg_def2str(&str_def, pmapdef);
+    astr_add_line(&str, "'%s' (%s)", str_def, str_status[pmapdef->status]);
+  }
+
+  *str_show = str.str;
+
+  return TRUE;
+}
+
+/**************************************************************************
+  Create the requested map image. The filename is created as
+  <basename>-<mapstr>.<mapext> where <mapstr> contains the map definition
+  and <mapext> the selected image extension. If 'force' is FALSE, the image
+  is only created if game.info.turn is a multiple of the map setting turns.
+**************************************************************************/
+bool mapimg_create(int id, const char *basename, bool force)
+{
+  struct mapdef *pmapdef = NULL;
+  struct img *pimg;
+  char filename[512]; /* MAX_LEN_FILENAME */
+  bool ret = TRUE;
+  struct timer *timer_cpu, *timer_user;
+
+  if (!mapimg_initialised()) {
+    MAPIMG_LOG("Map images not initialised!");
+    return FALSE;
+  }
+
+  if (!game_was_started_todo()) {
+    MAPIMG_LOG("no game loaded/started");
+    return FALSE;
+  }
+
+  if (id < 0 || id >= mapimg_count()) {
+    MAPIMG_LOG("no map definition with id %d", id);
+    return FALSE;
+  }
+
+  pmapdef = mapdef_list_get(mapimg.mapdef, id);
+
+  if (pmapdef->status != MAPIMG_OK) {
+    MAPIMG_LOG("map definition not checked or error");
+    return FALSE;
+  }
+
+  /* should an image be saved this turn? */
+  if (!force && pmapdef->turns != 0
+      && game.info.turn % pmapdef->turns != 0) {
+    return TRUE;
+  }
+
+  /* check player selection */
+  if (!mapimg_checkplayers(pmapdef)) {
+    return FALSE;
+  }
+
+  timer_cpu = new_timer_start(TIMER_CPU, TIMER_ACTIVE);
+  timer_user = new_timer_start(TIMER_USER, TIMER_ACTIVE);
+
+  /* create map */
+  switch (pmapdef->player.show) {
+  case SHOW_PLRNAME: /* display player given by name */
+  case SHOW_PLRID:   /* display player given by id */
+    /* should never happen as player.show is set to SHOW_PLRBV for these
+     * values in mapimg_checkplayers() */
+    MAPIMG_RETURN_VAL_IF_FAIL((pmapdef->player.show == SHOW_PLRBV
+                               || pmapdef->player.show == SHOW_EACH),
+                              FALSE);
+    break;
+  case SHOW_NONE:    /* no player one the map */
+  case SHOW_ALL:     /* show all players in one map */
+  case SHOW_PLRBV:   /* display player(s) given by bitvector */
+    generate_img_name(filename, sizeof(filename), pmapdef, basename);
+
+    pimg = img_new(pmapdef);
+    img_createmap(pimg);
+    if (!img_save(pimg, filename)) {
+      MAPIMG_LOG("Error saving file '%s'", filename);
+      ret = FALSE;
+    }
+    img_destroy(pimg);
+    break;
+  case SHOW_EACH:    /* one map for each player */
+    players_iterate(pplayer) {
+      if (!pplayer->is_alive) {
+        /* no map image for dead players */
+        continue;
+      }
+
+      BV_CLR_ALL(pmapdef->player.plrbv);
+      BV_SET(pmapdef->player.plrbv, player_index(pplayer));
+
+      generate_img_name(filename, sizeof(filename), pmapdef, basename);
+      pimg = img_new(pmapdef);
+      img_createmap(pimg);
+      if (!img_save(pimg, filename)) {
+        MAPIMG_LOG("Error saving file '%s'", filename);
+        ret = FALSE;
+      }
+      img_destroy(pimg);
+
+      if (!ret) {
+        break;
+      }
+    } players_iterate_end;
+    break;
+  }
+
+  log_verbose("Image generation time: %g seconds (%g apparent)",
+          read_timer_seconds(timer_cpu),
+          read_timer_seconds(timer_user));
+
+  free_timer(timer_cpu);
+  free_timer(timer_user);
+
+  return ret;
+}
+
+/**************************************************************************
+  Create an image which shows all map colors (playercolor, terrain colors).
+  A savegame has to be loaded for this function. THe filename will be
+  <basename>-colortest.<default mapext>.
+**************************************************************************/
+bool mapimg_colortest(const char *basename)
+{
+  struct img *pimg;
+  struct color *pcolor;
+  struct mapdef *pmapdef;
+  char buf[512]; /* MAX_LEN_FILENAME */
+  bv_pixel pixel;
+  int i, nat_x, nat_y, map_x, map_y;
+  int max_playercolor = MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS;
+  int max_terraincolor = terrain_count();
+  bool ret = TRUE;
+
+  if (!mapimg_initialised()) {
+    MAPIMG_LOG("Map images not initialised!");
+    return FALSE;
+  }
+
+  if (!game_was_started_todo()) {
+    MAPIMG_LOG("no game loaded/started");
+    return FALSE;
+  }
+
+  /* values for the test image */
+  pmapdef = mapdef_default();
+  pmapdef->bg = BG_WHITE;
+
+  pimg = img_new(pmapdef);
+
+  pixel = pimg->pixel_tile(1,1);
+
+#define SIZE_X 10
+#define SIZE_Y 5
+
+  pcolor = get_color(tileset, COLOR_OVERVIEW_OCEAN);
+  for (i = 0; i < MAX(max_playercolor, max_terraincolor); i++) {
+    nat_x = 1 + i % SIZE_X;
+    nat_y = 1 + (i / SIZE_X) * SIZE_Y;
+    NATIVE_TO_MAP_POS(&map_x, &map_y, nat_x, nat_y);
+    img_plot(pimg, map_x, map_y, pcolor, pixel);
+  }
+
+  for (i = 0; i < MAX(max_playercolor, max_terraincolor); i++) {
+    if (i >= max_playercolor) {
+      break;
+    }
+
+    nat_x = 1 + i % SIZE_X;
+    nat_y = 2 + (i / SIZE_X) * SIZE_Y;
+    pcolor = get_player_color(tileset, player_by_number(i));
+    NATIVE_TO_MAP_POS(&map_x, &map_y, nat_x, nat_y);
+    img_plot(pimg, map_x, map_y, pcolor, pixel);
+  }
+
+  pcolor = get_color(tileset, COLOR_OVERVIEW_LAND);
+  for (i = 0; i < MAX(max_playercolor, max_terraincolor); i++) {
+    nat_x = 1 + i % SIZE_X;
+    nat_y = 3 + (i / SIZE_X) * SIZE_Y;
+    NATIVE_TO_MAP_POS(&map_x, &map_y, nat_x, nat_y);
+    img_plot(pimg, map_x, map_y, pcolor, pixel);
+  }
+
+  for (i = 0; i < MAX(max_playercolor, max_terraincolor); i++) {
+    if (i >= max_terraincolor) {
+      break;
+    }
+
+    nat_x = 1 + i % SIZE_X;
+    nat_y = 4 + (i / SIZE_X) * SIZE_Y;
+    pcolor = get_terrain_color(tileset, terrain_by_number(i));
+    NATIVE_TO_MAP_POS(&map_x, &map_y, nat_x, nat_y);
+    img_plot(pimg, map_x, map_y, pcolor, pixel);
+  }
+
+#undef SIZE_X
+#undef SIZE_Y
+
+  /* filename for color test */
+  my_snprintf(buf, sizeof(buf), "%s-colortest", basename);
+
+  if (!img_save(pimg, buf)) {
+    MAPIMG_LOG("Error saving file '%s'", buf);
+    ret = FALSE;
+  } else {
+    img_destroy(pimg);
+  }
+
+  return ret;
+}
+
+/**************************************************************************
+  Return the map image definition 'id' as a mapdef string. This function is
+  a wrapper for mapimg_def2str().
+**************************************************************************/
+bool mapimg_id2str(int id, const char **str_def)
+{
+  struct mapdef *pmapdef = NULL;
+
+  if (!mapimg_initialised()) {
+    MAPIMG_LOG("Map images not initialised!");
+    return FALSE;
+  }
+
+  if (id < 0 || id >= mapimg_count()) {
+    MAPIMG_LOG("no map definition with id %d", id);
+    return FALSE;
+  }
+
+  pmapdef = mapdef_list_get(mapimg.mapdef, id);
+
+  return mapimg_def2str(str_def, pmapdef);
+}
+
+/*
+ * ==============================================
+ * mapimg - internal functions
+ * ==============================================
+ */
+
+/**************************************************************************
+  Check if the map image subsustem is initialised.
+**************************************************************************/
+static inline bool mapimg_initialised(void)
+{
+  return mapimg.init;
+}
+
+/**************************************************************************
+  Return a mapdef string for the map image definition given by 'pmapdef'.
+**************************************************************************/
+static bool mapimg_def2str(const char **str_def, struct mapdef *pmapdef)
+{
+  static struct astring str = ASTRING_INIT;
+  char buf[7];
+  int i;
+
+  /* set str to the maparg used of the map definition */
+  astr_clear(&str);
+  astr_add_line(&str, "%s", pmapdef->maparg);
+  *str_def = str.str;
+
+  if (pmapdef->status != MAPIMG_OK) {
+    MAPIMG_LOG("Map definition not checked or error.");
+    return FALSE;
+  }
+
+  if (!game_was_started_todo()) {
+    /* return uncheck definition string */
+    return TRUE;
+  }
+
+  astr_clear(&str);
+
+  i = 0;
+  if (pmapdef->area) {
+    buf[i++] = 'a';
+  }
+  if (pmapdef->borders) {
+    buf[i++] = 'b';
+  }
+  if (pmapdef->cities) {
+    buf[i++] = 'c';
+  }
+  if (pmapdef->fogofwar) {
+    buf[i++] = 'f';
+  }
+  if (pmapdef->known) {
+    buf[i++] = 'k';
+  }
+  if (pmapdef->terrain) {
+    buf[i++] = 't';
+  }
+  if (pmapdef->units) {
+    buf[i++] = 'u';
+  }
+  buf[i++] = '\0';
+
+  astr_add(&str, "bg=%s:", img_bg_color[pmapdef->bg]);
+  astr_add(&str, "format=%s:", image_extension[pmapdef->imgformat]);
+  astr_add(&str, "turns=%d:", pmapdef->turns);
+  astr_add(&str, "map=%s:", buf);
+  switch (pmapdef->player.show) {
+  case SHOW_NONE:
+  case SHOW_EACH:
+  case SHOW_ALL:
+    /* nothing */
+    astr_add(&str, "show=%s:", str_showplr[pmapdef->player.show]);
+    break;
+  case SHOW_PLRBV:
+  case SHOW_PLRNAME:
+  case SHOW_PLRID:
+    astr_add(&str, "show=%s:", str_showplr[SHOW_PLRBV]);
+    astr_add(&str, "plrbv=%s:", bvplayers_str(pmapdef));
+    break;
+  }
+  astr_add(&str, "zoom=%d", pmapdef->zoom);
+
+  *str_def = str.str;
+
+  return TRUE;
+}
+
+/**************************************************************************
+  Check the player selection (plrname and plrid).
+**************************************************************************/
+static bool mapimg_checkplayers(struct mapdef *pmapdef)
+{
+  struct player *pplayer;
+  enum m_pre_result result;
+
+  if (pmapdef->status != MAPIMG_CHECK) {
+    return TRUE;
+  }
+
+  if (!game_was_started_todo()) {
+    return TRUE;
+  }
+
+  pmapdef->status = MAPIMG_OK;
+
+  /* game started - generate / check bitvector for players */
+  switch (pmapdef->player.show) {
+  case SHOW_NONE:
+  case SHOW_PLRBV:
+  case SHOW_EACH:
+  case SHOW_ALL:
+    /* nothing; see mapimg_define() */
+    break;
+  case SHOW_PLRNAME:
+    /* display players as requested in the map definition */
+    pmapdef->player.show = SHOW_PLRBV;
+    BV_CLR_ALL(pmapdef->player.plrbv);
+    pplayer = find_player_by_name_prefix(pmapdef->player.plr.name, &result);
+
+    if (pplayer != NULL) {
+      BV_SET(pmapdef->player.plrbv, player_index(pplayer));
+    } else {
+      pmapdef->status = MAPIMG_ERROR;
+      my_snprintf(pmapdef->error, sizeof(pmapdef->error),
+                  "unknown player name: '%s'", pmapdef->player.plr.name);
+      MAPIMG_LOG("%s", pmapdef->error);
+      return FALSE;
+    }
+    break;
+  case SHOW_PLRID:
+    /* display players as requested in the map definition */
+    pmapdef->player.show = SHOW_PLRBV;
+    BV_CLR_ALL(pmapdef->player.plrbv);
+    pplayer = player_by_number(pmapdef->player.plr.id);
+
+    if (pplayer != NULL) {
+      BV_SET(pmapdef->player.plrbv, player_index(pplayer));
+    } else {
+      pmapdef->status = MAPIMG_ERROR;
+      my_snprintf(pmapdef->error, sizeof(pmapdef->error),
+                  "invalid player id: %d", pmapdef->player.plr.id);
+      MAPIMG_LOG("%s", pmapdef->error);
+      return FALSE;
+    }
+    break;
+  }
+
+  return TRUE;
+}
+
+/**************************************************************************
+  Edit the error_buffer.
+**************************************************************************/
+static void mapimg_log(const char *file, const char *function, int line,
+                       const char *format, ...)
+{
+  char message[MAX_LEN_ERRORBUF];
+  va_list args;
+
+  va_start(args, format);
+  my_vsnprintf(message, sizeof(message), format, args);
+  va_end(args);
+
+#ifdef DEBUG
+  my_snprintf(error_buffer, sizeof(error_buffer), "In %s() [%s:%d]: %s",
+              function, file, line, message);
+#else
+  sz_strlcpy(error_buffer, message);
+#endif
+}
+
+/*
+ * ==============================================
+ * mapdef
+ * ==============================================
+ */
+
+/**************************************************************************
+  Create a new map image definition with default values.
+**************************************************************************/
+static struct mapdef *mapdef_default(void)
+{
+  struct mapdef *pmapdef;
+
+  pmapdef = fc_malloc(sizeof(*pmapdef));
+
+  /* default values */
+  pmapdef->maparg[0] = '\0';
+  pmapdef->error[0] = '\0';
+  pmapdef->status = MAPIMG_CHECK;
+  pmapdef->imgformat = IMG_GIF;
+  pmapdef->bg = BG_WHITE;
+  pmapdef->zoom = 2;
+  pmapdef->turns = 1;
+  pmapdef->terrain = FALSE;
+  pmapdef->cities = TRUE;
+  pmapdef->units = TRUE;
+  pmapdef->borders = TRUE;
+  pmapdef->known = FALSE;
+  pmapdef->fogofwar = FALSE;
+  pmapdef->area = FALSE;
+  pmapdef->player.show = SHOW_ALL;
+  pmapdef->player.plr.name[0] = '\0';
+  BV_CLR_ALL(pmapdef->player.plrbv);
+
+  return pmapdef;
+}
+
+/**************************************************************************
+  Destroy a map image definition.
+**************************************************************************/
+static void mapdef_destroy(struct mapdef *pmapdef)
+{
+  if (pmapdef == NULL) {
+    return;
+  }
+
+  FC_FREE(pmapdef);
+}
+
+/*
+ * ==============================================
+ * mage functions
+ * ==============================================
+ */
+
+/**************************************************************************
+  Create a new image.
+**************************************************************************/
+static struct img *img_new(struct mapdef *mapdef)
+{
+  struct img *pimg;
+  int i;
+
+  pimg = fc_malloc(sizeof(*pimg));
+
+  pimg->def = mapdef;
+  pimg->turn = game.info.turn;
+  my_snprintf(pimg->title, sizeof(pimg->title),
+              _("Turn: %3d - Year: %s - %s"), game.info.turn,
+              textyear(game.info.year),  game.server.save_name);
+
+  pimg->size.x = 0; /* x size of the map image */
+  pimg->size.y = 0; /* y size of the map image */
+
+  if (topo_has_flag(TF_HEX)) {
+    /* additional space for hex maps */
+    pimg->size.x += TILE_SIZE / 2;
+    pimg->size.y += TILE_SIZE / 2;
+
+    if (topo_has_flag(TF_ISO)) {
+      /* iso-hex */
+      pimg->size.x += (map.xsize + map.ysize / 2) * TILE_SIZE;
+      pimg->size.y += (map.xsize + map.ysize / 2) * TILE_SIZE;
+
+      /* magic for isohexa: change size if wrapping in only one direction */
+      if ((topo_has_flag(TF_WRAPX) && !topo_has_flag(TF_WRAPY))
+          || (!topo_has_flag(TF_WRAPX) && topo_has_flag(TF_WRAPY))) {
+        pimg->size.y += (map.xsize - map.ysize / 2) / 2 * TILE_SIZE;
+      }
+
+      pimg->tileshape = &tile_isohexa;
+
+      pimg->pixel_tile = pixel_tile_isohexa;
+      pimg->pixel_city = pixel_city_isohexa;
+      pimg->pixel_unit = pixel_unit_isohexa;
+      pimg->pixel_fogofwar = pixel_fogofwar_isohexa;
+      pimg->pixel_border = pixel_border_isohexa;
+
+      pimg->base_coor = base_coor_isohexa;
+    } else {
+      /* hex */
+      pimg->size.x += map.xsize * TILE_SIZE;
+      pimg->size.y += map.ysize * TILE_SIZE;
+
+      pimg->tileshape = &tile_hexa;
+
+      pimg->pixel_tile = pixel_tile_hexa;
+      pimg->pixel_city = pixel_city_hexa;
+      pimg->pixel_unit = pixel_unit_hexa;
+      pimg->pixel_fogofwar = pixel_fogofwar_hexa;
+      pimg->pixel_border = pixel_border_hexa;
+
+      pimg->base_coor = base_coor_hexa;
+    }
+  } else {
+    if (topo_has_flag(TF_ISO)) {
+      /* isometric rectangular */
+      pimg->size.x += (map.xsize + map.ysize / 2) * TILE_SIZE;
+      pimg->size.y += (map.xsize + map.ysize / 2) * TILE_SIZE;
+    } else {
+      /* rectangular */
+      pimg->size.x += map.xsize * TILE_SIZE;
+      pimg->size.y += map.ysize * TILE_SIZE;
+    }
+
+    pimg->tileshape = &tile_rect;
+
+    pimg->pixel_tile = pixel_tile_rect;
+    pimg->pixel_city = pixel_city_rect;
+    pimg->pixel_unit = pixel_unit_rect;
+    pimg->pixel_fogofwar = pixel_fogofwar_rect;
+    pimg->pixel_border = pixel_border_rect;
+
+    pimg->base_coor = base_coor_rect;
+  }
+
+  pimg->map = fc_calloc(pimg->size.x * pimg->size.y, sizeof(*pimg->map));
+
+  /* set initial map */
+  for (i = 0; i < pimg->size.y * pimg->size.x; i++) {
+    pimg->map[i] = NULL;
+  }
+
+  return pimg;
+}
+
+/**************************************************************************
+  Destroy a image.
+**************************************************************************/
+static void img_destroy(struct img *pimg)
+{
+  if (pimg != NULL) {
+    /* do not free pimg->def */
+    FC_FREE(pimg->map);
+    FC_FREE(pimg);
+  }
+}
+
+/**************************************************************************
+  Set the color of one pixel.
+**************************************************************************/
+static inline void img_set_pixel(struct img *pimg, const int index,
+                                 struct color *pcolor)
+{
+  if (index < 0 || index > pimg->size.x*pimg->size.y) {
+    log_error("invalid index: 0 <= %d < %d", index,
+            pimg->size.x*pimg->size.y);
+    return;
+  }
+
+  pimg->map[index] = pcolor;
+}
+
+/**************************************************************************
+  Get the index for an (x,y) image coordinate.
+**************************************************************************/
+static inline int img_index(const int x, const int y,
+                            const struct img *pimg)
+{
+  return (pimg->size.x)*y + x;
+}
+
+/**************************************************************************
+  Plot one tile. Only the pixel of the tile set within 'pixel' are ploted.
+**************************************************************************/
+static void img_plot(struct img *pimg, const int x, const int y,
+                     struct color *pcolor, const bv_pixel pixel)
+{
+  int base_x, base_y, i, index;
+
+  if (!BV_ISSET_ANY(pixel)) {
+    return;
+  }
+
+  pimg->base_coor(&base_x, &base_y, x, y);
+
+  for (i = 0; i < NUM_PIXEL; i++) {
+    if (BV_ISSET(pixel, i)) {
+      index = img_index(base_x + pimg->tileshape->x[i],
+                        base_y + pimg->tileshape->y[i],
+                        pimg);
+      img_set_pixel(pimg, index, pcolor);
+    }
+  }
+}
+
+/**************************************************************************
+  Save an image. If freeciv is compiled with ImageMagick a lot of file
+  formats are possible. Else fall back to a ppm image.
+
+  Image structure:
+
+  [             0]
+                    border
+  [+BORDER_HEIGHT]
+                    title
+  [+  TEXT_HEIGHT]
+                    space (only if count(displayed players) > 0)
+  [+SPACER_HEIGHT]
+                    player line (only if count(displayed players) > 0)
+  [+  LINE_HEIGHT]
+                    space
+  [+SPACER_HEIGHT]
+                    map
+  [+   MAP_HEIGHT]
+                    border
+  [+BORDER_HEIGHT]
+
+**************************************************************************/
+#ifdef HAVE_WAND
+#define BORDER_HEIGHT 5
+#define BORDER_WIDTH BORDER_HEIGHT
+#define SPACER_HEIGHT 5
+#define LINE_HEIGHT 5
+#define TEXT_HEIGHT 12
+#define SET_COLOR(str, pcolor)                                               \
+  my_snprintf(str, sizeof(str), "rgb(%d,%d,%d)",                             \
+              pcolor->color.red >> 8, pcolor->color.green >> 8,              \
+              pcolor->color.blue >> 8);
+static bool img_save(const struct img *pimg, const char *filename)
+{
+  struct color *pcolor = NULL;
+  struct player *pplr_now = NULL, *pplr_only = NULL;
+  bool ret = TRUE;
+  char imagefile[512]; /* MAX_LEN_FILENAME */
+  char str_color[32], comment[2048] = "";
+  unsigned long img_width, img_height, map_width, map_height;
+  int x, y, xxx, yyy, row, i, index, plrwidth;
+  bool withplr = BV_ISSET_ANY(pimg->def->player.plrbv);
+
+  MagickWand *mw;
+  PixelIterator *imw;
+  PixelWand **pmw, *pw;
+  DrawingWand *dw;
+
+  MagickWandGenesis();
+
+  mw = NewMagickWand();
+  dw = NewDrawingWand();
+  pw = NewPixelWand();
+
+  map_width = pimg->size.x * pimg->def->zoom;
+  map_height = pimg->size.y * pimg->def->zoom;
+
+  img_width = map_width + 2 * BORDER_WIDTH;
+  img_height = map_height + 2 * BORDER_HEIGHT + TEXT_HEIGHT + SPACER_HEIGHT
+               + (withplr ? 2 * SPACER_HEIGHT : 0);
+
+  PixelSetColor(pw, img_bg_color[pimg->def->bg]);
+  MagickNewImage(mw, img_width, img_height, pw);
+
+  PixelSetColor(pw, img_fg_color[pimg->def->bg]);
+  DrawSetFillColor(dw, pw);
+  DrawSetFont(dw, "Times-New-Roman");
+  DrawSetFontSize(dw, TEXT_HEIGHT);
+  DrawAnnotation(dw, BORDER_WIDTH, TEXT_HEIGHT + BORDER_HEIGHT,
+                 (unsigned char *)pimg->title);
+  MagickDrawImage(mw, dw);
+
+  if (withplr) {
+    /* show a line displaying the colors of alive players */
+    plrwidth = map_width / (MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS);
+    if (bvplayers_count(pimg->def) == 1) {
+      /* only one player */
+      for (i = 0; i < MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS; i++) {
+        if (BV_ISSET(pimg->def->player.plrbv, i)) {
+          pplr_only = player_by_number(i);
+          break;
+        }
+      }
+    }
+
+    imw = NewPixelRegionIterator(mw, BORDER_WIDTH,
+                                 BORDER_HEIGHT + TEXT_HEIGHT + SPACER_HEIGHT,
+                                 map_width, LINE_HEIGHT);
+    /* y coordinate */
+    for (y = 0; y < LINE_HEIGHT; y++) {
+      pmw = PixelGetNextIteratorRow(imw, &map_width);
+
+      /* x coordinate */
+      for (x = 0; x < map_width; x++) {
+        i = x / plrwidth;
+        pplr_now = valid_player_by_number(i);
+
+        if (i > player_count() || pplr_now == NULL || !pplr_now->is_alive) {
+          continue;
+        }
+
+        if (BV_ISSET(pimg->def->player.plrbv, i)) {
+          /* player is alive - display it */
+          pcolor = get_player_color(tileset, player_by_number(i));
+          SET_COLOR(str_color, pcolor);
+          PixelSetColor(pmw[x], str_color);
+        } else if (pplr_only != NULL && pplayers_allied(pplr_now, pplr_only)
+                   && (x + y) % 2 == 0) {
+          /* player is allied to the selected player */
+          pcolor = get_player_color(tileset, player_by_number(i));
+          SET_COLOR(str_color, pcolor);
+          PixelSetColor(pmw[x], str_color);
+        }
+      }
+      PixelSyncIterator(imw);
+    }
+    DestroyPixelIterator(imw);
+  }
+
+  imw = NewPixelRegionIterator(mw, BORDER_WIDTH,
+                               BORDER_HEIGHT + TEXT_HEIGHT + SPACER_HEIGHT
+                               + (withplr ? (LINE_HEIGHT + SPACER_HEIGHT) : 0),
+                               map_width, map_height);
+  /* y coordinate */
+  for (y = 0; y < pimg->size.y; y++) {
+    /* zoom for y */
+    for (yyy = 0; yyy < pimg->def->zoom; yyy++) {
+
+      pmw = PixelGetNextIteratorRow(imw, &map_width);
+
+      /* x coordinate */
+      for (x = 0; x < pimg->size.x; x++) {
+        index = img_index(x, y, pimg);
+        pcolor = pimg->map[index];
+
+        if (pcolor != NULL) {
+          SET_COLOR(str_color, pcolor);
+
+          /* zoom for x */
+          for (xxx = 0; xxx < pimg->def->zoom; xxx++) {
+            row = x * pimg->def->zoom + xxx;
+            PixelSetColor(pmw[row], str_color);
+          }
+        }
+      }
+      PixelSyncIterator(imw);
+    }
+  }
+  DestroyPixelIterator(imw);
+
+  if (BV_ISSET_ANY(pimg->def->player.plrbv)) {
+    players_iterate(pplayer) {
+      if (!BV_ISSET(pimg->def->player.plrbv, player_index(pplayer))) {
+        continue;
+      }
+
+      pcolor = get_player_color(tileset, pplayer);
+      cat_snprintf(comment, sizeof(comment),
+                   "playerno:%d:color:#%02x%02x%02x:name:\"%s\"\n",
+                   player_number(pplayer), pcolor->color.red >> 8,
+                   pcolor->color.green >> 8, pcolor->color.blue >> 8,
+                   player_name(pplayer));
+    } players_iterate_end;
+
+    MagickCommentImage(mw, comment);
+  }
+
+  my_snprintf(imagefile, sizeof(imagefile), "%s.%s", filename,
+              image_extension[pimg->def->imgformat]);
+  if (!MagickWriteImage(mw, imagefile)) {
+    ret = FALSE;
+  } else {
+    log_normal("map image saved as '%s'", imagefile);
+  }
+
+  DestroyDrawingWand(dw);
+  DestroyPixelWand(pw);
+  DestroyMagickWand(mw);
+
+  MagickWandTerminus();
+
+  return ret;
+}
+#undef BORDER_HEIGHT
+#undef BORDER_WIDTH
+#undef SPACER_HEIGHT
+#undef TEXT_HEIGHT
+#undef SET_COLOR
+#else
+static bool img_save(const struct img *pimg, const char *filename)
+{
+  char ppmname[512]; /* MAX_LEN_FILENAME */
+  FILE *fp;
+  int x, y, xxx, yyy, index;
+  struct color *pcolor;
+
+  my_snprintf(ppmname, sizeof(ppmname), "%s.ppm", filename);
+  fp = fopen(ppmname, "w");
+  if (!fp) {
+    log_error("couldn't open file: %s\n", ppmname);
+    return FALSE;
+  }
+
+  fprintf(fp, "P3\n# version:2\n# gameid: %s\n", server.game_identifier);
+  fprintf(fp, "# An intermediate map from saved Freeciv game %s%+05d\n",
+          game.server.save_name, game.info.year);
+  fprintf(fp, "# map definition: %s", pimg->def->maparg);
+
+  if (BV_ISSET_ANY(pimg->def->player.plrbv)) {
+    players_iterate(pplayer) {
+      if (!BV_ISSET(pimg->def->player.plrbv, player_index(pplayer))) {
+        continue;
+      }
+
+      pcolor = get_player_color(tileset, pplayer);
+      fprintf(fp, "# playerno:%d:color:#%02x%02x%02x:name:\"%s\"\n",
+              player_number(pplayer), pcolor->color.red >> 8,
+              pcolor->color.green >> 8, pcolor->color.blue >> 8,
+              player_name(pplayer));
+    } players_iterate_end;
+  } else {
+    fprintf(fp, "# no players");
+  }
+
+  fprintf(fp, "%d %d\n", pimg->size.x * pimg->def->zoom,
+          pimg->size.y * pimg->def->zoom);
+  fprintf(fp, "255\n");
+
+  /* y coordinate */
+  for (y = 0; y < pimg->size.y; y++) {
+    /* zoom for y */
+    for (yyy = 0; yyy < pimg->def->zoom; yyy++) {
+      /* x coordinate */
+      for (x = 0; x < pimg->size.x; x++) {
+        index = img_index(x, y, pimg);
+        pcolor = pimg->map[index];
+
+        /* zoom for x */
+        for (xxx = 0; xxx < pimg->def->zoom; xxx++) {
+          if (pcolor != NULL) {
+            fprintf(fp, "%d %d %d\n", pcolor->color.red >> 8,
+                   pcolor->color.green >> 8, pcolor->color.blue >> 8);
+          } else {
+            fprintf(fp, "255 255 255\n"); /* white */
+          }
+        }
+      }
+    }
+  }
+
+  log_normal("map image saved as '%s'", ppmname);
+  fclose(fp);
+  return TRUE;
+}
+#endif /* HAVE_WAND */
+
+/**************************************************************************
+  Create the map considering the options (terrain, player(s), cities,
+  units, borders, known, fogofwar, ...).
+**************************************************************************/
+static void img_createmap(struct img *pimg)
+{
+  struct color *pcolor;
+  bv_pixel pixel;
+  int x, y, player_id, i;
+  struct player *pplayer = NULL;
+  enum known_type tile_knowledge = TILE_UNKNOWN;
+
+  whole_map_iterate(ptile) {
+    x = ptile->x;
+    y = ptile->y;
+
+    if (bvplayers_count(pimg->def) == 1) {
+      /* only one player; get player id for 'known' and 'fogofwar' */
+      for (i = 0; i < player_count(); i++) {
+        if (BV_ISSET(pimg->def->player.plrbv, i)) {
+          pplayer = player_by_number(i);
+          tile_knowledge = tile_get_known(ptile, pplayer);
+          break;
+        }
+      }
+    }
+
+    /* known tiles */
+    if (pimg->def->known && pplayer != NULL && tile_knowledge == TILE_UNKNOWN) {
+      /* plot nothing if tile is not known */
+      continue;
+    }
+
+    /* terrain */
+    if (pimg->def->terrain) {
+      /* full terrain */
+      pixel = pimg->pixel_tile(x, y);
+      pcolor = get_terrain_color(tileset, ptile->terrain);
+      img_plot(pimg, x, y, pcolor, pixel);
+    } else {
+      /* basic terrain */
+      pixel = pimg->pixel_tile(x, y);
+      if (is_ocean_tile(ptile)) {
+        img_plot(pimg, x, y, get_color(tileset, COLOR_OVERVIEW_OCEAN),
+                 pixel);
+      } else {
+        img_plot(pimg, x, y, get_color(tileset, COLOR_OVERVIEW_LAND),
+                 pixel);
+      }
+    }
+
+    /* cities and units */
+    if (pimg->def->cities && tile_city(ptile)) {
+      player_id = player_index(city_owner(tile_city(ptile)));
+      if (BV_ISSET(pimg->def->player.plrbv, player_id)
+          || (pplayer != NULL && tile_knowledge == TILE_KNOWN_SEEN)) {
+        /* plot cities if player is selected or view range of the one
+         * displayed player*/
+        pixel = pimg->pixel_city(x, y);
+        pcolor = get_player_color(tileset, player_by_number(player_id));
+        img_plot(pimg, x, y, pcolor, pixel);
+      }
+    } else if (pimg->def->units && unit_list_size(ptile->units) > 0) {
+      player_id = player_index(unit_owner(unit_list_get(ptile->units, 0)));
+      if (BV_ISSET(pimg->def->player.plrbv, player_id)
+          || (pplayer != NULL && tile_knowledge == TILE_KNOWN_SEEN)) {
+        /* plot units if player is selected or view range of the one
+         * displayed player*/
+        pixel = pimg->pixel_unit(x, y);
+        pcolor = get_player_color(tileset, player_by_number(player_id));
+        img_plot(pimg, x, y, pcolor, pixel);
+      }
+    }
+
+    /* (land) area within borders and borders */
+    if (game.info.borders > 0 && NULL != tile_owner(ptile)) {
+      player_id = player_index(tile_owner(ptile));
+      if (pimg->def->area && !is_ocean_tile(ptile)
+          && BV_ISSET(pimg->def->player.plrbv, player_id)) {
+        /* the tile is land and inside the players borders */
+        pixel = pimg->pixel_tile(x, y);
+        pcolor = get_player_color(tileset, player_by_number(player_id));
+        img_plot(pimg, x, y, pcolor, pixel);
+      } else if (pimg->def->borders
+                 && (BV_ISSET(pimg->def->player.plrbv, player_id)
+                     || (pplayer != NULL
+                         && tile_knowledge == TILE_KNOWN_SEEN))) {
+        /* plot borders if player is selected or view range of the one
+         * displayed player*/
+        pixel = pimg->pixel_border(x, y);
+        pcolor = get_player_color(tileset, player_by_number(player_id));
+        img_plot(pimg, x, y, pcolor, pixel);
+      }
+    }
+
+    /* fogofwar; if only 1 player is plotted */
+    if (game.info.fogofwar && pimg->def->fogofwar && pplayer != NULL
+        && tile_knowledge == TILE_KNOWN_UNSEEN) {
+      pixel = pimg->pixel_fogofwar(x, y);
+      pcolor = NULL;
+      img_plot(pimg, x, y, pcolor, pixel);
+    }
+
+  } whole_map_iterate_end;
+}
+
+/*
+ * ==============================================
+ * topology functions
+ * ==============================================
+ * With these functions the pixels corresponding to the different elements
+ * (tile, city, unit) for each map topology are defined.
+ *
+ * The bv_pixel_fogofwar_*() functions are special as they defines where
+ * the color should be removed.
+ *
+ * The functions for a rectangular and an isometric rectangular topology
+ * are identical.
+ */
+
+/**************************************************************************
+   0  1  2  3  3  5
+   6  7  8  9 10 11
+  12 13 14 15 16 17
+  18 19 20 21 22 23
+  24 25 26 27 28 29
+  30 31 32 33 34 35
+**************************************************************************/
+static bv_pixel pixel_tile_rect(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_SET_ALL(pixel);
+
+  return pixel;
+}
+
+/**************************************************************************
+  -- -- -- -- -- --
+  --  7  8  9 10 --
+  -- 13 14 15 16 --
+  -- 19 20 21 22 --
+  -- 25 26 27 28 --
+  -- -- -- -- -- --
+**************************************************************************/
+static bv_pixel pixel_city_rect(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_CLR_ALL(pixel);
+  BV_SET(pixel, 7);
+  BV_SET(pixel, 8);
+  BV_SET(pixel, 9);
+  BV_SET(pixel, 10);
+  BV_SET(pixel, 13);
+  BV_SET(pixel, 14);
+  BV_SET(pixel, 15);
+  BV_SET(pixel, 16);
+  BV_SET(pixel, 19);
+  BV_SET(pixel, 20);
+  BV_SET(pixel, 21);
+  BV_SET(pixel, 22);
+  BV_SET(pixel, 21);
+  BV_SET(pixel, 25);
+  BV_SET(pixel, 26);
+  BV_SET(pixel, 27);
+  BV_SET(pixel, 28);
+
+  return pixel;
+}
+
+/**************************************************************************
+  -- -- -- -- -- --
+  -- -- -- -- -- --
+  -- -- 14 15 -- --
+  -- -- 20 21 -- --
+  -- -- -- -- -- --
+  -- -- -- -- -- --
+**************************************************************************/
+static bv_pixel pixel_unit_rect(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_CLR_ALL(pixel);
+  BV_SET(pixel, 14);
+  BV_SET(pixel, 15);
+  BV_SET(pixel, 20);
+  BV_SET(pixel, 21);
+
+  return pixel;
+}
+
+/**************************************************************************
+   0 --  2 --  4 --
+  --  7 --  9 -- 11
+  12 -- 14 -- 16 --
+  -- 19 -- 21 -- 23
+  24 -- 26 -- 28 --
+  -- 31 -- 33 -- 35
+**************************************************************************/
+static bv_pixel pixel_fogofwar_rect(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_CLR_ALL(pixel);
+
+  BV_SET(pixel,  0);
+  BV_SET(pixel,  2);
+  BV_SET(pixel,  4);
+  BV_SET(pixel,  7);
+  BV_SET(pixel,  9);
+  BV_SET(pixel, 11);
+  BV_SET(pixel, 12);
+  BV_SET(pixel, 14);
+  BV_SET(pixel, 16);
+  BV_SET(pixel, 19);
+  BV_SET(pixel, 21);
+  BV_SET(pixel, 23);
+  BV_SET(pixel, 24);
+  BV_SET(pixel, 26);
+  BV_SET(pixel, 28);
+  BV_SET(pixel, 31);
+  BV_SET(pixel, 33);
+  BV_SET(pixel, 35);
+
+  return pixel;
+}
+
+/**************************************************************************
+             [N]
+
+       0  1  2  3  3  5
+       6 -- -- -- -- 11
+  [W] 12 -- -- -- -- 17 [E]
+      18 -- -- -- -- 23
+      24 -- -- -- -- 29
+      30 31 32 33 34 35
+
+             [S]
+**************************************************************************/
+static bv_pixel pixel_border_rect(const int x, const int y)
+{
+  bv_pixel pixel;
+  struct tile *ptile, *pcenter;
+  struct player *owner;
+
+  BV_CLR_ALL(pixel);
+
+  pcenter = map_pos_to_tile(x, y);
+  if (NULL == pcenter) {
+    /* no tile */
+    return pixel;
+  }
+
+  owner = tile_owner(pcenter);
+  if (NULL == owner) {
+    /* no border */
+    return pixel;
+  }
+
+  ptile = mapstep(pcenter, DIR8_NORTH);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 0);
+    BV_SET(pixel, 1);
+    BV_SET(pixel, 2);
+    BV_SET(pixel, 3);
+    BV_SET(pixel, 4);
+    BV_SET(pixel, 5);
+  }
+
+  ptile = mapstep(pcenter, DIR8_EAST);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 5);
+    BV_SET(pixel, 11);
+    BV_SET(pixel, 17);
+    BV_SET(pixel, 23);
+    BV_SET(pixel, 29);
+    BV_SET(pixel, 35);
+  }
+
+  ptile = mapstep(pcenter, DIR8_SOUTH);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 30);
+    BV_SET(pixel, 31);
+    BV_SET(pixel, 32);
+    BV_SET(pixel, 33);
+    BV_SET(pixel, 34);
+    BV_SET(pixel, 35);
+  }
+
+  ptile = mapstep(pcenter, DIR8_WEST);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 0);
+    BV_SET(pixel, 6);
+    BV_SET(pixel, 12);
+    BV_SET(pixel, 18);
+    BV_SET(pixel, 24);
+    BV_SET(pixel, 30);
+  }
+
+  return pixel;
+}
+
+/**************************************************************************
+  Base coordinates for the tiles on a (isometric) rectange topology,
+**************************************************************************/
+static void base_coor_rect(int *base_x, int *base_y, int x, int y)
+{
+  *base_x = x * TILE_SIZE;
+  *base_y = y * TILE_SIZE;
+}
+
+/**************************************************************************
+         0  1
+      2  3  4  5
+   6  7  8  9 10 11
+  12 13 14 15 16 17
+  18 19 20 21 22 23
+  24 25 26 27 28 29
+     30 31 32 33
+        34 35
+**************************************************************************/
+static bv_pixel pixel_tile_hexa(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_SET_ALL(pixel);
+
+  return pixel;
+}
+
+/**************************************************************************
+        -- --
+     --  3  4 --
+  --  7  8  9 10 --
+  -- 13 14 15 16 --
+  -- 19 20 21 22 --
+  -- 25 26 27 28 --
+     -- 31 32 --
+        -- --
+**************************************************************************/
+static bv_pixel pixel_city_hexa(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_CLR_ALL(pixel);
+  BV_SET(pixel, 3);
+  BV_SET(pixel, 4);
+  BV_SET(pixel, 7);
+  BV_SET(pixel, 8);
+  BV_SET(pixel, 9);
+  BV_SET(pixel, 10);
+  BV_SET(pixel, 13);
+  BV_SET(pixel, 14);
+  BV_SET(pixel, 15);
+  BV_SET(pixel, 16);
+  BV_SET(pixel, 19);
+  BV_SET(pixel, 20);
+  BV_SET(pixel, 21);
+  BV_SET(pixel, 22);
+  BV_SET(pixel, 25);
+  BV_SET(pixel, 26);
+  BV_SET(pixel, 27);
+  BV_SET(pixel, 28);
+  BV_SET(pixel, 31);
+  BV_SET(pixel, 32);
+
+  return pixel;
+}
+
+/**************************************************************************
+        -- --
+     -- -- -- --
+  -- -- -- -- -- --
+  -- -- 14 15 -- --
+  -- -- 20 21 -- --
+  -- -- -- -- -- --
+     -- -- -- --
+        -- --
+**************************************************************************/
+static bv_pixel pixel_unit_hexa(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_CLR_ALL(pixel);
+  BV_SET(pixel, 14);
+  BV_SET(pixel, 15);
+  BV_SET(pixel, 20);
+  BV_SET(pixel, 21);
+
+  return pixel;
+}
+
+/**************************************************************************
+         0 --
+     --  3 --  5
+  --  7 --  9 -- 11
+  -- 13 -- 15 -- 17
+  18 -- 20 -- 22 --
+  24 -- 26 -- 28 --
+     30 -- 32 --
+        -- 35
+**************************************************************************/
+static bv_pixel pixel_fogofwar_hexa(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_CLR_ALL(pixel);
+  BV_SET(pixel,  0);
+  BV_SET(pixel,  3);
+  BV_SET(pixel,  5);
+  BV_SET(pixel,  7);
+  BV_SET(pixel,  9);
+  BV_SET(pixel, 11);
+  BV_SET(pixel, 13);
+  BV_SET(pixel, 15);
+  BV_SET(pixel, 17);
+  BV_SET(pixel, 18);
+  BV_SET(pixel, 20);
+  BV_SET(pixel, 22);
+  BV_SET(pixel, 24);
+  BV_SET(pixel, 26);
+  BV_SET(pixel, 28);
+  BV_SET(pixel, 30);
+  BV_SET(pixel, 32);
+  BV_SET(pixel, 35);
+
+  return pixel;
+}
+
+/**************************************************************************
+   [W]        0  1       [N]
+           2 -- --  5
+        6 -- -- -- -- 11
+  [SW] 12 -- -- -- -- 17 [NE]
+       18 -- -- -- -- 23
+       24 -- -- -- -- 29
+          30 -- -- 33
+   [S]       34 35       [E]
+**************************************************************************/
+static bv_pixel pixel_border_hexa(const int x, const int y)
+{
+  bv_pixel pixel;
+  struct tile *ptile, *pcenter;
+  struct player *owner;
+
+  BV_CLR_ALL(pixel);
+
+  pcenter = map_pos_to_tile(x, y);
+  if (NULL == pcenter) {
+    /* no tile */
+    return pixel;
+  }
+
+  owner = tile_owner(pcenter);
+  if (NULL == owner) {
+    /* no border */
+    return pixel;
+  }
+
+  ptile = mapstep(pcenter, DIR8_WEST);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 0);
+    BV_SET(pixel, 2);
+    BV_SET(pixel, 6);
+  }
+
+  /* not used: DIR8_NORTHWEST */
+
+  ptile = mapstep(pcenter, DIR8_NORTH);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 1);
+    BV_SET(pixel, 5);
+    BV_SET(pixel, 11);
+  }
+
+  ptile = mapstep(pcenter, DIR8_NORTHEAST);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 11);
+    BV_SET(pixel, 17);
+    BV_SET(pixel, 23);
+    BV_SET(pixel, 29);
+  }
+
+  ptile = mapstep(pcenter, DIR8_EAST);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 29);
+    BV_SET(pixel, 33);
+    BV_SET(pixel, 35);
+  }
+
+  /* not used. DIR8_SOUTHEAST */
+
+  ptile = mapstep(pcenter, DIR8_SOUTH);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 24);
+    BV_SET(pixel, 30);
+    BV_SET(pixel, 34);
+  }
+
+  ptile = mapstep(pcenter, DIR8_SOUTHWEST);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 6);
+    BV_SET(pixel, 12);
+    BV_SET(pixel, 18);
+    BV_SET(pixel, 24);
+  }
+
+  return pixel;
+}
+
+/**************************************************************************
+  Base coordinates for the tiles on a hexa topology,
+**************************************************************************/
+static void base_coor_hexa(int *base_x, int *base_y, int x, int y)
+{
+  int nat_x, nat_y;
+  MAP_TO_NATIVE_POS(&nat_x, &nat_y, x, y);
+
+  *base_x = nat_x * TILE_SIZE + ((nat_y % 2) ? TILE_SIZE / 2 : 0);
+  *base_y = nat_y * TILE_SIZE;
+}
+
+/**************************************************************************
+         0  1  2  3
+      4  5  6  7  8  9
+  10 11 12 13 14 15 16 17
+  18 19 20 21 22 23 24 25
+     26 27 28 29 30 31
+        32 33 34 35
+**************************************************************************/
+static bv_pixel pixel_tile_isohexa(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_SET_ALL(pixel);
+
+  return pixel;
+}
+
+/**************************************************************************
+        -- -- -- --
+     --  5  6  7  8 --
+  -- 11 12 13 14 15 16 --
+  -- 19 20 21 22 23 24 --
+     -- 27 28 29 30 --
+        -- -- -- --
+**************************************************************************/
+static bv_pixel pixel_city_isohexa(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_CLR_ALL(pixel);
+  BV_SET(pixel, 5);
+  BV_SET(pixel, 6);
+  BV_SET(pixel, 7);
+  BV_SET(pixel, 8);
+  BV_SET(pixel, 11);
+  BV_SET(pixel, 12);
+  BV_SET(pixel, 13);
+  BV_SET(pixel, 14);
+  BV_SET(pixel, 15);
+  BV_SET(pixel, 16);
+  BV_SET(pixel, 19);
+  BV_SET(pixel, 20);
+  BV_SET(pixel, 21);
+  BV_SET(pixel, 22);
+  BV_SET(pixel, 23);
+  BV_SET(pixel, 24);
+  BV_SET(pixel, 27);
+  BV_SET(pixel, 28);
+  BV_SET(pixel, 29);
+  BV_SET(pixel, 30);
+
+  return pixel;
+}
+
+/**************************************************************************
+        -- -- -- --
+     -- -- -- -- -- --
+  -- -- -- 13 14 -- -- --
+  -- -- -- 21 22 -- -- --
+     -- -- -- -- -- --
+        -- -- -- --
+**************************************************************************/
+static bv_pixel pixel_unit_isohexa(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_CLR_ALL(pixel);
+  BV_SET(pixel, 13);
+  BV_SET(pixel, 14);
+  BV_SET(pixel, 21);
+  BV_SET(pixel, 22);
+
+  return pixel;
+}
+
+/**************************************************************************
+         0  1 -- --
+      4 -- --  7  8 --
+  -- -- 12 13 -- -- 16 17
+  18 19 -- -- 22 23 -- --
+     -- 27 28 -- -- 31
+        -- -- 34 35
+**************************************************************************/
+static bv_pixel pixel_fogofwar_isohexa(const int x, const int y)
+{
+  bv_pixel pixel;
+
+  BV_CLR_ALL(pixel);
+  BV_SET(pixel,  0);
+  BV_SET(pixel,  1);
+  BV_SET(pixel,  4);
+  BV_SET(pixel,  7);
+  BV_SET(pixel,  8);
+  BV_SET(pixel, 12);
+  BV_SET(pixel, 13);
+  BV_SET(pixel, 16);
+  BV_SET(pixel, 17);
+  BV_SET(pixel, 18);
+  BV_SET(pixel, 19);
+  BV_SET(pixel, 22);
+  BV_SET(pixel, 23);
+  BV_SET(pixel, 27);
+  BV_SET(pixel, 28);
+  BV_SET(pixel, 31);
+  BV_SET(pixel, 34);
+  BV_SET(pixel, 35);
+
+  return pixel;
+}
+
+/**************************************************************************
+
+               [N]
+
+  [NW]       0  1  2  3      [E]
+          4 -- -- -- --  9
+      10 -- -- -- -- -- -- 17
+      18 -- -- -- -- -- -- 25
+         26 -- -- -- -- 31
+  [W]       32 33 34 35      [SE]
+
+               [S]
+**************************************************************************/
+static bv_pixel pixel_border_isohexa(const int x, const int y)
+{
+  bv_pixel pixel;
+  struct tile *ptile, *pcenter;
+  struct player *owner;
+
+  BV_CLR_ALL(pixel);
+
+  pcenter = map_pos_to_tile(x, y);
+  if (NULL == pcenter) {
+    /* no tile */
+    return pixel;
+  }
+
+  owner = tile_owner(pcenter);
+  if (NULL == owner) {
+    /* no border */
+    return pixel;
+  }
+
+  ptile = mapstep(pcenter, DIR8_NORTH);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 0);
+    BV_SET(pixel, 1);
+    BV_SET(pixel, 2);
+    BV_SET(pixel, 3);
+  }
+
+  /* not used: DIR8_NORTHEAST */
+
+  ptile = mapstep(pcenter, DIR8_EAST);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 3);
+    BV_SET(pixel, 9);
+    BV_SET(pixel, 17);
+  }
+
+  ptile = mapstep(pcenter, DIR8_SOUTHEAST);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 25);
+    BV_SET(pixel, 31);
+    BV_SET(pixel, 35);
+  }
+
+  ptile = mapstep(pcenter, DIR8_SOUTH);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 32);
+    BV_SET(pixel, 33);
+    BV_SET(pixel, 34);
+    BV_SET(pixel, 35);
+  }
+
+  /* not used: DIR8_SOUTHWEST */
+
+  ptile = mapstep(pcenter, DIR8_WEST);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 18);
+    BV_SET(pixel, 26);
+    BV_SET(pixel, 32);
+  }
+
+  ptile = mapstep(pcenter, DIR8_NORTHWEST);
+  if (!ptile || tile_owner(ptile) != owner) {
+    BV_SET(pixel, 0);
+    BV_SET(pixel, 4);
+    BV_SET(pixel, 10);
+  }
+
+  return pixel;
+}
+
+/**************************************************************************
+  Base coordinates for the tiles on a isometric hexa topology,
+**************************************************************************/
+static void base_coor_isohexa(int *base_x, int *base_y, int x, int y)
+{
+  /* magic for iso-hexa */
+  y -= x / 2;
+  y += (map.xsize - 1)/2;
+
+  *base_x = x * TILE_SIZE;
+  *base_y = y * TILE_SIZE + ((x % 2) ? 0 : TILE_SIZE / 2);
+}
+
+/*
+ * ==============================================
+ * additonal functions
+ * ==============================================
+ */
+
+/**************************************************************************
+  Generate a file name for a map image.
+
+  <savename>-T<turn>-Y<year>-<mapstr>.<mapext>
+
+  <savename>-T<turn>-Y<year>: identical to filename for savegames
+  <mapstr>:                   map string as defined by this function
+                              M<map options>Z<zoom factor>P<player bitvector>
+                              For the player bitvector all 32 values are used
+                              due to the possibility of additional players
+                              during the game (civil war, barbarians).
+  <mapext>:                   image extension
+**************************************************************************/
+static int generate_img_name(char *buf, int buflen,
+                             const struct mapdef *pmapdef,
+                             const char *basename)
+{
+  int nb;
+
+  nb = my_snprintf(buf, buflen, "%s-M%c%c%c%c%c%c%cZ%dP%s",
+                   basename, pmapdef->area ? 'a' : '-',
+                   pmapdef->borders ? 'b' : '-', pmapdef->cities ? 'c' : '-',
+                   pmapdef->fogofwar ? 'f' : '-', pmapdef->known ? 'k' : '-',
+                   pmapdef->units ? 'u' : '-', pmapdef->terrain ? 't' : '-',
+                   pmapdef->zoom, bvplayers_str(pmapdef));
+
+  return nb;
+}
+
+/**************************************************************************
+  Convert the player bitvector to a string.
+**************************************************************************/
+static char *bvplayers_str(const struct mapdef *pmapdef)
+{
+  static char buf[MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS + 1];
+  int i;
+
+  switch (pmapdef->player.show) {
+  case SHOW_PLRNAME:
+  case SHOW_PLRID:
+    MAPIMG_RETURN_VAL_IF_FAIL((pmapdef->player.show != SHOW_PLRNAME
+                               || pmapdef->player.show != SHOW_PLRID),
+                              "error");
+    break;
+  case SHOW_NONE:
+    /* no player on the map */
+    sz_strlcpy(buf, "none");
+    break;
+  case SHOW_PLRBV:
+  case SHOW_EACH:
+    /* one map for each selected player; iterate over all posible player ids
+     * to generate unique strings even if civil wars occur */
+    for (i = 0; i < MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS; i++) {
+      buf[i] = BV_ISSET(pmapdef->player.plrbv, i) ? '1' : '0';
+    }
+    buf[MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS] = '\0';
+    break;
+  case SHOW_ALL:
+    /* show all players in one map */
+    sz_strlcpy(buf, "all");
+    break;
+  }
+
+  return buf;
+}
+
+/**************************************************************************
+  Return the number of players defined in a map image definition.
+**************************************************************************/
+static int bvplayers_count(const struct mapdef *pmapdef)
+{
+  int i, count = 0;
+
+  if (!game_was_started_todo()) {
+    /* game was never started */
+    return 0;
+  }
+
+  switch (pmapdef->player.show) {
+  case SHOW_NONE:    /* no player on the map */
+    count = 0;
+    break;
+  case SHOW_PLRNAME: /* the map of one selected player */
+  case SHOW_PLRID:
+    count = 1;
+    break;
+  case SHOW_PLRBV:   /* map showing only players given by a bitvector */
+    count = 0;
+    for (i = 0; i < MAX_NUM_PLAYERS + MAX_NUM_BARBARIANS; i++) {
+      if (BV_ISSET(pmapdef->player.plrbv, i)) {
+        count++;
+      }
+    }
+    break;
+  case SHOW_EACH:    /* one map for each player */
+    count = 1;
+    break;
+  case SHOW_ALL:     /* show all players in one map */
+    count = player_count();
+    break;
+  }
+
+  return count;
+}
+
+static bool game_was_started_todo(void)
+{
+  return TRUE;
+}
diff --git a/client/gui-gtk-2.0-mapimg/mapimg.h b/client/gui-gtk-2.0-mapimg/mapimg.h
new file mode 100644
index 0000000..34eff7a
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/mapimg.h
@@ -0,0 +1,68 @@
+/**********************************************************************
+ Freeciv - Copyright (C) 2010 - The Freeciv Team
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+/****************************************************************************
+  Map images:
+
+  * The color struct and the functions color_new() and color_destroy() are
+    used to define the colors for the player as well as for the terrain.
+
+  * Basic functions:
+
+    mapimg_init()       Initialise the map images.
+    mapimg_reset()      Reset the map images.
+    mapimg_free()       Free all memory needed for map images.
+    mapimg_count()      Return the number of map image definitions.
+    mapimg_error()      Return the last error message.
+    mapimg_help()       Return a help text.
+
+  * Advanced functions:
+
+    mapimg_define()     Define a new map image.
+    mapimg_isvalid()    Check if the map image is valid. this is only
+                        possible  after the game is started or if it is a
+                        savegame.
+    mapimg_delete()     Delete a map image definition.
+    mapimg_show()       Show the map image definition.
+    mapimg_create()     Create all defined and valid map images.
+    mapimg_colortest()  Create an image which shows all defined colors.
+    mapimg_id2str()     Convert the map image definition to strings. Usefull
+                        to save the definitions.
+
+    These functions return TRUE on success and FALSE on error. In the later
+    case the error message is available with mapimg_error().
+****************************************************************************/
+
+#ifndef FC__MAPIMG_H
+#define FC__MAPIMG_H
+
+/* common */
+#include "player.h" /* struct player */
+
+void mapimg_init(void);
+void mapimg_reset(void);
+void mapimg_free(void);
+int mapimg_count(void);
+const char *mapimg_help(void);
+const char *mapimg_error(void);
+
+bool mapimg_define(char *maparg, bool check);
+bool mapimg_isvalid(int id);
+bool mapimg_delete(int id);
+bool mapimg_show(int id, const char **str_show, bool detail);
+bool mapimg_create(int id, const char *basename, bool force);
+bool mapimg_colortest(const char *basename);
+bool mapimg_id2str(int id, const char **str_def);
+
+
+#endif  /* FC__MAPIMG_H */
diff --git a/client/gui-gtk-2.0-mapimg/mapview.c b/client/gui-gtk-2.0-mapimg/mapview.c
new file mode 100644
index 0000000..6d8af28
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/mapview.c
@@ -0,0 +1,241 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+/* utility */
+#include "fcintl.h"
+#include "support.h"
+
+/* common */
+#include "game.h"
+
+/* client */
+#include "client_main.h"
+#include "climisc.h"
+#include "control.h"
+#include "mapctrl_common.h"
+
+#include "mapview.h"
+
+/****************************************************************************
+  Typically an info box is provided to tell the player about the state
+  of their civilization.  This function is called when the label is
+  changed.
+****************************************************************************/
+void update_info_label(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Update the information label which gives info on the current unit
+  and the tile under the current unit, for specified unit.  Note that
+  in practice punit is always the focus unit.
+
+  Clears label if punit is NULL.
+
+  Typically also updates the cursor for the map_canvas (this is
+  related because the info label may includes "select destination"
+  prompt etc).  And it may call update_unit_pix_label() to update the
+  icons for units on this tile.
+****************************************************************************/
+void update_unit_info_label(struct unit_list *punitlist)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Update the mouse cursor. Cursor type depends on what user is doing and
+  pointing.
+****************************************************************************/
+void update_mouse_cursor(enum cursor_type new_cursor_type)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Update the timeout display.  The timeout is the time until the turn
+  ends, in seconds.
+****************************************************************************/
+void update_timeout_label(void)
+{
+  /* PORTME */
+    
+  /* set some widget based on get_timeout_label_text() */
+}
+
+/****************************************************************************
+  If do_restore is FALSE it should change the turn button style (to
+  draw the user's attention to it).  If called regularly from a timer
+  this will give a blinking turn done button.  If do_restore is TRUE
+  this should reset the turn done button to the default style.
+****************************************************************************/
+void update_turn_done_button(bool do_restore)
+{
+  static bool flip = FALSE;
+  
+  if (!get_turn_done_button_state()) {
+    return;
+  }
+
+  if ((do_restore && flip) || !do_restore) {
+    /* ... */
+
+    flip = !flip;
+  }
+  /* PORTME */
+}
+
+/****************************************************************************
+  Set information for the indicator icons typically shown in the main
+  client window.  The parameters tell which sprite to use for the
+  indicator.
+****************************************************************************/
+void set_indicator_icons(struct sprite *bulb, struct sprite *sol,
+			 struct sprite *flake, struct sprite *gov)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Return a canvas that is the overview window.
+****************************************************************************/
+struct canvas *get_overview_window(void)
+{
+  /* PORTME */
+  return NULL;
+}
+
+/****************************************************************************
+  Flush the given part of the canvas buffer (if there is one) to the
+  screen.
+****************************************************************************/
+void flush_mapcanvas(int canvas_x, int canvas_y,
+		     int pixel_width, int pixel_height)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Mark the rectangular region as "dirty" so that we know to flush it
+  later.
+****************************************************************************/
+void dirty_rect(int canvas_x, int canvas_y,
+		int pixel_width, int pixel_height)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Mark the entire screen area as "dirty" so that we can flush it later.
+****************************************************************************/
+void dirty_all(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Flush all regions that have been previously marked as dirty.  See
+  dirty_rect and dirty_all.  This function is generally called after we've
+  processed a batch of drawing operations.
+****************************************************************************/
+void flush_dirty(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Do any necessary synchronization to make sure the screen is up-to-date.
+  The canvas should have already been flushed to screen via flush_dirty -
+  all this function does is make sure the hardware has caught up.
+****************************************************************************/
+void gui_flush(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Update (refresh) the locations of the mapview scrollbars (if it uses
+  them).
+****************************************************************************/
+void update_map_canvas_scrollbars(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Update the size of the sliders on the scrollbars.
+****************************************************************************/
+void update_map_canvas_scrollbars_size(void)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Update (refresh) all city descriptions on the mapview.
+****************************************************************************/
+void update_city_descriptions(void)
+{
+  update_map_canvas_visible();
+}
+
+/****************************************************************************
+  Draw a cross-hair overlay on a tile.
+****************************************************************************/
+void put_cross_overlay_tile(struct tile *ptile)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+ Area Selection
+****************************************************************************/
+void draw_selection_rectangle(int canvas_x, int canvas_y, int w, int h)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  This function is called when the tileset is changed.
+****************************************************************************/
+void tileset_changed(void)
+{
+  /* PORTME */
+  /* Here you should do any necessary redraws (for instance, the city
+   * dialogs usually need to be resized). */
+}
+
+/****************************************************************************
+  Return the dimensions of the area (container widget; maximum size) for
+  the overview.
+****************************************************************************/
+void get_overview_area_dimensions(int *width, int *height)
+{
+  /* PORTME */
+  *width = 0;
+  *height = 0;  
+}
+
+/****************************************************************************
+  Called when the map size changes. This may be used to change the
+  size of the GUI element holding the overview canvas. The
+  overview.width and overview.height are updated if this function is
+  called.
+****************************************************************************/
+void overview_size_changed(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/mapview.h b/client/gui-gtk-2.0-mapimg/mapview.h
new file mode 100644
index 0000000..985578e
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/mapview.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__MAPVIEW_H
+#define FC__MAPVIEW_H
+
+#include "mapview_g.h"
+
+
+#endif				/* FC__MAPVIEW_H */
diff --git a/client/gui-gtk-2.0-mapimg/menu.c b/client/gui-gtk-2.0-mapimg/menu.c
new file mode 100644
index 0000000..a004e6e
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/menu.c
@@ -0,0 +1,38 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "menu.h"
+
+/**************************************************************************
+  Initialize menus (sensitivity, name, etc.) based on the
+  current state and current ruleset, etc.  Call menus_update().
+**************************************************************************/
+void menus_init(void)
+{
+  /* PORTME */
+
+  menus_update();
+}
+
+/**************************************************************************
+  Update all of the menus (sensitivity, name, etc.) based on the
+  current state.
+**************************************************************************/
+void menus_update(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/menu.h b/client/gui-gtk-2.0-mapimg/menu.h
new file mode 100644
index 0000000..44b13e6
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/menu.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__MENU_H
+#define FC__MENU_H
+
+#include "menu_g.h"
+
+
+#endif				/* FC__MENU_H */
diff --git a/client/gui-gtk-2.0-mapimg/messagedlg.c b/client/gui-gtk-2.0-mapimg/messagedlg.c
new file mode 100644
index 0000000..838d031
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/messagedlg.c
@@ -0,0 +1,28 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "options.h"
+
+#include "messagedlg.h"
+
+/**************************************************************************
+  Popup a window to let the user edit their message options.
+**************************************************************************/
+void popup_messageopt_dialog(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/messagedlg.h b/client/gui-gtk-2.0-mapimg/messagedlg.h
new file mode 100644
index 0000000..70a98b1
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/messagedlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 2003 - The Freeciv Project
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__MESSAGEDLG_H
+#define FC__MESSAGEDLG_H
+
+#include "messagedlg_g.h"
+
+/* nothing to add */
+
+#endif				/* FC__MESSAGEDLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/messagewin.c b/client/gui-gtk-2.0-mapimg/messagewin.c
new file mode 100644
index 0000000..f3f16a5
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/messagewin.c
@@ -0,0 +1,44 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "messagewin.h"
+
+/**************************************************************************
+  Display the message dialog.  Optionally raise it.
+  Typically triggered by F10.
+**************************************************************************/
+void popup_meswin_dialog(bool raise)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Return whether the message dialog is open.
+**************************************************************************/
+bool is_meswin_open(void)
+{
+  /* PORTME */
+  return FALSE;
+}
+
+/**************************************************************************
+  Do the work of updating (populating) the message dialog.
+**************************************************************************/
+void real_update_meswin_dialog(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/messagewin.h b/client/gui-gtk-2.0-mapimg/messagewin.h
new file mode 100644
index 0000000..538b62b
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/messagewin.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__MESSAGEWIN_H
+#define FC__MESSAGEWIN_H
+
+#include "messagewin_g.h"
+
+
+#endif				/* FC__MESSAGEWIN_H */
diff --git a/client/gui-gtk-2.0-mapimg/pages.c b/client/gui-gtk-2.0-mapimg/pages.c
new file mode 100644
index 0000000..bf65ed2
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/pages.c
@@ -0,0 +1,55 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996-2004 - The Freeciv Team
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "connectdlg_g.h"
+
+#include "pages.h"
+
+/**************************************************************************
+  Sets the "page" that the client should show.  See also pages_g.h.
+**************************************************************************/
+void set_client_page(enum client_pages page)
+{
+  /* PORTME */
+}
+
+/****************************************************************************
+  Set the list of available rulesets.  The default ruleset should be
+  "default", and if the user changes this then set_ruleset() should be
+  called.
+****************************************************************************/
+void gui_set_rulesets(int num_rulesets, char **rulesets)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Returns current client page
+**************************************************************************/
+enum client_pages get_client_page(void)
+{
+  /* PORTME */
+  return PAGE_MAIN;
+}
+
+/**************************************************************************
+  update the start page.
+**************************************************************************/
+void update_start_page(void)
+{
+  /* PORTME */    
+}
diff --git a/client/gui-gtk-2.0-mapimg/pages.h b/client/gui-gtk-2.0-mapimg/pages.h
new file mode 100644
index 0000000..2ccbda4
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/pages.h
@@ -0,0 +1,18 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996-2004 - The Freeciv Team
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__PAGES_H
+#define FC__PAGES_H
+
+#include "pages_g.h"
+
+#endif  /* FC__PAGES_H */
diff --git a/client/gui-gtk-2.0-mapimg/plrdlg.c b/client/gui-gtk-2.0-mapimg/plrdlg.c
new file mode 100644
index 0000000..0d10e85
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/plrdlg.c
@@ -0,0 +1,34 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "plrdlg.h"
+
+/**************************************************************************
+  Display the player list dialog.  Optionally raise it.
+**************************************************************************/
+void popup_players_dialog(bool raise)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Update all information in the player list dialog.
+**************************************************************************/
+void update_players_dialog(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/plrdlg.h b/client/gui-gtk-2.0-mapimg/plrdlg.h
new file mode 100644
index 0000000..254c86f
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/plrdlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__PLRDLG_H
+#define FC__PLRDLG_H
+
+#include "plrdlg_g.h"
+
+
+#endif				/* FC__PLRDLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/ratesdlg.c b/client/gui-gtk-2.0-mapimg/ratesdlg.c
new file mode 100644
index 0000000..d253889
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/ratesdlg.c
@@ -0,0 +1,26 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "ratesdlg.h"
+
+/**************************************************************************
+  Popup (or raise) the (tax/science/luxury) rates selection dialog.
+**************************************************************************/
+void popup_rates_dialog(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/ratesdlg.h b/client/gui-gtk-2.0-mapimg/ratesdlg.h
new file mode 100644
index 0000000..62d2244
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/ratesdlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 2003 - The Freeciv Project
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__RATESDLG_H
+#define FC__RATESDLG_H
+
+#include "ratesdlg_g.h"
+
+/* nothing to add */
+
+#endif				/* FC__RATESDLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/rc2c b/client/gui-gtk-2.0-mapimg/rc2c
new file mode 100755
index 0000000..59be2ce
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/rc2c
@@ -0,0 +1,41 @@
+#!/bin/sh
+#
+#	rc2c : Convert resource file to C strings decls, based on ad2c.
+#
+#	George Ferguson, ferguson@cs.rcohester.edu, 12 Nov 1990.
+#	19 Mar 1991 : gf
+#		Made it self-contained.
+#	6 Jan 1992 : mycroft@gnu.ai.mit.edu (Charles Hannum)
+#		Removed use of "-n" and ":read" label since Gnu and
+#		IBM sed print pattern space on "n" command. Still works
+#		with Sun sed, of course.
+#	7 Jan 1992: matthew@sunpix.East.Sun.COM (Matthew Stier)
+#		Escape quotes after escaping backslashes.
+#	4 Mar 2000: vasc@rnl.ist.utl.pt (Vasco Costa)
+#		Modified to convert Gtk+ resource files instead of
+#		X app-default files.
+#
+
+sed '
+/^!/d
+/^$/d
+s/\\/\\\\/g
+s/\\$//g
+s/"/\\"/g
+s/^/"/
+: test
+/\\$/b slash
+s/$/\\n"/
+p
+d
+: slash
+n
+/^!/d
+/^$/d
+s/"/\\"/g
+s/\\\\/\\/g
+s/\\n/\\\\n/g
+s/\\t/\\\\t/g
+s/\\f/\\\\f/g
+s/\\b/\\\\b/g
+b test' "$@"
diff --git a/client/gui-gtk-2.0-mapimg/repodlgs.c b/client/gui-gtk-2.0-mapimg/repodlgs.c
new file mode 100644
index 0000000..ebb2f81
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/repodlgs.c
@@ -0,0 +1,104 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+
+#include "repodlgs_common.h"
+
+#include "cityrep.h"
+
+#include "repodlgs.h"
+
+/**************************************************************************
+  Update all report dialogs.
+**************************************************************************/
+void update_report_dialogs(void)
+{
+  if (!is_report_dialogs_frozen()) {
+    activeunits_report_dialog_update();
+    economy_report_dialog_update();
+    city_report_dialog_update(); 
+    science_dialog_update();
+  }
+}
+
+/**************************************************************************
+  Update the science report.
+**************************************************************************/
+void science_dialog_update(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Display the science report.  Optionally raise it.
+  Typically triggered by F6.
+**************************************************************************/
+void popup_science_dialog(bool raise)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Update the economy report.
+**************************************************************************/
+void economy_report_dialog_update(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Display the economy report.  Optionally raise it.
+  Typically triggered by F5.
+**************************************************************************/
+void popup_economy_report_dialog(bool raise)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Update the units report.
+**************************************************************************/
+void activeunits_report_dialog_update(void)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Display the units report.  Optionally raise it.
+  Typically triggered by F2.
+**************************************************************************/
+void popup_activeunits_report_dialog(bool raise)
+{
+  /* PORTME */
+}
+
+/****************************************************************
+  Show a dialog with player statistics at endgame.
+*****************************************************************/
+void popup_endgame_report_dialog(struct packet_endgame_report *packet)
+{
+  /* PORTME */
+}
+
+/*************************************************************************
+  Show a dialog with the server options.
+*************************************************************************/
+void popup_settable_options_dialog(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/repodlgs.h b/client/gui-gtk-2.0-mapimg/repodlgs.h
new file mode 100644
index 0000000..a470fa9
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/repodlgs.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__REPODLGS_H
+#define FC__REPODLGS_H
+
+#include "repodlgs_g.h"
+
+
+#endif				/* FC__REPODLGS_H */
diff --git a/client/gui-gtk-2.0-mapimg/resources.c b/client/gui-gtk-2.0-mapimg/resources.c
new file mode 100644
index 0000000..1b4038f
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/resources.c
@@ -0,0 +1,26 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <gtk/gtk.h>
+
+/**************************************************************************
+Fallback resources
+**************************************************************************/
+
+const gchar *fallback_resources =
+#include <Freeciv.h>
+;
diff --git a/client/gui-gtk-2.0-mapimg/resources.h b/client/gui-gtk-2.0-mapimg/resources.h
new file mode 100644
index 0000000..40566ce
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/resources.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__RESOURCES_H
+#define FC__RESOURCES_H
+
+#include <gtk/gtk.h>
+
+extern gchar *fallback_resources;
+
+#endif  /* FC__RESOURCES_H */
diff --git a/client/gui-gtk-2.0-mapimg/spaceshipdlg.c b/client/gui-gtk-2.0-mapimg/spaceshipdlg.c
new file mode 100644
index 0000000..d98b2f7
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/spaceshipdlg.c
@@ -0,0 +1,43 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "spaceshipdlg.h"
+
+
+/**************************************************************************
+  Popup (or raise) the spaceship dialog for the given player.
+**************************************************************************/
+void popup_spaceship_dialog(struct player *pplayer)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Close the spaceship dialog for the given player.
+**************************************************************************/
+void popdown_spaceship_dialog(struct player *pplayer)
+{
+  /* PORTME */
+}
+
+/**************************************************************************
+  Refresh (update) the spaceship dialog for the given player.
+**************************************************************************/
+void refresh_spaceship_dialog(struct player *pplayer)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/spaceshipdlg.h b/client/gui-gtk-2.0-mapimg/spaceshipdlg.h
new file mode 100644
index 0000000..14673c7
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/spaceshipdlg.h
@@ -0,0 +1,20 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__SPACESHIPDLG_H
+#define FC__SPACESHIPDLG_H
+
+#include "spaceshipdlg_g.h"
+
+
+#endif				/* FC__SPACESHIPDLG_H */
diff --git a/client/gui-gtk-2.0-mapimg/sprite.c b/client/gui-gtk-2.0-mapimg/sprite.c
new file mode 100644
index 0000000..7a2104d
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/sprite.c
@@ -0,0 +1,405 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996-2005 - Freeciv Development Team
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+/* utility */
+#include "log.h"
+#include "shared.h"
+
+#include "sprite.h"
+
+/****************************************************************************
+  Create a new sprite by cropping and taking only the given portion of
+  the image.
+
+  source gives the sprite that is to be cropped.
+
+  x,y, width, height gives the rectangle to be cropped.  The pixel at
+  position of the source sprite will be at (0,0) in the new sprite, and
+  the new sprite will have dimensions (width, height).
+
+  mask gives an additional mask to be used for clipping the new sprite.
+
+  mask_offset_x, mask_offset_y is the offset of the mask relative to the
+  origin of the source image.  The pixel at (mask_offset_x,mask_offset_y)
+  in the mask image will be used to clip pixel (0,0) in the source image
+  which is pixel (-x,-y) in the new image.
+****************************************************************************/
+struct sprite *crop_sprite(struct sprite *source,
+			   int x, int y,
+			   int width, int height,
+			   struct sprite *mask,
+			   int mask_offset_x, int mask_offset_y)
+{
+  GdkPixbuf *mypixbuf, *sub, *mask_pixbuf;
+
+  /* First just crop the image. */
+  if (x < 0) {
+    width += x;
+    x = 0;
+  }
+  if (y < 0) {
+    height += y;
+    y = 0;
+  }
+  width = CLIP(0, width, source->width - x);
+  height = CLIP(0, height, source->height - y);
+  sub = gdk_pixbuf_new_subpixbuf(sprite_get_pixbuf(source), x, y,
+				 width, height);
+  mypixbuf = gdk_pixbuf_copy(sub);
+  g_object_unref(sub);
+
+  /* Now mask.  This reduces the alpha of the final image proportional to the
+   * alpha of the mask.  Thus if the mask has 50% alpha the final image will
+   * be reduced by 50% alpha.  Note that the mask offset is in coordinates
+   * relative to the clipped image not the final image. */
+  if (mask
+      && (mask_pixbuf = sprite_get_pixbuf(mask))
+      && gdk_pixbuf_get_has_alpha(mask_pixbuf)) {
+    int x1, y1;
+
+    /* The mask offset is the offset of the mask relative to the origin
+     * of the original source image.  For instance when cropping with
+     * blending sprites the offset is always 0.  Here we convert the
+     * coordinates so that they are relative to the origin of the new
+     * (cropped) image. */
+    mask_offset_x -= x;
+    mask_offset_y -= y;
+
+    width = CLIP(0, width, mask->width + mask_offset_x);
+    height = CLIP(0, height, mask->height + mask_offset_y);
+
+    if (!gdk_pixbuf_get_has_alpha(mypixbuf)) {
+      GdkPixbuf *p2 = mypixbuf;
+
+      mypixbuf = gdk_pixbuf_add_alpha(mypixbuf, FALSE, 0, 0, 0);
+      g_object_unref(p2);
+    }
+
+    for (x1 = 0; x1 < width; x1++) {
+      for (y1 = 0; y1 < height; y1++) {
+	int mask_x = x1 - mask_offset_x, mask_y = y1 - mask_offset_y;
+	guchar *alpha = gdk_pixbuf_get_pixels(mypixbuf)
+	  + y1 * gdk_pixbuf_get_rowstride(mypixbuf)
+	  + x1 * gdk_pixbuf_get_n_channels(mypixbuf)
+	  + 3;
+	guchar *mask_alpha = gdk_pixbuf_get_pixels(mask_pixbuf)
+	  + mask_y * gdk_pixbuf_get_rowstride(mask_pixbuf)
+	  + mask_x * gdk_pixbuf_get_n_channels(mask_pixbuf)
+	  + 3;
+
+	*alpha = (*alpha) * (*mask_alpha) / 255;
+      }
+    }
+  }
+
+  return ctor_sprite(mypixbuf);
+}
+
+/****************************************************************************
+  Find the dimensions of the sprite.
+****************************************************************************/
+void get_sprite_dimensions(struct sprite *sprite, int *width, int *height)
+{
+  *width = sprite->width;
+  *height = sprite->height;
+}
+
+/****************************************************************************
+  Create a new sprite with the given pixmap, dimensions, and
+  (optional) mask.
+
+  FIXME: should be renamed as sprite_new or some such.
+****************************************************************************/
+struct sprite *ctor_sprite(GdkPixbuf *pixbuf)
+{
+  struct sprite *sprite = fc_malloc(sizeof(*sprite));
+  bool has_alpha = FALSE, has_mask = FALSE;
+
+  sprite->width = gdk_pixbuf_get_width(pixbuf);
+  sprite->height = gdk_pixbuf_get_height(pixbuf);
+
+  /* Check to see if this pixbuf has an alpha layer. */
+  if (gdk_pixbuf_get_has_alpha(pixbuf)) {
+    guchar *pixels = gdk_pixbuf_get_pixels(pixbuf);
+    int x, y, rowstride = gdk_pixbuf_get_rowstride(pixbuf);
+
+    for (y = 0; y < sprite->height; y++) {
+      for (x = 0; x < sprite->width; x++) {
+	int i = y * rowstride + 4 * x + 3;
+	guchar pixel = pixels[i];
+
+	if (pixel > 0 && pixel < 255) {
+	  has_alpha = TRUE;
+	}
+	if (pixel == 0) {
+	  has_mask = TRUE;
+	}
+      }
+    }
+  }
+
+  sprite->pixbuf_fogged = NULL;
+  sprite->pixmap_fogged = NULL;
+  if (has_alpha) {
+    sprite->pixbuf = pixbuf;
+    sprite->pixmap = NULL;
+    sprite->mask = NULL;
+  } else {
+    gdk_pixbuf_render_pixmap_and_mask(pixbuf, &sprite->pixmap,
+				      &sprite->mask, 1);
+    if (!has_mask && sprite->mask) {
+      g_object_unref(sprite->mask);
+      sprite->mask = NULL;
+    }
+    g_object_unref(pixbuf);
+    sprite->pixbuf = NULL;
+  }
+  return sprite;
+}
+
+/****************************************************************************
+  Returns the filename extensions the client supports
+  Order is important.
+****************************************************************************/
+const char **gfx_fileextensions(void)
+{
+  static const char *ext[] =
+  {
+    "png",
+    "xpm",
+    NULL
+  };
+
+  return ext;
+}
+
+/****************************************************************************
+  Load the given graphics file into a sprite.  This function loads an
+  entire image file, which may later be broken up into individual sprites
+  with crop_sprite.
+****************************************************************************/
+struct sprite *load_gfxfile(const char *filename)
+{
+  GdkPixbuf *im;
+
+  if (!(im = gdk_pixbuf_new_from_file(filename, NULL))) {
+    log_fatal("Failed reading graphics file: \"%s\"", filename);
+    exit(EXIT_FAILURE);
+  }
+
+  return ctor_sprite(im);
+}
+
+/****************************************************************************
+  Free a sprite and all associated image data.
+****************************************************************************/
+void free_sprite(struct sprite * s)
+{
+  if (s->pixmap) {
+    g_object_unref(s->pixmap);
+    s->pixmap = NULL;
+  }
+  if (s->mask) {
+    g_object_unref(s->mask);
+    s->mask = NULL;
+  }
+  if (s->pixbuf) {
+    g_object_unref(s->pixbuf);
+    s->pixbuf = NULL;
+  }
+  if (s->pixmap_fogged) {
+    g_object_unref(s->pixmap_fogged);
+  }
+  if (s->pixbuf_fogged) {
+    g_object_unref(s->pixbuf_fogged);
+  }
+  free(s);
+}
+
+/****************************************************************************
+  Scales a sprite. If the sprite contains a mask, the mask is scaled
+  as as well.
+****************************************************************************/
+struct sprite *sprite_scale(struct sprite *src, int new_w, int new_h)
+{
+  return ctor_sprite(gdk_pixbuf_scale_simple(sprite_get_pixbuf(src),
+					     new_w, new_h,
+					     GDK_INTERP_BILINEAR));
+}
+
+/****************************************************************************
+  Method returns the bounding box of a sprite. It assumes a rectangular
+  object/mask. The bounding box contains the border (pixel which have
+  unset pixel as neighbours) pixel.
+****************************************************************************/
+void sprite_get_bounding_box(struct sprite * sprite, int *start_x,
+			     int *start_y, int *end_x, int *end_y)
+{
+  GdkImage *mask_image;
+  GdkBitmap *mask = sprite_get_mask(sprite);
+  int i, j;
+
+  if (!mask) {
+    *start_x = 0;
+    *start_y = 0;
+    *end_x = sprite->width - 1;
+    *end_y = sprite->height - 1;
+    return;
+  }
+
+  mask_image
+    = gdk_drawable_get_image(mask, 0, 0, sprite->width, sprite->height);
+
+
+  /* parses mask image for the first column that contains a visible pixel */
+  *start_x = -1;
+  for (i = 0; i < sprite->width && *start_x == -1; i++) {
+    for (j = 0; j < sprite->height; j++) {
+      if (gdk_image_get_pixel(mask_image, i, j) != 0) {
+	*start_x = i;
+	break;
+      }
+    }
+  }
+
+  /* parses mask image for the last column that contains a visible pixel */
+  *end_x = -1;
+  for (i = sprite->width - 1; i >= *start_x && *end_x == -1; i--) {
+    for (j = 0; j < sprite->height; j++) {
+      if (gdk_image_get_pixel(mask_image, i, j) != 0) {
+	*end_x = i;
+	break;
+      }
+    }
+  }
+
+  /* parses mask image for the first row that contains a visible pixel */
+  *start_y = -1;
+  for (i = 0; i < sprite->height && *start_y == -1; i++) {
+    for (j = *start_x; j <= *end_x; j++) {
+      if (gdk_image_get_pixel(mask_image, j, i) != 0) {
+	*start_y = i;
+	break;
+      }
+    }
+  }
+
+  /* parses mask image for the last row that contains a visible pixel */
+  *end_y = -1;
+  for (i = sprite->height - 1; i >= *end_y && *end_y == -1; i--) {
+    for (j = *start_x; j <= *end_x; j++) {
+      if (gdk_image_get_pixel(mask_image, j, i) != 0) {
+	*end_y = i;
+	break;
+      }
+    }
+  }
+
+  g_object_unref(mask_image);
+}
+
+/****************************************************************************
+  Crops all blankspace from a sprite (insofar as is possible as a rectangle)
+****************************************************************************/
+struct sprite *crop_blankspace(struct sprite *s)
+{
+  int x1, y1, x2, y2;
+
+  sprite_get_bounding_box(s, &x1, &y1, &x2, &y2);
+
+  return crop_sprite(s, x1, y1, x2 - x1 + 1, y2 - y1 + 1, NULL, -1, -1);
+}
+
+/****************************************************************************
+  Converts a pixmap/mask sprite to a GdkPixbuf.
+
+  This is just a helper function for sprite_get_pixbuf().  Most callers
+  should use that function instead.
+****************************************************************************/
+static GdkPixbuf *gdk_pixbuf_new_from_pixmap_sprite(struct sprite *src)
+{
+  GdkPixbuf *dst;
+  int w, h;
+
+  w = src->width;
+  h = src->height;
+  
+  /* convert pixmap */
+  dst = gdk_pixbuf_new(GDK_COLORSPACE_RGB, src->mask != NULL, 8, w, h);
+  gdk_pixbuf_get_from_drawable(dst, src->pixmap, NULL, 0, 0, 0, 0, w, h);
+
+  /* convert mask */
+  if (src->mask) {
+    GdkImage *img;
+    int x, y, rowstride;
+    guchar *pixels;
+
+    img = gdk_drawable_get_image(src->mask, 0, 0, w, h);
+
+    pixels = gdk_pixbuf_get_pixels(dst);
+    rowstride = gdk_pixbuf_get_rowstride(dst);
+
+    for (y = 0; y < h; y++) {
+      for (x = 0; x < w; x++) {
+	guchar *pixel = pixels + y * rowstride + x * 4 + 3;
+
+	if (gdk_image_get_pixel(img, x, y)) {
+	  *pixel = 255;
+	} else {
+	  *pixel = 0;
+	}
+      }
+    }
+    g_object_unref(img);
+  }
+
+  return dst;
+}
+
+/********************************************************************
+  Render a pixbuf from the sprite.
+
+  NOTE: the pixmap and mask of a sprite must not change after this
+        function is called!
+********************************************************************/
+GdkPixbuf *sprite_get_pixbuf(struct sprite *sprite)
+{
+  if (!sprite) {
+    return NULL;
+  }
+  
+  if (!sprite->pixbuf) {
+    sprite->pixbuf = gdk_pixbuf_new_from_pixmap_sprite(sprite);
+  }
+  return sprite->pixbuf;
+}
+
+/****************************************************************************
+  Render a mask from the sprite.
+
+  NOTE: the pixbuf of a sprite must not change after this function is called!
+****************************************************************************/
+GdkBitmap *sprite_get_mask(struct sprite *sprite)
+{
+  if (!sprite->pixmap && !sprite->mask) {
+    /* If we're not in pixmap mode and we don't yet have a mask, render
+     * the pixbuf to a mask. */
+    gdk_pixbuf_render_pixmap_and_mask(sprite->pixbuf, NULL,
+				      &sprite->mask, 1);
+  }
+  return sprite->mask;
+}
diff --git a/client/gui-gtk-2.0-mapimg/sprite.h b/client/gui-gtk-2.0-mapimg/sprite.h
new file mode 100644
index 0000000..f259a7a
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/sprite.h
@@ -0,0 +1,47 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996-2005 - Freeciv Development Team
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__SPRITE_H
+#define FC__SPRITE_H
+
+#include <gtk/gtk.h>
+
+#include "sprite_g.h"
+
+struct sprite
+{
+  /* A pixmap + mask is used if there's a 1-bit alpha channel.  mask may be
+   * NULL if there's no alpha.  For multi-bit alpha levels, a pixbuf will be
+   * used instead.  For consistency a pixbuf may be generated on-demand when
+   * doing drawing (into a gtkpixcomm or gtkimage), so it's important that
+   * the sprite data not be changed after the sprite is loaded. */
+  GdkPixmap *pixmap, *pixmap_fogged;
+  GdkBitmap *mask;
+  GdkPixbuf *pixbuf, *pixbuf_fogged;
+
+  int	     width;
+  int	     height;
+};
+
+struct sprite *ctor_sprite(GdkPixbuf *pixbuf);
+struct sprite *sprite_scale(struct sprite *src, int new_w, int new_h);
+void sprite_get_bounding_box(struct sprite *sprite, int *start_x,
+			     int *start_y, int *end_x, int *end_y);
+struct sprite *crop_blankspace(struct sprite *s);
+
+/********************************************************************
+  Note: a sprite cannot be changed after these functions are called!
+********************************************************************/
+GdkPixbuf *sprite_get_pixbuf(struct sprite *sprite);
+GdkBitmap *sprite_get_mask(struct sprite *sprite);
+
+#endif  /* FC__SPRITE_H */
diff --git a/client/gui-gtk-2.0-mapimg/themes.c b/client/gui-gtk-2.0-mapimg/themes.c
new file mode 100644
index 0000000..5a6e49d
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/themes.c
@@ -0,0 +1,59 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 2005 The Freeciv Team
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "themes_common.h"
+#include "themes_g.h"
+
+/*****************************************************************************
+  Loads a gtk theme directory/theme_name
+*****************************************************************************/
+void gui_load_theme(const char *directory, const char *theme_name)
+{
+  /* Nothing */
+}
+
+/*****************************************************************************
+  Clears a theme (sets default system theme)
+*****************************************************************************/
+void gui_clear_theme(void)
+{
+  /* Nothing */
+}
+
+/*****************************************************************************
+  Each gui has its own themes directories.
+
+  Returns an array containing these strings and sets array size in count.
+  The caller is responsible for freeing the array and the paths.
+*****************************************************************************/
+char **get_gui_specific_themes_directories(int *count)
+{
+  *count = 0;
+  
+  return fc_malloc(sizeof(char*) * 0);
+}
+
+/*****************************************************************************
+  Return an array of names of usable themes in the given directory.
+  Array size is stored in count.
+  Useable theme for gtk+ is a directory which contains file gtk-2.0/gtkrc.
+  The caller is responsible for freeing the array and the names
+*****************************************************************************/
+char **get_useable_themes_in_directory(const char *directory, int *count)
+{
+  *count = 0;
+  return fc_malloc(sizeof(char*) * 0);
+}
diff --git a/client/gui-gtk-2.0-mapimg/voteinfo_bar.c b/client/gui-gtk-2.0-mapimg/voteinfo_bar.c
new file mode 100644
index 0000000..d78eade
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/voteinfo_bar.c
@@ -0,0 +1,30 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+/* client */
+#include "voteinfo.h"
+
+#include "voteinfo_bar.h"
+
+/****************************************************************************
+  Refresh all vote related GUI widgets. Called by the voteinfo module when
+  the client receives new vote information from the server.
+****************************************************************************/
+void voteinfo_gui_update(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/voteinfo_bar.h b/client/gui-gtk-2.0-mapimg/voteinfo_bar.h
new file mode 100644
index 0000000..f5d1031
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/voteinfo_bar.h
@@ -0,0 +1,19 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__VOTEBAR_H
+#define FC__VOTEBAR_H
+
+/* include */
+#include "voteinfo_bar_g.h"
+
+#endif  /* FC__VOTEBAR_H */
diff --git a/client/gui-gtk-2.0-mapimg/wldlg.c b/client/gui-gtk-2.0-mapimg/wldlg.c
new file mode 100644
index 0000000..0acf049
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/wldlg.c
@@ -0,0 +1,26 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "wldlg.h"
+
+/**************************************************************************
+  If the worklist report is open, force its contents to be updated.
+**************************************************************************/
+void update_worklist_report_dialog(void)
+{
+  /* PORTME */
+}
diff --git a/client/gui-gtk-2.0-mapimg/wldlg.h b/client/gui-gtk-2.0-mapimg/wldlg.h
new file mode 100644
index 0000000..6492ee9
--- /dev/null
+++ b/client/gui-gtk-2.0-mapimg/wldlg.h
@@ -0,0 +1,19 @@
+/********************************************************************** 
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifndef FC__WLDLG_H
+#define FC__WLDLG_H
+
+void update_worklist_report_dialog(void);
+
+#endif				/* FC__WLDLG_H */
diff --git a/client/tilespec.c b/client/tilespec.c
index 93f59d8..00cb03f 100644
--- a/client/tilespec.c
+++ b/client/tilespec.c
@@ -5123,6 +5123,7 @@ void tileset_use_prefered_theme(const struct tileset *t)
 
   switch (get_gui_type()) {
   case GUI_GTK2:
+  case GUI_MAPIMG:
     default_theme_name = gui_gtk2_default_theme_name;
     default_theme_name_sz = sizeof(gui_gtk2_default_theme_name);
     break;
diff --git a/common/Makefile.am b/common/Makefile.am
index b8d28ac..a6f1e72 100644
--- a/common/Makefile.am
+++ b/common/Makefile.am
@@ -21,6 +21,8 @@ libfreeciv_la_SOURCES = \
 		combat.h	\
 		connection.c	\
 		connection.h	\
+		console.c	\
+		console.h	\
 		dataio.c	\
 		dataio.h	\
 		diptreaty.c	\
diff --git a/common/console.c b/common/console.c
new file mode 100644
index 0000000..dad3589
--- /dev/null
+++ b/common/console.c
@@ -0,0 +1,227 @@
+/**********************************************************************
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+
+#ifdef HAVE_LIBREADLINE
+#include <readline/readline.h>
+#endif
+
+/* utility */
+#include "fciconv.h"
+#include "fcintl.h"
+#include "log.h"
+#include "support.h"
+
+/* common */
+#include "featured_text.h"
+#include "game.h"
+
+#include "console.h"
+
+static bool console_show_prompt = FALSE;
+static bool console_prompt_is_showing = FALSE;
+static bool console_rfcstyle = FALSE;
+#ifdef HAVE_LIBREADLINE
+static bool readline_received_enter = TRUE;
+#else
+static int con_dump(enum rfc_status rfc_status, const char *message, ...);
+#endif
+
+/************************************************************************
+  Print the prompt if it is not the last thing printed.
+************************************************************************/
+static void con_update_prompt(void)
+{
+  if (console_prompt_is_showing || !console_show_prompt)
+    return;
+
+#ifdef HAVE_LIBREADLINE
+  if (readline_received_enter) {
+    readline_received_enter = FALSE;
+  } else {
+    rl_forced_update_display();
+  }
+#else
+  con_dump(C_READY,"> ");
+  con_flush();
+#endif
+
+  console_prompt_is_showing = TRUE;
+}
+
+#ifndef HAVE_LIBREADLINE
+/************************************************************************
+  Write to console without line-break, don't print prompt.
+************************************************************************/
+static int con_dump(enum rfc_status rfc_status, const char *message, ...)
+{
+  static char buf[MAX_LEN_CONSOLE_LINE];
+  va_list args;
+
+  va_start(args, message);
+  my_vsnprintf(buf, sizeof(buf), message, args);
+  va_end(args);
+
+  if (console_prompt_is_showing) {
+    fc_printf("\n");
+  }
+  if ((console_rfcstyle) && (rfc_status >= 0)) {
+    fc_printf("%.3d %s", rfc_status, buf);
+  } else {
+    fc_printf("%s", buf);
+  }
+  console_prompt_is_showing = FALSE;
+  return (int) strlen(buf);
+}
+#endif
+
+/************************************************************************
+  Write to console and add line-break, and show prompt if required.
+************************************************************************/
+void con_write(enum rfc_status rfc_status, const char *message, ...)
+{
+  /* First buffer contains featured text tags */
+  static char buf1[(MAX_LEN_CONSOLE_LINE * 3) / 2];
+  static char buf2[MAX_LEN_CONSOLE_LINE];
+  va_list args;
+
+  va_start(args, message);
+  my_vsnprintf(buf1, sizeof(buf1), message, args);
+  va_end(args);
+
+  /* remove all format tags */
+  featured_text_to_plain_text(buf1, buf2, sizeof(buf2), NULL);
+  con_puts(rfc_status, buf2);
+}
+
+/************************************************************************
+  Write to console and add line-break, and show prompt if required.
+  Same as con_write, but without the format string stuff.
+  The real reason for this is because __attribute__ complained
+  with con_write(C_COMMENT,"") of "warning: zero-length format string";
+  this allows con_puts(C_COMMENT,"");
+************************************************************************/
+void con_puts(enum rfc_status rfc_status, const char *str)
+{
+  if (console_prompt_is_showing) {
+    fc_printf("\n");
+  }
+  if ((console_rfcstyle) && (rfc_status >= 0)) {
+    fc_printf("%.3d %s\n", rfc_status, str);
+  } else {
+    fc_printf("%s\n", str);
+  }
+  console_prompt_is_showing = FALSE;
+  con_update_prompt();
+}
+
+/************************************************************************
+  Write log messages to the console.
+************************************************************************/
+void con_log(enum log_level level, const char *message)
+{
+  if (console_rfcstyle) {
+    con_write(C_LOG_BASE + level, "%s", message);
+  } else {
+    con_write(C_LOG_BASE + level, "%d: %s", level, message);
+  }
+}
+
+/************************************************************************
+  Ensure timely update.
+************************************************************************/
+void con_flush(void)
+{
+  fflush(stdout);
+}
+
+/************************************************************************
+  Set style.
+************************************************************************/
+void con_set_style(bool i)
+{
+  console_rfcstyle = i;
+  if (console_rfcstyle) {
+    con_puts(C_OK, _("Ok. RFC-style set."));
+  } else {
+    con_puts(C_OK, _("Ok. Standard style set."));
+  }
+}
+
+/************************************************************************
+  Returns rfc-style.
+************************************************************************/
+bool con_get_style(void)
+{
+  return console_rfcstyle;
+}
+
+/************************************************************************
+  Initialize prompt; display initial message.
+************************************************************************/
+void con_prompt_init(void)
+{
+  static bool first = TRUE;
+
+  if (first) {
+    con_puts(C_COMMENT, "");
+    con_puts(C_COMMENT, _("For introductory help, type 'help'."));
+    first = FALSE;
+  }
+}
+
+/************************************************************************
+  Make sure a prompt is printed, and re-printed after every message.
+************************************************************************/
+void con_prompt_on(void)
+{
+  console_show_prompt = TRUE;
+  con_update_prompt();
+}
+
+/************************************************************************
+  Do not print a prompt after log messages.
+************************************************************************/
+void con_prompt_off(void)
+{
+  console_show_prompt = FALSE;
+}
+
+/************************************************************************
+  User pressed enter: will need a new prompt.
+************************************************************************/
+void con_prompt_enter(void)
+{
+  console_prompt_is_showing = FALSE;
+#ifdef HAVE_LIBREADLINE
+  readline_received_enter = TRUE;
+#endif
+}
+
+/************************************************************************
+  Clear "user pressed enter" state (used in special cases).
+************************************************************************/
+void con_prompt_enter_clear(void)
+{
+  console_prompt_is_showing = TRUE;
+#ifdef HAVE_LIBREADLINE
+  readline_received_enter = FALSE;
+#endif
+}
diff --git a/common/console.h b/common/console.h
new file mode 100644
index 0000000..5cb9f91
--- /dev/null
+++ b/common/console.h
@@ -0,0 +1,89 @@
+/**********************************************************************
+ Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+***********************************************************************/
+#ifndef FC__CONSOLE_H
+#define FC__CONSOLE_H
+
+#include "shared.h"		/* bool type and fc__attribute */
+#include "log.h"
+
+#define MAX_LEN_CONSOLE_LINE 512	/* closing \0 included */
+
+/*
+ * A note on "rfc-style":
+ *
+ * This style of server output, started with the /rfcstyle server
+ * command, prefixes all output with a status number. This is similar
+ * to how some common ascii based internet protocols like FTP and SMTP
+ * work. A parser can check these numbers to determine whether an
+ * action was successful or not, instead of attempting to parse the
+ * text (which can be translated into various languages and easily
+ * change between versions). This status number is given to the output
+ * functions below as their first parameter, or to cmd_reply* as their
+ * third parameter.
+ */
+
+enum rfc_status {
+  C_IGNORE = -1,           /* never print RFC-style number prefix */
+  C_COMMENT = 0,           /* for human eyes only */
+  C_VERSION = 1,           /* version info */
+  C_DEBUG = 2,             /* debug info */
+  C_LOG_BASE = 10,         /* 10, 11, 12 depending on log level */
+  C_OK = 100,              /* success of requested operation */
+  C_CONNECTION = 101,      /* new client */
+  C_DISCONNECTED = 102,    /* client gone */
+  C_REJECTED = 103,        /* client rejected */
+  C_FAIL = 200,            /* failure of requested operation */
+  C_METAERROR = 201,       /* failure of meta server */
+  C_SYNTAX = 300,          /* syntax error or value out of range */
+  C_BOUNCE = 301,          /* option no longer available */
+  C_GENFAIL = 400,         /* failure not caused by a requested operation */
+  C_WARNING = 500,         /* something may be wrong */
+  C_READY = 999            /* waiting for input */
+};
+
+/* write to console and add line-break, and show prompt if required. */
+void con_write(enum rfc_status rfc_status, const char *message, ...)
+               fc__attribute((__format__ (__printf__, 2, 3)));
+
+/* write to console and add line-break, and show prompt if required.
+   ie, same as con_write, but without the format string stuff. */
+void con_puts(enum rfc_status rfc_status, const char *str);
+
+/* write log messages to the console */
+void con_log(enum log_level level, const char *message);
+
+/* ensure timely update */
+void con_flush(void);
+
+/* initialize prompt; display initial message */
+void con_prompt_init(void);
+
+/* make sure a prompt is printed, and re-printed after every message */
+void con_prompt_on(void);
+
+/* do not print a prompt after every message */
+void con_prompt_off(void);
+
+/* user pressed enter: will need a new prompt */
+void con_prompt_enter(void);
+
+/* clear "user pressed enter" state (used in special cases) */
+void con_prompt_enter_clear(void);
+
+/* set server output style */
+void con_set_style(bool i);
+
+/* return server output style */
+bool con_get_style(void);
+
+#endif  /* FC__CONSOLE_H */
diff --git a/common/fc_types.h b/common/fc_types.h
index 2d55e0b..a91090a 100644
--- a/common/fc_types.h
+++ b/common/fc_types.h
@@ -293,6 +293,7 @@ BV_DEFINE(bv_bases, MAX_BASE_TYPES);
 enum gui_type {
   GUI_STUB,
   GUI_GTK2,
+  GUI_MAPIMG,
   GUI_SDL,
   GUI_XAW,
   GUI_WIN32,
diff --git a/configure.ac b/configure.ac
index 06c8edb..b13d95e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -110,17 +110,21 @@ WITH_READLINE=$withval,	dnl yes/no - required to use / never use
 WITH_READLINE="maybe"	dnl maybe  - use if found [default]
 )
 
+dnl checks for MagickWand support; sets WAND_CFLAGS, WAND_LIBS
+FC_CHECK_MAGICKWAND
+
 dnl no:   Do not compile client.
 dnl auto: Autodetect one.
 dnl all:  Autodetect as many as possible.
 dnl comma-separated-list: Detect these or abort.
 AC_ARG_ENABLE(client,
-[  --enable-client[=auto/all/gtk/sdl/xaw/win32/ftwl/stub)]
+[  --enable-client[=auto/all/gtk/mapimg/sdl/xaw/win32/ftwl/stub)]
                           clients to compile [[auto]] (or list for multiple)],
 [clients=${enableval}],
 [client=auto])
 
 gui_gtk2=no
+gui_mapimg=no
 gui_sdl=no
 gui_xaw=no
 gui_win32=no
@@ -146,6 +150,8 @@ for gui in $(echo $clients | $SED 's/,/ /g') ; do
        test "x$gui" = "xgtk20"  ||
        test "x$gui" = "xgtk-2.0" ; then
       gui_gtk2=yes
+    elif test "x$gui" = "xmapimg" ; then
+      gui_mapimg=yes
     else
       if test ! -d "${srcdir}/client/gui-$gui" ; then
         AC_MSG_ERROR(bad value ${gui} for --enable-client)
@@ -550,6 +556,9 @@ if test "x$client" != "xno"; then
     AS_MESSAGE([checking for which clients to compile:...])
   fi
 
+  dnl Gtk-2.0-mapimg-specific overrides
+  FC_MAPIMG_CLIENT
+
   dnl Gtk-2.0-specific overrides
   FC_GTK2_CLIENT
 
@@ -658,6 +667,10 @@ AC_SUBST([GUI_gtk2_CFLAGS])
 AC_SUBST([GUI_gtk2_CXXFLAGS])
 AC_SUBST([GUI_gtk2_LIBS])
 AC_SUBST([GUI_gtk2_LDFLAGS])
+AC_SUBST([GUI_mapimg_CFLAGS])
+AC_SUBST([GUI_mapimg_CXXFLAGS])
+AC_SUBST([GUI_mapimg_LIBS])
+AC_SUBST([GUI_mapimg_LDFLAGS])
 AC_SUBST([GUI_sdl_CFLAGS])
 AC_SUBST([GUI_sdl_CXXFLAGS])
 AC_SUBST([GUI_sdl_LIBS])
@@ -691,6 +704,7 @@ AC_SUBST([HOST_PATH_SEPARATOR])
 AM_CONDITIONAL(AUDIO_SDL, test "x$SDL_mixer" = "xyes")
 AM_CONDITIONAL(CLIENT_GUI_SDL, test "x$gui_sdl" = "xyes")
 AM_CONDITIONAL(CLIENT_GUI_GTK_2_0, test "x$gui_gtk2" = "xyes")
+AM_CONDITIONAL(CLIENT_GUI_GTK_2_0_MAPIMG, test "x$gui_mapimg" = "xyes")
 AM_CONDITIONAL(CLIENT_GUI_XAW, test "x$gui_xaw" = "xyes")
 AM_CONDITIONAL(CLIENT_GUI_STUB, test "x$gui_stub" = "xyes")
 AM_CONDITIONAL(CLIENT_GUI_WIN32, test "x$gui_win32" = "xyes")
@@ -1015,6 +1029,7 @@ AC_CONFIG_FILES([Makefile
 	  client/include/Makefile
 	  client/gui-sdl/Makefile
 	  client/gui-gtk-2.0/Makefile
+	  client/gui-gtk-2.0-mapimg/Makefile
 	  client/gui-xaw/Makefile
 	  client/gui-win32/Makefile
 	  client/gui-ftwl/Makefile
@@ -1082,6 +1097,7 @@ AC_MSG_NOTICE([
 
   Client frontends:
     Gtk-2.0: $gui_gtk2
+    Mapimg:  $gui_mapimg
     SDL:     $gui_sdl
     Xaw:     $gui_xaw
     Win32:   $gui_win32
diff --git a/data/amplio.tilespec b/data/amplio.tilespec
index 85a9f13..bff4dad 100644
--- a/data/amplio.tilespec
+++ b/data/amplio.tilespec
@@ -60,7 +60,7 @@ minimap_intro_file = "misc/radar"
 ; the data path. Order may be important for color allocation on 
 ; low-color systems, and if there are any duplicate tags (lattermost
 ; tag is used).
-files = 
+files =
   "amplio/terrain1.spec",
   "amplio/terrain2.spec",
   "amplio/ocean.spec",
@@ -83,8 +83,8 @@ files =
   "amplio/select.spec",
   "amplio/grid.spec",
   "misc/cursors.spec",
-  "misc/colors.spec",
   "misc/overlays.spec",
+  "misc/playercolors.spec",
   "misc/citybar.spec",
   "misc/shields.spec",
   "misc/editor.spec",
@@ -92,7 +92,9 @@ files =
 
 
 ; Include color definitions
-*include "misc/colors.tilespec"
+*include "misc/gamecolors.tilespec"
+*include "misc/playercolors.tilespec"
+*include "amplio/terraincolors.tilespec"
 
 ; Terrain info - see README.graphics
 
diff --git a/data/amplio/Makefile.am b/data/amplio/Makefile.am
index 6b85d1e..33f5b43 100644
--- a/data/amplio/Makefile.am
+++ b/data/amplio/Makefile.am
@@ -31,6 +31,7 @@ pkgdata_DATA =          	\
 	terrain1.spec		\
 	terrain2.png		\
 	terrain2.spec		\
+	terraincolors.tilespec	\
 	tiles.png		\
 	tiles.spec		\
 	units.png		\
diff --git a/data/amplio/terraincolors.tilespec b/data/amplio/terraincolors.tilespec
new file mode 100644
index 0000000..0ba5a62
--- /dev/null
+++ b/data/amplio/terraincolors.tilespec
@@ -0,0 +1,24 @@
+[terraincolors]
+
+; Tile tags should match [tile_*] sections in *.tilespec(s)
+; corresponding to graphic tag in terrain.ruleset(s)
+;
+; tile colors to match amplio tiles
+;   coast  == ocean
+;   floor  == depth ocean
+;   arctic == glacier
+tiles = {"r", "g", "b", "tag"
+   46, 120, 182, "lake"
+    0,  46, 137, "coast"
+    0,  33, 129, "floor"
+  240, 240, 240, "arctic"
+  214, 185, 106, "desert"
+   43, 107,  19, "forest"
+   11, 138,   4, "grassland"
+   24,  97,   5, "hills"
+   55, 156,  38, "jungle"
+  129, 127, 118, "mountains"
+  122, 156,  46, "plains"
+   48,  85,  97, "swamp"
+  188, 188, 188, "tundra"
+}
diff --git a/data/hex2t.tilespec b/data/hex2t.tilespec
index a867d5a..6814932 100644
--- a/data/hex2t.tilespec
+++ b/data/hex2t.tilespec
@@ -66,8 +66,8 @@ minimap_intro_file = "misc/radar"
 ; the data path. Order may be important for color allocation on 
 ; low-color systems, and if there are any duplicate tags (lattermost
 ; tag is used).
-files = 
-  "misc/colors.spec",
+files =
+  "misc/playercolors.spec",
   "misc/overlays.spec",
   "misc/citybar.spec",
   "hex2t/tiles.spec",
@@ -90,7 +90,9 @@ files =
 
 
 ; Include color definitions
-*include "misc/colors.tilespec"
+*include "misc/gamecolors.tilespec"
+*include "misc/playercolors.tilespec"
+*include "misc/terraincolors.tilespec"
 
 ; Terrain info - see README.graphics
 
diff --git a/data/isophex.tilespec b/data/isophex.tilespec
index 515a987..d95fb57 100644
--- a/data/isophex.tilespec
+++ b/data/isophex.tilespec
@@ -66,8 +66,8 @@ minimap_intro_file = "misc/radar"
 ; the data path. Order may be important for color allocation on 
 ; low-color systems, and if there are any duplicate tags (lattermost
 ; tag is used).
-files = 
-  "misc/colors.spec",
+files =
+  "misc/playercolors.spec",
   "misc/overlays.spec",
   "misc/citybar.spec",
   "isophex/terrain1.spec",
@@ -96,7 +96,9 @@ files =
 
 
 ; Include color definitions
-*include "misc/colors.tilespec"
+*include "misc/gamecolors.tilespec"
+*include "misc/playercolors.tilespec"
+*include "misc/terraincolors.tilespec"
 
 ; Terrain info - see README.graphics
 
diff --git a/data/isotrident.tilespec b/data/isotrident.tilespec
index 2fc239e..82f14d3 100644
--- a/data/isotrident.tilespec
+++ b/data/isotrident.tilespec
@@ -56,8 +56,8 @@ minimap_intro_file = "misc/radar"
 ; the data path. Order may be important for color allocation on 
 ; low-color systems, and if there are any duplicate tags (lattermost
 ; tag is used).
-files = 
-  "misc/colors.spec",
+files =
+  "misc/playercolors.spec",
   "misc/overlays.spec",
   "misc/citybar.spec",
   "isotrident/terrain1.spec",
@@ -86,7 +86,9 @@ files =
 
 
 ; Include color definitions
-*include "misc/colors.tilespec"
+*include "misc/gamecolors.tilespec"
+*include "misc/playercolors.tilespec"
+*include "misc/terraincolors.tilespec"
 
 ; Terrain info - see README.graphics
 
diff --git a/data/misc/Makefile.am b/data/misc/Makefile.am
index 1370b0f..94ebd05 100644
--- a/data/misc/Makefile.am
+++ b/data/misc/Makefile.am
@@ -12,18 +12,19 @@ pkgdata_DATA =          \
 	citybar.spec	\
 	cityicon.png	\
 	civicon.png	\
-	colors.png	\
-	colors.spec	\
-	colors.tilespec \
 	cursors.png	\
 	cursors.spec	\
 	editor.png	\
 	editor.spec	\
 	flags.spec	\
+	gamecolors.tilespec	\
 	icons.spec	\
 	intro.png	\
 	overlays.png	\
 	overlays.spec	\
+	playercolors.png	\
+	playercolors.spec	\
+	playercolors.tilespec	\
 	radar.png	\
 	shields.spec	\
 	small.png	\
@@ -32,6 +33,7 @@ pkgdata_DATA =          \
 	space.spec	\
 	techs.png	\
 	techs.spec	\
+	terraincolors.tilespec	\
 	treaty.png	\
 	treaty.spec
 
diff --git a/data/misc/colors.png b/data/misc/colors.png
deleted file mode 100644
index c652cc2..0000000
Binary files a/data/misc/colors.png and /dev/null differ
diff --git a/data/misc/colors.spec b/data/misc/colors.spec
deleted file mode 100644
index 3cd240c..0000000
--- a/data/misc/colors.spec
+++ /dev/null
@@ -1,66 +0,0 @@
-
-[spec]
-
-; Format and options of this spec file:
-options = "+spec3"
-
-[info]
-
-artists = "
-    Jason Dorje Short <jdorje@freeciv.org>
-"
-
-[file]
-gfx = "misc/colors"
-
-[grid_main]
-
-x_top_left = 2
-y_top_left = 2
-dx = 128
-dy = 64
-pixel_border=2
-
-tiles = { "row", "column", "tag"
-
-  0, 0, "colors.player0"
-  0, 1, "colors.player1"
-  0, 2, "colors.player2"
-  0, 3, "colors.player3"
-  0, 4, "colors.player4"
-
-  1, 0, "colors.player5"
-  1, 1, "colors.player6"
-  1, 2, "colors.player7"
-  1, 3, "colors.player8"
-  1, 4, "colors.player9"
-
-  2, 0, "colors.player10"
-  2, 1, "colors.player11"
-  2, 2, "colors.player12"
-  2, 3, "colors.player13"
-  2, 4, "colors.player14"
-
-  3, 0, "colors.player15"
-  3, 1, "colors.player16"
-  3, 2, "colors.player17"
-  3, 3, "colors.player18"
-  3, 4, "colors.player19"
-
-  4, 0, "colors.player20"
-  4, 1, "colors.player21"
-  4, 2, "colors.player22"
-  4, 3, "colors.player23"
-  4, 4, "colors.player24"
-
-  5, 0, "colors.player25"
-  5, 1, "colors.player26"
-  5, 2, "colors.player27"
-  5, 3, "colors.player28"
-  5, 4, "colors.player29"
-
-  6, 0, "colors.player30"
-  6, 1, "colors.player31"
-
-  6, 4, "colors.background"
-}
diff --git a/data/misc/colors.tilespec b/data/misc/colors.tilespec
deleted file mode 100644
index 250a957..0000000
--- a/data/misc/colors.tilespec
+++ /dev/null
@@ -1,180 +0,0 @@
-[colors]
-
-; Player colors should match those in colors.spec
-player = {"r", "g", "b"
-  255,   0,   0  ; race0
-    0, 128,   0  ; race1
-  255, 255, 255  ; race2
-  255, 255,   0  ; race3
-  138,  43, 226  ; race4
-  255, 140,   0  ; race5
-    0, 255, 255  ; race6
-  139,  69,  19  ; race7
-  211, 211, 211  ; race8
-  255, 215,   0  ; race9
-  255,  20, 147  ; race10
-  124, 252,   0  ; race11
-  218, 112, 214  ; race12
-   30, 144, 255  ; race13
-  250, 128, 114  ; race14
-  154, 205,  50  ; race15
-   25,  25, 112  ; race16
-    0, 255, 127  ; race17
-  139,   0,   0  ; race18
-  100, 149, 237  ; race19
-    0, 128, 128  ; race20
-  255, 192, 203  ; race21
-  255, 250, 205  ; race22
-  119, 136, 153  ; race23
-  255, 127,  80  ; race24
-  255,   0, 255  ; race25
-  128, 128,   0  ; race26
-  245, 222, 179  ; race27
-  184, 134,  11  ; race28
-  173, 216, 230  ; race29
-  102, 205, 170  ; race20
-  255, 165,   0  ; race31
-}
-
-; Tile tags should match [tile_*] sections in *.tilespec(s)
-; corresponding to graphic tag in terrain.ruleset(s)
-tiles = {"r", "g", "b", "tag"
-    0,   0, 220, "lake"
-    0,   0, 200, "coast"
-
-    0,   0, 170, "floor"
-
-  255, 255, 255, "arctic"
-
-  212, 179, 101, "desert"
-
-   43, 107,  19, "forest"
-
-   10, 123,   2, "grassland"
-
-  142, 121,  63, "hills"
-
-   54, 162,  38, "jungle"
-
-  138, 168,  60, "plains"
-
-  167,  77,  38, "mountains"
-
-   44,  64,  44, "swamp"
-
-   74,  74,  74, "tundra"
-}
-
-; Mapview
-mapview_unknown = {"r", "g", "b"
-    0,     0,   0
-}
-mapview_citytext = {"r", "g", "b"
-    255, 255, 255
-}
-mapview_cityblocked = {"r", "g", "b"
-    255,   0,   0
-}
-mapview_goto = {"r", "g", "b"
-    0,   255, 200
-}
-mapview_selection = {"r", "g", "b"
-    255, 255,   0
-}
-mapview_trade_route_line = {"r", "g", "b"
-    0,   255, 127
-}
-mapview_trade_routes_all_built = {"r", "g", "b"
-    0,   255,   0
-}
-mapview_trade_routes_some_built = {"r", "g", "b"
-    255, 255,   0
-}
-mapview_trade_routes_no_built = {"r", "g", "b"
-    255,   0,   0
-}
-mapview_city_link = {"r", "g", "b"
-    0,   255,   0
-}
-mapview_tile_link = {"r", "g", "b"
-    255,   0,   0
-}
-mapview_unit_link = {"r", "g", "b"
-    0,   255, 255
-}
-
-; Spaceship
-spaceship_background = {"r", "g", "b"
-    0,   0,   0
-}
-
-; Overview
-overview_unknown = {"r", "g", "b"
-    0,     0,   0
-}
-overview_mycity = {"r", "g", "b"
-    255, 255, 255
-}
-overview_alliedcity = {"r", "g", "b"
-    255, 255, 255
-}
-overview_enemycity = {"r", "g", "b"
-    0,   255, 200
-}
-overview_myunit = {"r", "g", "b"
-    255, 255,   0
-}
-overview_alliedunit = {"r", "g", "b"
-    255, 255, 255
-}
-overview_enemyunit = {"r", "g", "b"
-    255,   0,   0
-}
-overview_ocean = {"r", "g", "b"
-; Generic ocean, not the same as the Ocean terrain (see "tiles" above)
-    0,     0, 200
-}
-overview_ground = {"r", "g", "b"
-    0,   200,   0
-}
-overview_viewrect = {"r", "g", "b"
-    255, 255, 255
-}
-
-; Reqtree
-reqtree_known = {"r", "g", "b"
-    255, 255, 255
-}
-reqtree_prereqs_known = {"r", "g", "b"
-    210, 180, 140
-}
-reqtree_unknown = {"r", "g", "b"
-    190, 150, 110
-}
-reqtree_researching = {"r", "g", "b"
-    255, 250, 70
-}
-reqtree_goal_prereqs_known = {"r", "g", "b"
-    95,  160, 190
-}
-reqtree_goal_unknown = {"r", "g", "b"
-    85,  120, 180
-}
-reqtree_unreachable = {"r", "g", "b"
-    190, 150, 110
-}
-reqtree_background = {"r", "g", "b"
-    0,   0,   0
-}
-reqtree_text = {"r", "g", "b"
-    0,   0,   0
-}
-
-reqtree_edge = {"r", "g", "b"
-    127,   127,   127
-}
-  
-; Player dialog
-playerdlg_background = {"r", "g", "b"
-    0,   0,   0
-}
diff --git a/data/misc/gamecolors.tilespec b/data/misc/gamecolors.tilespec
new file mode 100644
index 0000000..e3a34e7
--- /dev/null
+++ b/data/misc/gamecolors.tilespec
@@ -0,0 +1,115 @@
+[gamecolors]
+
+; Mapview
+mapview_unknown = {"r", "g", "b"
+    0,     0,   0
+}
+mapview_citytext = {"r", "g", "b"
+    255, 255, 255
+}
+mapview_cityblocked = {"r", "g", "b"
+    255,   0,   0
+}
+mapview_goto = {"r", "g", "b"
+    0,   255, 200
+}
+mapview_selection = {"r", "g", "b"
+    255, 255,   0
+}
+mapview_trade_route_line = {"r", "g", "b"
+    0,   255, 127
+}
+mapview_trade_routes_all_built = {"r", "g", "b"
+    0,   255,   0
+}
+mapview_trade_routes_some_built = {"r", "g", "b"
+    255, 255,   0
+}
+mapview_trade_routes_no_built = {"r", "g", "b"
+    255,   0,   0
+}
+mapview_city_link = {"r", "g", "b"
+    0,   255,   0
+}
+mapview_tile_link = {"r", "g", "b"
+    255,   0,   0
+}
+mapview_unit_link = {"r", "g", "b"
+    0,   255, 255
+}
+
+; Spaceship
+spaceship_background = {"r", "g", "b"
+    0,   0,   0
+}
+
+; Overview
+overview_unknown = {"r", "g", "b"
+    0,     0,   0
+}
+overview_mycity = {"r", "g", "b"
+    255, 255, 255
+}
+overview_alliedcity = {"r", "g", "b"
+    255, 255, 255
+}
+overview_enemycity = {"r", "g", "b"
+    0,   255, 200
+}
+overview_myunit = {"r", "g", "b"
+    255, 255,   0
+}
+overview_alliedunit = {"r", "g", "b"
+    255, 255, 255
+}
+overview_enemyunit = {"r", "g", "b"
+    255,   0,   0
+}
+overview_ocean = {"r", "g", "b"
+; Generic ocean, not the same as the Ocean terrain (see "tiles" above)
+    0,     0, 200
+}
+overview_ground = {"r", "g", "b"
+    0,   200,   0
+}
+overview_viewrect = {"r", "g", "b"
+    255, 255, 255
+}
+
+; Reqtree
+reqtree_known = {"r", "g", "b"
+    255, 255, 255
+}
+reqtree_prereqs_known = {"r", "g", "b"
+    210, 180, 140
+}
+reqtree_unknown = {"r", "g", "b"
+    190, 150, 110
+}
+reqtree_researching = {"r", "g", "b"
+    255, 250, 70
+}
+reqtree_goal_prereqs_known = {"r", "g", "b"
+    95,  160, 190
+}
+reqtree_goal_unknown = {"r", "g", "b"
+    85,  120, 180
+}
+reqtree_unreachable = {"r", "g", "b"
+    190, 150, 110
+}
+reqtree_background = {"r", "g", "b"
+    0,   0,   0
+}
+reqtree_text = {"r", "g", "b"
+    0,   0,   0
+}
+
+reqtree_edge = {"r", "g", "b"
+    127,   127,   127
+}
+  
+; Player dialog
+playerdlg_background = {"r", "g", "b"
+    0,   0,   0
+}
diff --git a/data/misc/playercolors.png b/data/misc/playercolors.png
new file mode 100644
index 0000000..c652cc2
Binary files /dev/null and b/data/misc/playercolors.png differ
diff --git a/data/misc/playercolors.spec b/data/misc/playercolors.spec
new file mode 100644
index 0000000..76cf0d9
--- /dev/null
+++ b/data/misc/playercolors.spec
@@ -0,0 +1,66 @@
+
+[spec]
+
+; Format and options of this spec file:
+options = "+spec3"
+
+[info]
+
+artists = "
+    Jason Dorje Short <jdorje@freeciv.org>
+"
+
+[file]
+gfx = "misc/playercolors"
+
+[grid_main]
+
+x_top_left = 2
+y_top_left = 2
+dx = 128
+dy = 64
+pixel_border=2
+
+tiles = { "row", "column", "tag"
+
+  0, 0, "colors.player0"
+  0, 1, "colors.player1"
+  0, 2, "colors.player2"
+  0, 3, "colors.player3"
+  0, 4, "colors.player4"
+
+  1, 0, "colors.player5"
+  1, 1, "colors.player6"
+  1, 2, "colors.player7"
+  1, 3, "colors.player8"
+  1, 4, "colors.player9"
+
+  2, 0, "colors.player10"
+  2, 1, "colors.player11"
+  2, 2, "colors.player12"
+  2, 3, "colors.player13"
+  2, 4, "colors.player14"
+
+  3, 0, "colors.player15"
+  3, 1, "colors.player16"
+  3, 2, "colors.player17"
+  3, 3, "colors.player18"
+  3, 4, "colors.player19"
+
+  4, 0, "colors.player20"
+  4, 1, "colors.player21"
+  4, 2, "colors.player22"
+  4, 3, "colors.player23"
+  4, 4, "colors.player24"
+
+  5, 0, "colors.player25"
+  5, 1, "colors.player26"
+  5, 2, "colors.player27"
+  5, 3, "colors.player28"
+  5, 4, "colors.player29"
+
+  6, 0, "colors.player30"
+  6, 1, "colors.player31"
+
+  6, 4, "colors.background"
+}
diff --git a/data/misc/playercolors.tilespec b/data/misc/playercolors.tilespec
new file mode 100644
index 0000000..ce544a5
--- /dev/null
+++ b/data/misc/playercolors.tilespec
@@ -0,0 +1,37 @@
+[playercolors]
+
+; Player colors should match those in colors.spec
+player = {"r", "g", "b"
+  255,   0,   0  ; race0
+    0, 128,   0  ; race1
+  255, 255, 255  ; race2
+  255, 255,   0  ; race3
+  138,  43, 226  ; race4
+  255, 140,   0  ; race5
+    0, 255, 255  ; race6
+  139,  69,  19  ; race7
+  211, 211, 211  ; race8
+  255, 215,   0  ; race9
+  255,  20, 147  ; race10
+  124, 252,   0  ; race11
+  218, 112, 214  ; race12
+   30, 144, 255  ; race13
+  250, 128, 114  ; race14
+  154, 205,  50  ; race15
+   25,  25, 112  ; race16
+    0, 255, 127  ; race17
+  139,   0,   0  ; race18
+  100, 149, 237  ; race19
+    0, 128, 128  ; race20
+  255, 192, 203  ; race21
+  255, 250, 205  ; race22
+  119, 136, 153  ; race23
+  255, 127,  80  ; race24
+  255,   0, 255  ; race25
+  128, 128,   0  ; race26
+  245, 222, 179  ; race27
+  184, 134,  11  ; race28
+  173, 216, 230  ; race29
+  102, 205, 170  ; race20
+  255, 165,   0  ; race31
+}
diff --git a/data/misc/terraincolors.tilespec b/data/misc/terraincolors.tilespec
new file mode 100644
index 0000000..30ff6db
--- /dev/null
+++ b/data/misc/terraincolors.tilespec
@@ -0,0 +1,24 @@
+[terraincolors]
+
+; Tile tags should match [tile_*] sections in *.tilespec(s)
+; corresponding to graphic tag in terrain.ruleset(s)
+;
+;   coast  == ocean
+;   floor  == depth ocean
+;   arctic == glacier
+;
+tiles = {"r", "g", "b", "tag"
+    0,   0, 220, "lake"
+    0,   0, 200, "coast"
+    0,   0, 170, "floor"
+  255, 255, 255, "arctic"
+  212, 179, 101, "desert"
+   43, 107,  19, "forest"
+   10, 123,   2, "grassland"
+  142, 121,  63, "hills"
+   54, 162,  38, "jungle"
+  138, 168,  60, "plains"
+  167,  77,  38, "mountains"
+   44,  64,  44, "swamp"
+   74,  74,  74, "tundra"
+}
diff --git a/data/trident.tilespec b/data/trident.tilespec
index 975e811..8207332 100644
--- a/data/trident.tilespec
+++ b/data/trident.tilespec
@@ -56,8 +56,8 @@ minimap_intro_file = "misc/radar"
 ; the data path. Order may be important for color allocation on 
 ; low-color systems, and if there are any duplicate tags (lattermost
 ; tag is used).
-files = 
-  "misc/colors.spec",
+files =
+  "misc/playercolors.spec",
   "misc/overlays.spec",
   "misc/citybar.spec",
   "trident/tiles.spec",
@@ -82,7 +82,9 @@ files =
 
 
 ; Include color definitions
-*include "misc/colors.tilespec"
+*include "misc/gamecolors.tilespec"
+*include "misc/playercolors.tilespec"
+*include "misc/terraincolors.tilespec"
 
 ; Terrain info - see README.graphics
 
diff --git a/m4/magickwand.m4 b/m4/magickwand.m4
new file mode 100644
index 0000000..2604b1d
--- /dev/null
+++ b/m4/magickwand.m4
@@ -0,0 +1,47 @@
+# Check for Freeciv MagickWand support used to create png images of the map
+#
+# Called without any parameters.
+
+AC_DEFUN([FC_CHECK_MAGICKWAND],
+[
+  AC_ARG_WITH(magickwand,
+              [  --with-magickwand[=DIR]   Imagemagick installation directory (optional)],
+              magickwand_dir="$withval", magickwand_dir="")
+
+  WAND_CONFIG_PATH=""
+  if test x$magickwand_dir = x ; then
+    AC_MSG_CHECKING([for MagickWand-config in default path])
+
+    for i in /usr/local /usr;
+    do
+      test -r $i/bin/MagickWand-config && WAND_CONFIG_PATH=$i/bin && break
+    done
+  else
+    AC_MSG_CHECKING([for MagickWand-config])
+
+    test -r $magickwand_dir/MagickWand-config && WAND_CONFIG_PATH=$magickwand_dir
+  fi
+
+  if test -z "$WAND_CONFIG_PATH"; then
+    AC_MSG_RESULT([not found - falling back to ppm images])
+    wand=no
+  else
+    AC_MSG_RESULT([found in $WAND_CONFIG_PATH])
+    wand=yes
+  fi
+
+  if test x$wand = xyes ; then
+    AC_MSG_CHECKING([for MagickWand-config --cflags])
+    WAND_CFLAGS="`$WAND_CONFIG_PATH/MagickWand-config --cflags`"
+    AC_MSG_RESULT([$WAND_CFLAGS])
+
+    AC_MSG_CHECKING([for MagickWand-config --libs])
+    WAND_LIBS="`$WAND_CONFIG_PATH/MagickWand-config --libs`"
+    AC_MSG_RESULT([$WAND_LIBS])
+
+    AC_SUBST(WAND_CFLAGS)
+    AC_SUBST(WAND_LIBS)
+
+    AC_DEFINE(HAVE_WAND,1,[ ])
+  fi
+])
diff --git a/m4/mapimg-client.m4 b/m4/mapimg-client.m4
new file mode 100644
index 0000000..1102e65
--- /dev/null
+++ b/m4/mapimg-client.m4
@@ -0,0 +1,26 @@
+# Try to configure the GTK+-2.0 client (gui-gtk-2.0-mapimg)
+
+# FC_GTK_CLIENT
+# Test for GTK+-2.0 libraries needed for gui-gtk-2.0-mapimg
+
+AC_DEFUN([FC_MAPIMG_CLIENT],
+[
+  if test "x$gui_mapimg" = "xyes" || test "x$client" = "xauto" ||
+     test "x$client" = "xall" ; then
+    AM_PATH_GTK_2_0(2.4.0,
+      [
+        gui_mapimg=yes
+        # this is _not_ a full client!
+        GUI_mapimg_CFLAGS="$GTK_CFLAGS"
+        GUI_mapimg_LIBS="$GTK_LIBS"
+        if test "x$MINGW32" = "xyes"; then
+          dnl Required to compile gtk2 on Windows platform
+          GUI_mapimg_CFLAGS="$GUI_mapimg_CFLAGS -mms-bitfields"
+          GUI_mapimg_LDFLAGS="$GUI_mapimg_LDFLAGS -mwindows"
+        fi
+      ],
+      [
+        FC_NO_CLIENT([mapimg], [GTK+-2.0 libraries not found])
+      ])
+  fi
+])
diff --git a/manual/civmanual.c b/manual/civmanual.c
index b7a0ad8..8b9ec00 100644
--- a/manual/civmanual.c
+++ b/manual/civmanual.c
@@ -33,6 +33,7 @@
 
 /* common */
 #include "connection.h"
+#include "console.h"
 #include "events.h"
 #include "game.h"
 #include "improvement.h"
@@ -48,7 +49,6 @@
 #include "citytools.h"
 #include "commands.h"
 #include "connecthand.h"
-#include "console.h"
 #include "diplhand.h"
 #include "gamehand.h"
 #include "plrhand.h"
diff --git a/server/Makefile.am b/server/Makefile.am
index 4a4db9f..eabb405 100644
--- a/server/Makefile.am
+++ b/server/Makefile.am
@@ -35,8 +35,6 @@ libfreeciv_srv_la_SOURCES = \
 		commands.h	\
 		connecthand.c	\
 		connecthand.h	\
-		console.c	\
-		console.h	\
 		diplhand.c	\
 		diplhand.h	\
 		diplomats.c	\
diff --git a/server/civserver.c b/server/civserver.c
index 006ec31..736748b 100644
--- a/server/civserver.c
+++ b/server/civserver.c
@@ -46,11 +46,11 @@
 
 /* common */
 #include "capstr.h"
+#include "console.h"
 #include "game.h"
 #include "version.h"
 
 /* server */
-#include "console.h"
 #include "ggzserver.h"
 #include "meta.h"
 #include "sernet.h"
diff --git a/server/console.c b/server/console.c
deleted file mode 100644
index e46a974..0000000
--- a/server/console.c
+++ /dev/null
@@ -1,258 +0,0 @@
-/********************************************************************** 
- Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-***********************************************************************/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdarg.h>
-#include <stdio.h>
-#include <string.h>
-
-#ifdef HAVE_LIBREADLINE
-#include <readline/readline.h>
-#endif
-
-/* utility */
-#include "fciconv.h"
-#include "fcintl.h"
-#include "log.h"
-#include "support.h"
-
-/* common */
-#include "game.h"
-
-/* server */
-#include "notify.h"
-#include "srv_main.h"
-
-#include "console.h"
-
-static bool console_show_prompt = FALSE;
-static bool console_prompt_is_showing = FALSE;
-static bool console_rfcstyle = FALSE;
-#ifdef HAVE_LIBREADLINE
-static bool readline_received_enter = TRUE;
-#else
-static int con_dump(enum rfc_status rfc_status, const char *message, ...);
-#endif
-
-/************************************************************************
-Function to handle log messages.
-This must match the log_callback_fn typedef signature.
-************************************************************************/
-static void con_handle_log(enum log_level level, const char *message,
-                           bool file_too)
-{
-  if (LOG_ERROR == level) {
-    notify_conn(NULL, NULL, E_LOG_ERROR, ftc_warning, "%s", message);
-  } else if (LOG_FATAL >= level) {
-    /* Make sure that message is not left to buffers when server dies */
-    conn_list_iterate(game.est_connections, pconn) {
-      pconn->send_buffer->do_buffer_sends = 0;
-      pconn->compression.frozen_level = 0;
-    } conn_list_iterate_end;
-
-    notify_conn(NULL, NULL, E_LOG_FATAL, ftc_warning, "%s", message);
-    notify_conn(NULL, NULL, E_LOG_FATAL, ftc_warning,
-                _("Please report this message at %s"),
-                BUG_URL);
-  }
-
-  /* Write debug/verbose message to console only when not written to file. */
-  if (!file_too || level <= LOG_NORMAL) {
-    if (console_rfcstyle) {
-      con_write(C_LOG_BASE + level, "%s", message);
-    } else {
-      con_write(C_LOG_BASE + level, "%d: %s", level, message);
-    }
-  }
-}
-
-/************************************************************************
-Print the prompt if it is not the last thing printed.
-************************************************************************/
-static void con_update_prompt(void)
-{
-  if (console_prompt_is_showing || !console_show_prompt)
-    return;
-
-#ifdef HAVE_LIBREADLINE
-  if (readline_received_enter) {
-    readline_received_enter = FALSE;
-  } else {
-    rl_forced_update_display();
-  }
-#else
-  con_dump(C_READY,"> ");
-  con_flush();
-#endif
-
-  console_prompt_is_showing = TRUE;
-}
-
-/************************************************************************
-  Initialize logging via console.
-************************************************************************/
-void con_log_init(const char *log_filename, enum log_level level,
-                  int fatal_assertions)
-{
-  log_init(log_filename, level, con_handle_log, fatal_assertions);
-}
-
-#ifndef HAVE_LIBREADLINE
-/************************************************************************
-Write to console without line-break, don't print prompt.
-************************************************************************/
-static int con_dump(enum rfc_status rfc_status, const char *message, ...)
-{
-  static char buf[MAX_LEN_CONSOLE_LINE];
-  va_list args;
-  
-  va_start(args, message);
-  my_vsnprintf(buf, sizeof(buf), message, args);
-  va_end(args);
-
-  if (console_prompt_is_showing) {
-    fc_printf("\n");
-  }
-  if ((console_rfcstyle) && (rfc_status >= 0)) {
-    fc_printf("%.3d %s", rfc_status, buf);
-  } else {
-    fc_printf("%s", buf);
-  }
-  console_prompt_is_showing = FALSE;
-  return (int) strlen(buf);
-}
-#endif
-
-/************************************************************************
-Write to console and add line-break, and show prompt if required.
-************************************************************************/
-void con_write(enum rfc_status rfc_status, const char *message, ...)
-{
-  /* First buffer contains featured text tags */
-  static char buf1[(MAX_LEN_CONSOLE_LINE * 3) / 2];
-  static char buf2[MAX_LEN_CONSOLE_LINE];
-  va_list args;
-
-  va_start(args, message);
-  my_vsnprintf(buf1, sizeof(buf1), message, args);
-  va_end(args);
-
-  /* remove all format tags */
-  featured_text_to_plain_text(buf1, buf2, sizeof(buf2), NULL);
-  con_puts(rfc_status, buf2);
-}
-
-/************************************************************************
-Write to console and add line-break, and show prompt if required.
-Same as con_write, but without the format string stuff.
-The real reason for this is because __attribute__ complained
-with con_write(C_COMMENT,"") of "warning: zero-length format string";
-this allows con_puts(C_COMMENT,"");
-************************************************************************/
-void con_puts(enum rfc_status rfc_status, const char *str)
-{
-  if (console_prompt_is_showing) {
-    fc_printf("\n");
-  }
-  if ((console_rfcstyle) && (rfc_status >= 0)) {
-    fc_printf("%.3d %s\n", rfc_status, str);
-  } else {
-    fc_printf("%s\n", str);
-  }
-  console_prompt_is_showing = FALSE;
-  con_update_prompt();
-}
-
-/************************************************************************
-Ensure timely update. 
-************************************************************************/
-void con_flush(void)
-{
-  fflush(stdout);
-}
-
-/************************************************************************
-Set style.
-************************************************************************/
-void con_set_style(bool i)
-{
-  console_rfcstyle = i;
-  if (console_rfcstyle) 
-    con_puts(C_OK, _("Ok. RFC-style set."));
-  else
-    con_puts(C_OK, _("Ok. Standard style set."));
-}
-
-/************************************************************************
-Returns rfc-style.
-************************************************************************/
-bool con_get_style(void)
-{
-  return console_rfcstyle;
-}
-
-/************************************************************************
-Initialize prompt; display initial message.
-************************************************************************/
-void con_prompt_init(void)
-{
-  static bool first = TRUE;
-
-  if (first) {
-    con_puts(C_COMMENT, "");
-    con_puts(C_COMMENT, _("For introductory help, type 'help'."));
-    first = FALSE;
-  }
-}
-
-/************************************************************************
-Make sure a prompt is printed, and re-printed after every message.
-************************************************************************/
-void con_prompt_on(void)
-{
-  console_show_prompt = TRUE;
-  con_update_prompt();
-}
-
-/************************************************************************
-Do not print a prompt after log messages.
-************************************************************************/
-void con_prompt_off(void)
-{
-  console_show_prompt = FALSE;
-}
-
-/************************************************************************
-User pressed enter: will need a new prompt 
-************************************************************************/
-void con_prompt_enter(void)
-{
-  console_prompt_is_showing = FALSE;
-#ifdef HAVE_LIBREADLINE
-  readline_received_enter = TRUE;
-#endif
-}
-
-/************************************************************************
-Clear "user pressed enter" state (used in special cases).
-************************************************************************/
-void con_prompt_enter_clear(void)
-{
-  console_prompt_is_showing = TRUE;
-#ifdef HAVE_LIBREADLINE
-  readline_received_enter = FALSE;
-#endif
-}
diff --git a/server/console.h b/server/console.h
deleted file mode 100644
index 019c227..0000000
--- a/server/console.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/********************************************************************** 
- Freeciv - Copyright (C) 1996 - A Kjeldberg, L Gregersen, P Unold
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-***********************************************************************/
-#ifndef FC__CONSOLE_H
-#define FC__CONSOLE_H
-
-#include "shared.h"		/* bool type and fc__attribute */
-
-#define MAX_LEN_CONSOLE_LINE 512	/* closing \0 included */
-
-/* 
- * A note on "rfc-style":
- *
- * This style of server output, started with the /rfcstyle server
- * command, prefixes all output with a status number. This is similar
- * to how some common ascii based internet protocols like FTP and SMTP
- * work. A parser can check these numbers to determine whether an
- * action was successful or not, instead of attempting to parse the
- * text (which can be translated into various languages and easily
- * change between versions). This status number is given to the output
- * functions below as their first parameter, or to cmd_reply* as their
- * third parameter.
- */
-
-enum rfc_status {
-  C_IGNORE = -1,                /* never print RFC-style number prefix */
-  C_COMMENT = 0,                /* for human eyes only */
-  C_VERSION = 1,                /* version info */
-  C_DEBUG = 2,                  /* debug info */
-  C_LOG_BASE = 10,              /* 10, 11, 12 depending on log level */
-  C_OK = 100,                   /* success of requested operation */
-  C_CONNECTION = 101,           /* new client */
-  C_DISCONNECTED = 102,         /* client gone */
-  C_REJECTED = 103,             /* client rejected */
-  C_FAIL = 200,                 /* failure of requested operation */
-  C_METAERROR = 201,            /* failure of meta server */
-  C_SYNTAX = 300,               /* syntax error or value out of range */
-  C_BOUNCE = 301,               /* option no longer available */
-  C_GENFAIL = 400,              /* failure not caused by a requested operation */
-  C_WARNING = 500,              /* something may be wrong */
-  C_READY = 999                 /* waiting for input */
-};
-
-/* initialize logging via console */
-void con_log_init(const char *log_filename, enum log_level level,
-                  int fatal_assertions);
-
-/* write to console and add line-break, and show prompt if required. */
-void con_write(enum rfc_status rfc_status, const char *message, ...)
-     fc__attribute((__format__ (__printf__, 2, 3)));
-
-/* write to console and add line-break, and show prompt if required.
-   ie, same as con_write, but without the format string stuff. */
-void con_puts(enum rfc_status rfc_status, const char *str);
-     
-/* ensure timely update */
-void con_flush(void);
-
-/* initialize prompt; display initial message */
-void con_prompt_init(void);
-
-/* make sure a prompt is printed, and re-printed after every message */
-void con_prompt_on(void);
-
-/* do not print a prompt after every message */
-void con_prompt_off(void);
-
-/* user pressed enter: will need a new prompt */
-void con_prompt_enter(void);
-
-/* clear "user pressed enter" state (used in special cases) */
-void con_prompt_enter_clear(void);
-
-/* set server output style */
-void con_set_style(bool i);
-
-/* return server output style */
-bool con_get_style(void);
-
-#endif  /* FC__CONSOLE_H */
diff --git a/server/handchat.c b/server/handchat.c
index 17d1a3f..7fac55a 100644
--- a/server/handchat.c
+++ b/server/handchat.c
@@ -27,12 +27,12 @@
 #include "support.h"
 
 /* common */
+#include "console.h"
 #include "game.h"
 #include "packets.h"
 #include "player.h"
 
 /* server */
-#include "console.h"
 #include "notify.h"
 #include "stdinhand.h"
 
diff --git a/server/meta.c b/server/meta.c
index 5797037..d867577 100644
--- a/server/meta.c
+++ b/server/meta.c
@@ -42,6 +42,7 @@
 
 #include "capstr.h"
 #include "connection.h"
+#include "console.h"
 #include "dataio.h"
 #include "fcintl.h"
 #include "game.h"
@@ -53,7 +54,6 @@
 #include "version.h"
 
 /* server */
-#include "console.h"
 #include "plrhand.h"
 #include "srv_main.h"
 
diff --git a/server/sernet.c b/server/sernet.c
index b6bc3dd..1bc4885 100644
--- a/server/sernet.c
+++ b/server/sernet.c
@@ -63,6 +63,7 @@
 #include "fciconv.h"
 
 #include "capability.h"
+#include "console.h"
 #include "dataio.h"
 #include "events.h"
 #include "fcintl.h"
@@ -77,7 +78,6 @@
 
 #include "auth.h"
 #include "connecthand.h"
-#include "console.h"
 #include "ggzserver.h"
 #include "meta.h"
 #include "plrhand.h"
diff --git a/server/srv_main.c b/server/srv_main.c
index d09267e..d377d67 100644
--- a/server/srv_main.c
+++ b/server/srv_main.c
@@ -61,6 +61,7 @@
 /* common */
 #include "capstr.h"
 #include "city.h"
+#include "console.h"
 #include "dataio.h"
 #include "effects.h"
 #include "events.h"
@@ -94,7 +95,6 @@
 #include "citytools.h"
 #include "cityturn.h"
 #include "connecthand.h"
-#include "console.h"
 #include "diplhand.h"
 #include "edithand.h"
 #include "gamehand.h"
@@ -2104,6 +2104,34 @@ static void srv_running(void)
   free_timer(eot_timer);
 }
 
+/************************************************************************
+  Function to handle log messages on the server side.
+  This must match the log_callback_fn typedef signature.
+************************************************************************/
+static void server_log_callback(enum log_level level, const char *message,
+                                bool file_too)
+{
+  if (LOG_ERROR == level) {
+    notify_conn(NULL, NULL, E_LOG_ERROR, ftc_warning, "%s", message);
+  } else if (LOG_FATAL >= level) {
+    /* Make sure that message is not left to buffers when server dies */
+    conn_list_iterate(game.est_connections, pconn) {
+      pconn->send_buffer->do_buffer_sends = 0;
+      pconn->compression.frozen_level = 0;
+    } conn_list_iterate_end;
+
+    notify_conn(NULL, NULL, E_LOG_FATAL, ftc_warning, "%s", message);
+    notify_conn(NULL, NULL, E_LOG_FATAL, ftc_warning,
+                _("Please report this message at %s"),
+                BUG_URL);
+  }
+
+  /* Write debug/verbose message to console only when not written to file. */
+  if (!file_too || level <= LOG_NORMAL) {
+    con_log(level, message);
+  }
+}
+
 /**************************************************************************
   Server initialization.
 **************************************************************************/
@@ -2111,7 +2139,9 @@ static void srv_prepare(void)
 {
 #ifdef HAVE_AUTH
   if (!srvarg.auth_enabled) {
-    con_write(C_COMMENT, _("This civserver program has player authentication support, but it's currently not in use."));
+    con_write(C_COMMENT, _("This civserver program has player "
+                           "authentication support, but it's currently not "
+                           "in use."));
   }
 #endif /* HAVE_AUTH */
 
@@ -2122,15 +2152,15 @@ static void srv_prepare(void)
 
   fc_init_network();
 
-  con_log_init(srvarg.log_filename, srvarg.loglevel,
-               srvarg.fatal_assertions);
-  
+  log_init(srvarg.log_filename, srvarg.loglevel, server_log_callback,
+           srvarg.fatal_assertions);
+
 #if IS_BETA_VERSION
   con_puts(C_COMMENT, "");
   con_puts(C_COMMENT, beta_message());
   con_puts(C_COMMENT, "");
 #endif
-  
+
   con_flush();
 
   settings_init();
diff --git a/server/stdinhand.c b/server/stdinhand.c
index 985c95d..9ce6606 100644
--- a/server/stdinhand.c
+++ b/server/stdinhand.c
@@ -41,6 +41,7 @@
 
 /* common */
 #include "capability.h"
+#include "console.h"
 #include "events.h"
 #include "featured_text.h"
 #include "game.h"
@@ -58,7 +59,6 @@
 #include "citytools.h"
 #include "commands.h"
 #include "connecthand.h"
-#include "console.h"
 #include "diplhand.h"
 #include "gamehand.h"
 #include "ggzserver.h"
diff --git a/server/voting.c b/server/voting.c
index 30de148..865076e 100644
--- a/server/voting.c
+++ b/server/voting.c
@@ -25,12 +25,12 @@
 /* common */
 #include "capability.h"
 #include "connection.h"
+#include "console.h"
 #include "packets.h"
 #include "player.h"
 
 /* server */
 #include "commands.h"
-#include "console.h"
 #include "hand_gen.h"
 #include "notify.h"
 #include "settings.h"
